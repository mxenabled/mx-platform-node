/* tslint:disable */
/* eslint-disable */
/**
 * MX Platform API
 * The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.  Just getting started? See our [use case guides](/use-cases/). 
 *
 * The version of the OpenAPI document: 20111101
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ACHResponse
 */
export interface ACHResponse {
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'account_number_last_four'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'account_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'ach_initiated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'client_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'corrected_account_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'corrected_routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'institution_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'investigation_notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'processing_errors'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'resolution_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'resolution_detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'resolved_status_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'return_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'return_notes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'return_account_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'return_routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'return_status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'returned_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'sec_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'started_processing_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'submitted_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ACHResponse
     */
    'transaction_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHResponse
     */
    'user_guid'?: string;
}
/**
 * 
 * @export
 * @interface ACHReturnCreateRequest
 */
export interface ACHReturnCreateRequest {
    /**
     * The unique identifier for the account associated with the transaction. Defined by MX.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'account_guid': string;
    /**
     * The last 4 digits of the account number used for the transaction by the Originating Depository Financial Institution (ODFI).
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'account_number_last_four'?: string;
    /**
     * The date and time when the transaction was initiated by the Originating Depository Financial Institution (ODFI) in ISO 8601 format without timestamp.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'ach_initiated_at'?: string;
    /**
     * The account number correction reported by the RDFI. Populate only if the `resolution_code` is `NOTICE_OF_CHANGE`.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'corrected_account_number'?: string;
    /**
     * The routing number correction reported by the RDFI. Populate only if the `resolution_code` is `NOTICE_OF_CHANGE`. Must be a valid 9-digit routing number format.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'corrected_routing_number'?: string;
    /**
     * Client-defined identifier for this specific return submission. Allows you to track and reference you requests.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'id': string;
    /**
     * The unique identifier for the member associated with the transaction. Defined by MX.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'member_guid': string;
    /**
     * Incorrect account number used in the ACH transaction.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'return_account_number'?: string;
    /**
     * The associated ACH return code and notice of change code (for example, R02, R03, R04, R05, R20, NOC). See [Return Codes](/api-reference/platform-api/reference/ach-return-fields#return-codes) for a complete list.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'return_code': string;
    /**
     * Notes that you set to inform MX on internal ACH processing.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'return_notes'?: string;
    /**
     * Incorrect routing number used in the ACH transaction.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'return_routing_number'?: string;
    /**
     * The date and time when the return was reported by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'returned_at'?: string;
    /**
     * The SEC code (Standard Entry Class Code)â€“a three-letter code describing how a payment was authorized (for example, `WEB`). See [SEC Codes](/api-reference/platform-api/reference/ach-return-fields#sec-codes) for a complete list.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'sec_code'?: string;
    /**
     * The amount of the transaction.
     * @type {number}
     * @memberof ACHReturnCreateRequest
     */
    'transaction_amount'?: number;
    /**
     * The transaction amount range, used for impact assessment.
     * @type {number}
     * @memberof ACHReturnCreateRequest
     */
    'transaction_amount_range'?: number;
    /**
     * MX-defined identifier for the user associated with the ACH return.
     * @type {string}
     * @memberof ACHReturnCreateRequest
     */
    'user_guid': string;
}
/**
 * 
 * @export
 * @interface ACHReturnCreateRequestBody
 */
export interface ACHReturnCreateRequestBody {
    /**
     * 
     * @type {ACHReturnCreateRequest}
     * @memberof ACHReturnCreateRequestBody
     */
    'ach_return'?: ACHReturnCreateRequest;
}
/**
 * 
 * @export
 * @interface ACHReturnResponseBody
 */
export interface ACHReturnResponseBody {
    /**
     * 
     * @type {ACHResponse}
     * @memberof ACHReturnResponseBody
     */
    'ach_return'?: ACHResponse;
}
/**
 * 
 * @export
 * @interface ACHReturnsResponseBody
 */
export interface ACHReturnsResponseBody {
    /**
     * 
     * @type {Array<ACHResponse>}
     * @memberof ACHReturnsResponseBody
     */
    'ach_returns'?: Array<ACHResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof ACHReturnsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface AccountCreateRequest
 */
export interface AccountCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'account_subtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'account_type': string;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'apr'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'apy'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'available_balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'cash_surrender_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'credit_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'currency_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'death_benefit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'interest_rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCreateRequest
     */
    'is_business'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCreateRequest
     */
    'is_closed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCreateRequest
     */
    'is_hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'loan_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountCreateRequest
     */
    'original_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountCreateRequest
     */
    'property_type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountCreateRequest
     */
    'skip_webhook'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountCreateRequestBody
 */
export interface AccountCreateRequestBody {
    /**
     * 
     * @type {AccountCreateRequest}
     * @memberof AccountCreateRequestBody
     */
    'account'?: AccountCreateRequest;
}
/**
 * 
 * @export
 * @interface AccountNumberResponse
 */
export interface AccountNumberResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'institution_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'loan_guarantor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'loan_reference_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccountNumberResponse
     */
    'passed_validation'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'sequence_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'transit_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountNumberResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountNumbersResponseBody
 */
export interface AccountNumbersResponseBody {
    /**
     * 
     * @type {Array<AccountNumberResponse>}
     * @memberof AccountNumbersResponseBody
     */
    'account_numbers'?: Array<AccountNumberResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof AccountNumbersResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface AccountOwnerResponse
 */
export interface AccountOwnerResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'owner_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'postal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountOwnerResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountOwnersResponseBody
 */
export interface AccountOwnersResponseBody {
    /**
     * 
     * @type {Array<AccountOwnerResponse>}
     * @memberof AccountOwnersResponseBody
     */
    'account_owners'?: Array<AccountOwnerResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof AccountOwnersResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'account_number'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'account_number_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'account_ownership'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'annuity_policy_to_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'annuity_provider'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'annuity_term_year'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'apr'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'apr_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'apy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'apy_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'available_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'available_balance_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'available_credit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'available_credit_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'balance_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'calculated_apr'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'cash_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'cash_balance_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'cash_surrender_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'cash_surrender_value_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'credit_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'credit_limit_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'currency_code_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'day_payment_is_due'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'day_payment_is_due_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'death_benefit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'death_benefit_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'federal_insurance_status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_account_number'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_account_subtype'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_account_type'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_apr'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_apy'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_available_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_cash_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_cash_surrender_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_credit_limit'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_currency_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_day_payment_is_due'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_death_benefit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_holdings_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_interest_rate'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'feed_is_closed'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_last_payment'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_last_payment_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_loan_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_matures_on'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_minimum_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_minimum_payment'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_nickname'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_original_balance'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_payment_due_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_payoff_balance'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'feed_started_on'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_statement_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'feed_total_account_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'holdings_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'holdings_value_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'imported_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'institution_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'institution_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'insured_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'interest_rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'interest_rate_set_by'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'is_closed'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'is_closed_set_by'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'is_hidden'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'is_manual'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'last_payment'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'last_payment_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'last_payment_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'last_payment_at_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'loan_amount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'loan_amount_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'margin_balance'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'matures_on'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'matures_on_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'member_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'member_is_managed_by_user'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'metadata'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'minimum_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'minimum_balance_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'minimum_payment'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'minimum_payment_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'name_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'nickname'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'nickname_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'original_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'original_balance_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'pay_out_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'payment_due_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'payment_due_at_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'payoff_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'payoff_balance_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'premium_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'property_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'routing_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'started_on'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'started_on_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'statement_balance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'statement_balance_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'subtype'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'subtype_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'today_ugl_amount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'today_ugl_percentage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'total_account_value'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'total_account_value_set_by'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'total_account_value_ugl'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'type_set_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'user_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface AccountResponseBody
 */
export interface AccountResponseBody {
    /**
     * 
     * @type {AccountResponse}
     * @memberof AccountResponseBody
     */
    'account'?: AccountResponse;
}
/**
 * 
 * @export
 * @interface AccountUpdateRequest
 */
export interface AccountUpdateRequest {
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'account_subtype'?: string;
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'account_type'?: string;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'apr'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'apy'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'available_balance'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'balance'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'cash_surrender_value'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'credit_limit'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'currency_code'?: string;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'death_benefit'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'interest_rate'?: number;
    /**
     * Can be updated for manual accounts and aggregated accounts.
     * @type {boolean}
     * @memberof AccountUpdateRequest
     */
    'is_business'?: boolean;
    /**
     * Can only be updated for manual accounts.
     * @type {boolean}
     * @memberof AccountUpdateRequest
     */
    'is_closed'?: boolean;
    /**
     * Can be updated for manual accounts and aggregated accounts.
     * @type {boolean}
     * @memberof AccountUpdateRequest
     */
    'is_hidden'?: boolean;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'loan_amount'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'metadata'?: string;
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'name'?: string;
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'nickname'?: string;
    /**
     * Can only be updated for manual accounts.
     * @type {number}
     * @memberof AccountUpdateRequest
     */
    'original_balance'?: number;
    /**
     * Can only be updated for manual accounts.
     * @type {string}
     * @memberof AccountUpdateRequest
     */
    'property_type'?: string;
    /**
     * If set to true, prevents sending an account webhook for the update if that webhook type is enabled for you.
     * @type {boolean}
     * @memberof AccountUpdateRequest
     */
    'skip_webhook'?: boolean;
}
/**
 * 
 * @export
 * @interface AccountUpdateRequestBody
 */
export interface AccountUpdateRequestBody {
    /**
     * 
     * @type {AccountUpdateRequest}
     * @memberof AccountUpdateRequestBody
     */
    'account'?: AccountUpdateRequest;
}
/**
 * 
 * @export
 * @interface AccountsResponseBody
 */
export interface AccountsResponseBody {
    /**
     * 
     * @type {Array<AccountResponse>}
     * @memberof AccountsResponseBody
     */
    'accounts'?: Array<AccountResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof AccountsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface AuthorizationCodeRequest
 */
export interface AuthorizationCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationCodeRequest
     */
    'scope'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthorizationCodeRequestBody
 */
export interface AuthorizationCodeRequestBody {
    /**
     * 
     * @type {AuthorizationCodeRequest}
     * @memberof AuthorizationCodeRequestBody
     */
    'authorization_code'?: AuthorizationCodeRequest;
}
/**
 * 
 * @export
 * @interface AuthorizationCodeResponse
 */
export interface AuthorizationCodeResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationCodeResponse
     */
    'code'?: string | null;
}
/**
 * 
 * @export
 * @interface AuthorizationCodeResponseBody
 */
export interface AuthorizationCodeResponseBody {
    /**
     * 
     * @type {AuthorizationCodeResponse}
     * @memberof AuthorizationCodeResponseBody
     */
    'authorization_code'?: AuthorizationCodeResponse;
}
/**
 * 
 * @export
 * @interface BudgetCreateRequest
 */
export interface BudgetCreateRequest {
    /**
     * Unique identifier of the category.
     * @type {string}
     * @memberof BudgetCreateRequest
     */
    'category_guid': string;
    /**
     * Unique identifier of the parent budget. This is only required when creating a budget on a sub-category.
     * @type {string}
     * @memberof BudgetCreateRequest
     */
    'parent_guid': string;
    /**
     * Amount of the budget.
     * @type {number}
     * @memberof BudgetCreateRequest
     */
    'amount'?: number;
    /**
     * Additional information a partner can store on the budget.
     * @type {string}
     * @memberof BudgetCreateRequest
     */
    'metadata'?: string;
    /**
     * When set to true, this parameter will prevent a webhook from being triggered by the request.
     * @type {boolean}
     * @memberof BudgetCreateRequest
     */
    'skip_webhook'?: boolean;
}
/**
 * 
 * @export
 * @interface BudgetCreateRequestBody
 */
export interface BudgetCreateRequestBody {
    /**
     * 
     * @type {BudgetCreateRequest}
     * @memberof BudgetCreateRequestBody
     */
    'budget'?: BudgetCreateRequest;
}
/**
 * 
 * @export
 * @interface BudgetResponse
 */
export interface BudgetResponse {
    /**
     * A goal amount set by the user for a category\'s transaction total during a month.
     * @type {number}
     * @memberof BudgetResponse
     */
    'amount'?: number;
    /**
     * Unique identifier for the budget category. Defined by MX.
     * @type {string}
     * @memberof BudgetResponse
     */
    'category_guid'?: string;
    /**
     * Date and time the budget was created, represented in ISO 8601 format with timestamp.
     * @type {string}
     * @memberof BudgetResponse
     */
    'created_at'?: string;
    /**
     * Unique identifier for the budget. Defined by MX.
     * @type {string}
     * @memberof BudgetResponse
     */
    'guid'?: string;
    /**
     * If the budget has been exceeded, this field will be true. Otherwise, this field will be false.
     * @type {boolean}
     * @memberof BudgetResponse
     */
    'is_exceeded'?: boolean;
    /**
     * If the budget is off track, this field will be true. Otherwise, this field will be false.
     * @type {boolean}
     * @memberof BudgetResponse
     */
    'is_off_track'?: boolean;
    /**
     * Additional information a partner can store on the budget.
     * @type {string}
     * @memberof BudgetResponse
     */
    'metadata'?: string | null;
    /**
     * The name of the budget that is visible to the user (ie \"Food\", \"Bills\", \"Entertainment\", etc).
     * @type {string}
     * @memberof BudgetResponse
     */
    'name'?: string | null;
    /**
     * The percentage amount of off track spending. (Deprecated).
     * @type {number}
     * @memberof BudgetResponse
     */
    'off_track_percentage'?: number | null;
    /**
     * Unique identifier for the parent budget. Defined by MX.
     * @type {string}
     * @memberof BudgetResponse
     */
    'parent_guid'?: string | null;
    /**
     * The percentage of a budget that has been spent during the current calendar month Calculated as the transaction total divided by the amount and then multiplied by 100.A value of zero will be returned when `amount` is zero.
     * @type {number}
     * @memberof BudgetResponse
     */
    'percent_spent'?: number | null;
    /**
     * The projected amount of spending for the budget.
     * @type {number}
     * @memberof BudgetResponse
     */
    'projected_spending'?: number;
    /**
     * The revision number of this budget record.
     * @type {number}
     * @memberof BudgetResponse
     */
    'revision'?: number;
    /**
     * The cumulative amount of all transactions under the budget.
     * @type {any}
     * @memberof BudgetResponse
     */
    'transaction_total'?: any;
    /**
     * Date and time the budget was updated, represented in ISO 8601 format with timestamp.
     * @type {any}
     * @memberof BudgetResponse
     */
    'updated_at'?: any;
    /**
     * Unique identifier for the user. Defined by MX.
     * @type {any}
     * @memberof BudgetResponse
     */
    'user_guid'?: any;
}
/**
 * 
 * @export
 * @interface BudgetResponseBody
 */
export interface BudgetResponseBody {
    /**
     * 
     * @type {BudgetResponse}
     * @memberof BudgetResponseBody
     */
    'budget'?: BudgetResponse;
}
/**
 * 
 * @export
 * @interface BudgetUpdateRequest
 */
export interface BudgetUpdateRequest {
    /**
     * Amount of the budget.
     * @type {number}
     * @memberof BudgetUpdateRequest
     */
    'amount'?: number;
    /**
     * Additional information a partner can store on the budget.
     * @type {string}
     * @memberof BudgetUpdateRequest
     */
    'metadata'?: string;
    /**
     * When set to true, this parameter will prevent a webhook from being triggered by the request.
     * @type {boolean}
     * @memberof BudgetUpdateRequest
     */
    'skip_webhook'?: boolean;
}
/**
 * 
 * @export
 * @interface BudgetUpdateRequestBody
 */
export interface BudgetUpdateRequestBody {
    /**
     * 
     * @type {BudgetUpdateRequest}
     * @memberof BudgetUpdateRequestBody
     */
    'budget'?: BudgetUpdateRequest;
}
/**
 * 
 * @export
 * @interface CategoriesResponseBody
 */
export interface CategoriesResponseBody {
    /**
     * 
     * @type {Array<CategoryResponse>}
     * @memberof CategoriesResponseBody
     */
    'categories'?: Array<CategoryResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof CategoriesResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface CategoryCreateRequest
 */
export interface CategoryCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryCreateRequest
     */
    'parent_guid': string;
}
/**
 * 
 * @export
 * @interface CategoryCreateRequestBody
 */
export interface CategoryCreateRequestBody {
    /**
     * 
     * @type {CategoryCreateRequest}
     * @memberof CategoryCreateRequestBody
     */
    'category'?: CategoryCreateRequest;
}
/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * Category creation date-time.
     * @type {string}
     * @memberof CategoryResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CategoryResponse
     */
    'is_default'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CategoryResponse
     */
    'is_income'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'metadata'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'parent_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'updated_at'?: string | null;
}
/**
 * 
 * @export
 * @interface CategoryResponseBody
 */
export interface CategoryResponseBody {
    /**
     * 
     * @type {CategoryResponse}
     * @memberof CategoryResponseBody
     */
    'category'?: CategoryResponse;
}
/**
 * 
 * @export
 * @interface CategoryUpdateRequest
 */
export interface CategoryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUpdateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CategoryUpdateRequestBody
 */
export interface CategoryUpdateRequestBody {
    /**
     * 
     * @type {CategoryUpdateRequest}
     * @memberof CategoryUpdateRequestBody
     */
    'category'?: CategoryUpdateRequest;
}
/**
 * 
 * @export
 * @interface ChallengeResponse
 */
export interface ChallengeResponse {
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponse
     */
    'field_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponse
     */
    'image_data'?: string | null;
    /**
     * 
     * @type {Array<ImageOptionResponse>}
     * @memberof ChallengeResponse
     */
    'image_options'?: Array<ImageOptionResponse>;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {Array<OptionResponse>}
     * @memberof ChallengeResponse
     */
    'options'?: Array<OptionResponse>;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponse
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface ChallengesResponseBody
 */
export interface ChallengesResponseBody {
    /**
     * 
     * @type {Array<ChallengeResponse>}
     * @memberof ChallengesResponseBody
     */
    'challenges'?: Array<ChallengeResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof ChallengesResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface ConnectWidgetRequest
 */
export interface ConnectWidgetRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'client_redirect_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'color_scheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'current_institution_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'current_member_guid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'disable_background_agg'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'disable_institution_search'?: boolean;
    /**
     * This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to `true`. When set to `false`, the widget will **not** direct the end user to the institution\'s mobile application. This setting is not persistent. This setting currently only affects Chase institutions. 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'enable_app2app'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'include_identity'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'include_transactions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'is_mobile_webview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'mode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'oauth_referral_source'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectWidgetRequest
     */
    'ui_message_version'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetRequest
     */
    'ui_message_webview_url_scheme'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectWidgetRequest
     */
    'update_credentials'?: boolean;
}
/**
 * 
 * @export
 * @interface ConnectWidgetRequestBody
 */
export interface ConnectWidgetRequestBody {
    /**
     * 
     * @type {ConnectWidgetRequest}
     * @memberof ConnectWidgetRequestBody
     */
    'config'?: ConnectWidgetRequest;
}
/**
 * 
 * @export
 * @interface ConnectWidgetResponse
 */
export interface ConnectWidgetResponse {
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetResponse
     */
    'connect_widget_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectWidgetResponse
     */
    'guid'?: string | null;
}
/**
 * 
 * @export
 * @interface ConnectWidgetResponseBody
 */
export interface ConnectWidgetResponseBody {
    /**
     * 
     * @type {ConnectWidgetResponse}
     * @memberof ConnectWidgetResponseBody
     */
    'user'?: ConnectWidgetResponse;
}
/**
 * 
 * @export
 * @interface CredentialRequest
 */
export interface CredentialRequest {
    /**
     * 
     * @type {string}
     * @memberof CredentialRequest
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CredentialResponse
 */
export interface CredentialResponse {
    /**
     * 
     * @type {number}
     * @memberof CredentialResponse
     */
    'display_order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialResponse
     */
    'field_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialResponse
     */
    'field_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CredentialResponse
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface CredentialsResponseBody
 */
export interface CredentialsResponseBody {
    /**
     * 
     * @type {Array<CredentialResponse>}
     * @memberof CredentialsResponseBody
     */
    'credentials'?: Array<CredentialResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof CredentialsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface CreditCardProduct
 */
export interface CreditCardProduct {
    /**
     * 
     * @type {number}
     * @memberof CreditCardProduct
     */
    'annual_fee'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardProduct
     */
    'duration_of_introductory_rate_on_balance_transfer'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreditCardProduct
     */
    'duration_of_introductory_rate_on_purchases'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreditCardProduct
     */
    'guid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'has_cashback_rewards'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'has_other_rewards'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'has_travel_rewards'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'has_zero_introductory_annual_fee'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'has_zero_percent_introductory_rate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'has_zero_percent_introductory_rate_on_balance_transfer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'is_accepting_applicants'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'is_active_credit_card_product'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCardProduct
     */
    'is_small_business_card'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreditCardProduct
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreditCardProductResponse
 */
export interface CreditCardProductResponse {
    /**
     * 
     * @type {CreditCardProduct}
     * @memberof CreditCardProductResponse
     */
    'credit_card_product'?: CreditCardProduct;
}
/**
 * 
 * @export
 * @interface EnhanceTransactionResponse
 */
export interface EnhanceTransactionResponse {
    /**
     * 
     * @type {number}
     * @memberof EnhanceTransactionResponse
     */
    'amount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof EnhanceTransactionResponse
     */
    'categorized_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'category_guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnhanceTransactionResponse
     */
    'described_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'extended_transaction_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_bill_pay'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_direct_deposit'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_expense'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_income'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_international'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_overdraft_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_payroll_advance'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof EnhanceTransactionResponse
     */
    'is_subscription'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof EnhanceTransactionResponse
     */
    'merchant_category_code'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'merchant_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'merchant_location_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'original_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionResponse
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface EnhanceTransactionsRequest
 */
export interface EnhanceTransactionsRequest {
    /**
     * 
     * @type {number}
     * @memberof EnhanceTransactionsRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionsRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionsRequest
     */
    'extended_transaction_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionsRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionsRequest
     */
    'memo'?: string;
    /**
     * 
     * @type {number}
     * @memberof EnhanceTransactionsRequest
     */
    'merchant_category_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnhanceTransactionsRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface EnhanceTransactionsRequestBody
 */
export interface EnhanceTransactionsRequestBody {
    /**
     * 
     * @type {Array<EnhanceTransactionsRequest>}
     * @memberof EnhanceTransactionsRequestBody
     */
    'transactions'?: Array<EnhanceTransactionsRequest>;
}
/**
 * 
 * @export
 * @interface EnhanceTransactionsResponseBody
 */
export interface EnhanceTransactionsResponseBody {
    /**
     * 
     * @type {Array<EnhanceTransactionResponse>}
     * @memberof EnhanceTransactionsResponseBody
     */
    'transactions'?: Array<EnhanceTransactionResponse>;
}
/**
 * 
 * @export
 * @interface GoalRequest
 */
export interface GoalRequest {
    /**
     * Unique identifier of the account for the goal.
     * @type {string}
     * @memberof GoalRequest
     */
    'account_guid': string;
    /**
     * Amount of the goal.
     * @type {number}
     * @memberof GoalRequest
     */
    'amount': number;
    /**
     * The goal type.
     * @type {string}
     * @memberof GoalRequest
     */
    'goal_type_name': string;
    /**
     * The category of the goal.
     * @type {string}
     * @memberof GoalRequest
     */
    'meta_type_name': string;
    /**
     * The name of the goal.
     * @type {string}
     * @memberof GoalRequest
     */
    'name': string;
    /**
     * Date and time the goal was completed.
     * @type {string}
     * @memberof GoalRequest
     */
    'completed_at'?: string;
    /**
     * Determines if the goal has been spent.
     * @type {boolean}
     * @memberof GoalRequest
     */
    'has_been_spent'?: boolean;
    /**
     * Determines if the goal is complete.
     * @type {boolean}
     * @memberof GoalRequest
     */
    'is_complete'?: boolean;
    /**
     * Additional information a partner can store on the goal.
     * @type {string}
     * @memberof GoalRequest
     */
    'metadata'?: string;
    /**
     * The priority of the goal in relation to multiple goals.
     * @type {number}
     * @memberof GoalRequest
     */
    'position'?: number;
    /**
     * Date and time the goal is to complete. Intended for users to set their own goal completion dates.
     * @type {string}
     * @memberof GoalRequest
     */
    'targeted_to_complete_at'?: string;
}
/**
 * 
 * @export
 * @interface GoalRequestBody
 */
export interface GoalRequestBody {
    /**
     * 
     * @type {GoalRequest}
     * @memberof GoalRequestBody
     */
    'goal'?: GoalRequest;
}
/**
 * 
 * @export
 * @interface GoalResponse
 */
export interface GoalResponse {
    /**
     * Unique identifier of the account for the goal.
     * @type {string}
     * @memberof GoalResponse
     */
    'account_guid'?: string;
    /**
     * Amount of the goal.
     * @type {number}
     * @memberof GoalResponse
     */
    'amount'?: number;
    /**
     * Date and time the goal was completed.
     * @type {string}
     * @memberof GoalResponse
     */
    'completed_at'?: string;
    /**
     * The current amount of the goal.
     * @type {number}
     * @memberof GoalResponse
     */
    'current_amount'?: number;
    /**
     * The goal type.
     * @type {string}
     * @memberof GoalResponse
     */
    'goal_type_name'?: string;
    /**
     * Unique identifier for the goal. Defined by MX.
     * @type {string}
     * @memberof GoalResponse
     */
    'guid'?: string;
    /**
     * Determines if the goal has been spent.
     * @type {boolean}
     * @memberof GoalResponse
     */
    'has_been_spent'?: boolean;
    /**
     * Determines if the goal is complete.
     * @type {boolean}
     * @memberof GoalResponse
     */
    'is_complete'?: boolean;
    /**
     * Additional information a partner can store on the goal.
     * @type {string}
     * @memberof GoalResponse
     */
    'metadata'?: string;
    /**
     * The category of the goal.
     * @type {string}
     * @memberof GoalResponse
     */
    'meta_type_name'?: string;
    /**
     * The name of the goal.
     * @type {string}
     * @memberof GoalResponse
     */
    'name'?: string;
    /**
     * The priority of the goal in relation to multiple goals.
     * @type {number}
     * @memberof GoalResponse
     */
    'position'?: number;
    /**
     * Date and time the goal is projected to be completed.
     * @type {string}
     * @memberof GoalResponse
     */
    'projected_to_complete_at'?: string;
    /**
     * Date and time the goal is to complete. Intended for users to set their own goal completion dates.
     * @type {string}
     * @memberof GoalResponse
     */
    'targeted_to_complete_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalResponse
     */
    'track_type_name'?: string;
    /**
     * The unique identifier for the the user. Defined by MX.
     * @type {string}
     * @memberof GoalResponse
     */
    'user_guid'?: string;
}
/**
 * 
 * @export
 * @interface GoalResponseBody
 */
export interface GoalResponseBody {
    /**
     * 
     * @type {GoalResponse}
     * @memberof GoalResponseBody
     */
    'goal'?: GoalResponse;
}
/**
 * 
 * @export
 * @interface GoalsResponse
 */
export interface GoalsResponse {
    /**
     * Unique identifier of the account for the goal.
     * @type {string}
     * @memberof GoalsResponse
     */
    'account_guid'?: string;
    /**
     * Amount of the goal.
     * @type {number}
     * @memberof GoalsResponse
     */
    'amount'?: number;
    /**
     * The current amount of the goal.
     * @type {number}
     * @memberof GoalsResponse
     */
    'current_amount'?: number;
    /**
     * The unique identifier for the goal. Defined by MX.
     * @type {string}
     * @memberof GoalsResponse
     */
    'guid'?: string;
    /**
     * The goal type.
     * @type {string}
     * @memberof GoalsResponse
     */
    'goal_type_name'?: string;
    /**
     * The category of the goal.
     * @type {string}
     * @memberof GoalsResponse
     */
    'meta_type_name'?: string;
    /**
     * The name of the goal.
     * @type {string}
     * @memberof GoalsResponse
     */
    'name'?: string;
    /**
     * Date and time the goal was completed.
     * @type {string}
     * @memberof GoalsResponse
     */
    'completed_at'?: string;
    /**
     * Determines if the goal has been spent.
     * @type {boolean}
     * @memberof GoalsResponse
     */
    'has_been_spent'?: boolean;
    /**
     * Determines if the goal is complete.
     * @type {boolean}
     * @memberof GoalsResponse
     */
    'is_complete'?: boolean;
    /**
     * Additional information a partner can store on the goal.
     * @type {string}
     * @memberof GoalsResponse
     */
    'metadata'?: string;
    /**
     * The priority of the goal in relation to multiple goals.
     * @type {number}
     * @memberof GoalsResponse
     */
    'position'?: number;
    /**
     * The date on which the project was completed.
     * @type {string}
     * @memberof GoalsResponse
     */
    'projected_to_complete_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalsResponse
     */
    'targeted_to_complete_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoalsResponse
     */
    'track_type_name'?: string;
    /**
     * The unique identifier for the the user. Defined by MX.
     * @type {string}
     * @memberof GoalsResponse
     */
    'user_guid'?: string;
}
/**
 * 
 * @export
 * @interface GoalsResponseBody
 */
export interface GoalsResponseBody {
    /**
     * 
     * @type {Array<GoalsResponse>}
     * @memberof GoalsResponseBody
     */
    'goals'?: Array<GoalsResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof GoalsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface ImageOptionResponse
 */
export interface ImageOptionResponse {
    /**
     * 
     * @type {string}
     * @memberof ImageOptionResponse
     */
    'data_uri'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageOptionResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageOptionResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageOptionResponse
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface InsightResponse
 */
export interface InsightResponse {
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'active_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'client_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'cta_clicked_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'has_associated_accounts'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'has_associated_categories'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'has_associated_merchants'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'has_associated_scheduled_payments'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'has_associated_transactions'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'has_been_displayed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InsightResponse
     */
    'is_dismissed'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'micro_call_to_action'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'micro_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'micro_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'template'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InsightResponse
     */
    'user_guid'?: string;
    /**
     * 
     * @type {any}
     * @memberof InsightResponse
     */
    'user_id'?: any;
}
/**
 * 
 * @export
 * @interface InsightResponseBody
 */
export interface InsightResponseBody {
    /**
     * 
     * @type {InsightResponse}
     * @memberof InsightResponseBody
     */
    'insight'?: InsightResponse;
}
/**
 * 
 * @export
 * @interface InsightUpdateRequest
 */
export interface InsightUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof InsightUpdateRequest
     */
    'has_been_displayed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InsightUpdateRequest
     */
    'is_dismissed'?: boolean;
}
/**
 * 
 * @export
 * @interface InsightUpdateRequestBody
 */
export interface InsightUpdateRequestBody {
    /**
     * 
     * @type {InsightUpdateRequest}
     * @memberof InsightUpdateRequestBody
     */
    'insight'?: InsightUpdateRequest;
}
/**
 * 
 * @export
 * @interface InsightsResponseBody
 */
export interface InsightsResponseBody {
    /**
     * 
     * @type {Array<InsightResponse>}
     * @memberof InsightsResponseBody
     */
    'insights'?: Array<InsightResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof InsightsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface InstitutionResponse
 */
export interface InstitutionResponse {
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'forgot_password_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'forgot_username_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'instructional_text'?: string | null;
    /**
     * An array of instructional steps that may contain html elements.
     * @type {Array<string>}
     * @memberof InstitutionResponse
     */
    'instructional_text_steps'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'is_disabled_by_client'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'iso_country_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'medium_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'small_logo_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'supports_account_identification'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'supports_account_statement'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'supports_account_verification'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'supports_oauth'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'supports_tax_document'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof InstitutionResponse
     */
    'supports_transaction_history'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'trouble_signing_in_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstitutionResponse
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface InstitutionResponseBody
 */
export interface InstitutionResponseBody {
    /**
     * 
     * @type {InstitutionResponse}
     * @memberof InstitutionResponseBody
     */
    'institution'?: InstitutionResponse;
}
/**
 * 
 * @export
 * @interface InstitutionsResponseBody
 */
export interface InstitutionsResponseBody {
    /**
     * 
     * @type {Array<InstitutionResponse>}
     * @memberof InstitutionsResponseBody
     */
    'institutions'?: Array<InstitutionResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof InstitutionsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface InvestmentHoldingResponse
 */
export interface InvestmentHoldingResponse {
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'cost_basis'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'coupon_yield'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'current_price'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'daily_change'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'expiration'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'face_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'frequency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'market_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'maturity_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'percentage_change'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'purchase_price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'quantity'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'strike_price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'symbol'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'term'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'today_ugl_amount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'today_ugl_percentage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'total_ugl_amount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'total_ugl_percentage'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'unvested_quantity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'unvested_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'user_guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'vested_quantity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvestmentHoldingResponse
     */
    'vested_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'current_price_as_of'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'issue_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'vesting_start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'vesting_end_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'put_or_call'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'holding_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InvestmentHoldingResponse
     */
    'term_unit'?: string | null;
}
/**
 * 
 * @export
 * @interface InvestmentHoldingResponseBody
 */
export interface InvestmentHoldingResponseBody {
    /**
     * 
     * @type {InvestmentHoldingResponse}
     * @memberof InvestmentHoldingResponseBody
     */
    'investment_holding'?: InvestmentHoldingResponse;
}
/**
 * 
 * @export
 * @interface InvestmentHoldingsDeactivation
 */
export interface InvestmentHoldingsDeactivation {
    /**
     * 
     * @type {any}
     * @memberof InvestmentHoldingsDeactivation
     */
    'message'?: any;
    /**
     * 
     * @type {any}
     * @memberof InvestmentHoldingsDeactivation
     */
    'status'?: any;
}
/**
 * 
 * @export
 * @interface InvestmentHoldingsResponseBody
 */
export interface InvestmentHoldingsResponseBody {
    /**
     * 
     * @type {Array<InvestmentHoldingResponse>}
     * @memberof InvestmentHoldingsResponseBody
     */
    'investment_holdings'?: Array<InvestmentHoldingResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof InvestmentHoldingsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface ManagedAccountCreateRequest
 */
export interface ManagedAccountCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'account_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'apr'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'apy'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'available_balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'available_credit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'cash_surrender_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'credit_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'currency_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'day_payment_is_due'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'death_benefit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'interest_rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedAccountCreateRequest
     */
    'is_closed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedAccountCreateRequest
     */
    'is_hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'last_payment'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'last_payment_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'loan_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'matures_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'minimum_balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'minimum_payment'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'original_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'payment_due_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountCreateRequest
     */
    'payoff_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'routing_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'started_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'subtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountCreateRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ManagedAccountCreateRequestBody
 */
export interface ManagedAccountCreateRequestBody {
    /**
     * 
     * @type {ManagedAccountCreateRequest}
     * @memberof ManagedAccountCreateRequestBody
     */
    'account'?: ManagedAccountCreateRequest;
}
/**
 * 
 * @export
 * @interface ManagedAccountUpdateRequest
 */
export interface ManagedAccountUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'account_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'apr'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'apy'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'available_balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'available_credit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'cash_surrender_value'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'credit_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'currency_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'day_payment_is_due'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'death_benefit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'interest_rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedAccountUpdateRequest
     */
    'is_closed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedAccountUpdateRequest
     */
    'is_hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'last_payment'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'last_payment_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'loan_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'matures_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'minimum_balance'?: number;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'minimum_payment'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'original_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'payment_due_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedAccountUpdateRequest
     */
    'payoff_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'routing_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'started_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'subtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedAccountUpdateRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ManagedAccountUpdateRequestBody
 */
export interface ManagedAccountUpdateRequestBody {
    /**
     * 
     * @type {ManagedAccountUpdateRequest}
     * @memberof ManagedAccountUpdateRequestBody
     */
    'account'?: ManagedAccountUpdateRequest;
}
/**
 * 
 * @export
 * @interface ManagedMemberCreateRequest
 */
export interface ManagedMemberCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberCreateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberCreateRequest
     */
    'institution_code': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberCreateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ManagedMemberCreateRequestBody
 */
export interface ManagedMemberCreateRequestBody {
    /**
     * 
     * @type {ManagedMemberCreateRequest}
     * @memberof ManagedMemberCreateRequestBody
     */
    'member'?: ManagedMemberCreateRequest;
}
/**
 * 
 * @export
 * @interface ManagedMemberUpdateRequest
 */
export interface ManagedMemberUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberUpdateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedMemberUpdateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ManagedMemberUpdateRequestBody
 */
export interface ManagedMemberUpdateRequestBody {
    /**
     * 
     * @type {ManagedMemberUpdateRequest}
     * @memberof ManagedMemberUpdateRequestBody
     */
    'member'?: ManagedMemberUpdateRequest;
}
/**
 * 
 * @export
 * @interface ManagedTransactionCreateRequest
 */
export interface ManagedTransactionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'check_number_string'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedTransactionCreateRequest
     */
    'is_international'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ManagedTransactionCreateRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'localized_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'localized_memo'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedTransactionCreateRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'memo'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedTransactionCreateRequest
     */
    'merchant_category_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'merchant_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'merchant_location_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'posted_at': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'transacted_at': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionCreateRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ManagedTransactionCreateRequestBody
 */
export interface ManagedTransactionCreateRequestBody {
    /**
     * 
     * @type {ManagedTransactionCreateRequest}
     * @memberof ManagedTransactionCreateRequestBody
     */
    'transaction'?: ManagedTransactionCreateRequest;
}
/**
 * 
 * @export
 * @interface ManagedTransactionUpdateRequest
 */
export interface ManagedTransactionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'check_number_string'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'currency_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedTransactionUpdateRequest
     */
    'is_international'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ManagedTransactionUpdateRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'localized_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'localized_memo'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedTransactionUpdateRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'memo'?: string;
    /**
     * 
     * @type {number}
     * @memberof ManagedTransactionUpdateRequest
     */
    'merchant_category_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'merchant_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'merchant_location_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'posted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'transacted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionUpdateRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ManagedTransactionUpdateRequestBody
 */
export interface ManagedTransactionUpdateRequestBody {
    /**
     * 
     * @type {ManagedTransactionUpdateRequest}
     * @memberof ManagedTransactionUpdateRequestBody
     */
    'transaction'?: ManagedTransactionUpdateRequest;
}
/**
 * 
 * @export
 * @interface MemberCreateRequest
 */
export interface MemberCreateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof MemberCreateRequest
     */
    'background_aggregation_is_disabled'?: boolean;
    /**
     * 
     * @type {Array<CredentialRequest>}
     * @memberof MemberCreateRequest
     */
    'credentials': Array<CredentialRequest>;
    /**
     * 
     * @type {string}
     * @memberof MemberCreateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberCreateRequest
     */
    'institution_code': string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberCreateRequest
     */
    'is_oauth'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MemberCreateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberCreateRequest
     */
    'skip_aggregation'?: boolean;
    /**
     * The use case associated with the member. Valid values are `PFM` and/or `MONEY_MOVEMENT`. Only set this if you\'ve met with MX and have opted in to using this field.
     * @type {Array<string>}
     * @memberof MemberCreateRequest
     */
    'use_cases'?: Array<MemberCreateRequestUseCasesEnum>;
}

export const MemberCreateRequestUseCasesEnum = {
    MoneyMovement: 'MONEY_MOVEMENT',
    Pfm: 'PFM'
} as const;

export type MemberCreateRequestUseCasesEnum = typeof MemberCreateRequestUseCasesEnum[keyof typeof MemberCreateRequestUseCasesEnum];

/**
 * 
 * @export
 * @interface MemberCreateRequestBody
 */
export interface MemberCreateRequestBody {
    /**
     * 
     * @type {string}
     * @memberof MemberCreateRequestBody
     */
    'client_redirect_url'?: string;
    /**
     * This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to `true`. When set to `false`, any `oauth_window_uri` generated will **not** direct the end user to the institution\'s mobile application. This setting is not persistent. This setting currently only affects Chase institutions. 
     * @type {boolean}
     * @memberof MemberCreateRequestBody
     */
    'enable_app2app'?: boolean;
    /**
     * 
     * @type {MemberCreateRequest}
     * @memberof MemberCreateRequestBody
     */
    'member'?: MemberCreateRequest;
    /**
     * 
     * @type {string}
     * @memberof MemberCreateRequestBody
     */
    'referral_source'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberCreateRequestBody
     */
    'ui_message_webview_url_scheme'?: string;
}
/**
 * 
 * @export
 * @interface MemberElements
 */
export interface MemberElements {
    /**
     * 
     * @type {string}
     * @memberof MemberElements
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberElements
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberElements
     */
    'user_guid'?: string;
}
/**
 * 
 * @export
 * @interface MemberResponse
 */
export interface MemberResponse {
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'aggregated_at'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'background_aggregation_is_disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'connection_status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'connection_status_message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'institution_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'institution_guid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'is_being_aggregated'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'is_managed_by_user'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'is_manual'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'is_oauth'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'metadata'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemberResponse
     */
    'most_recent_job_detail_code'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'most_recent_job_detail_text'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'most_recent_job_guid'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberResponse
     */
    'needs_updated_credentials'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'oauth_window_uri'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'successfully_aggregated_at'?: string | null;
    /**
     * The use case associated with the member. Valid values are `PFM` and/or `MONEY_MOVEMENT`. Only set this if you\'ve met with MX and have opted in to using this field.
     * @type {Array<string>}
     * @memberof MemberResponse
     */
    'use_cases'?: Array<MemberResponseUseCasesEnum>;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'user_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberResponse
     */
    'user_id'?: string | null;
}

export const MemberResponseUseCasesEnum = {
    MoneyMovement: 'MONEY_MOVEMENT',
    Pfm: 'PFM'
} as const;

export type MemberResponseUseCasesEnum = typeof MemberResponseUseCasesEnum[keyof typeof MemberResponseUseCasesEnum];

/**
 * 
 * @export
 * @interface MemberResponseBody
 */
export interface MemberResponseBody {
    /**
     * 
     * @type {MemberResponse}
     * @memberof MemberResponseBody
     */
    'member'?: MemberResponse;
}
/**
 * 
 * @export
 * @interface MemberResumeRequest
 */
export interface MemberResumeRequest {
    /**
     * 
     * @type {Array<CredentialRequest>}
     * @memberof MemberResumeRequest
     */
    'challenges'?: Array<CredentialRequest>;
}
/**
 * 
 * @export
 * @interface MemberResumeRequestBody
 */
export interface MemberResumeRequestBody {
    /**
     * 
     * @type {MemberResumeRequest}
     * @memberof MemberResumeRequestBody
     */
    'member'?: MemberResumeRequest;
}
/**
 * 
 * @export
 * @interface MemberStatusResponse
 */
export interface MemberStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof MemberStatusResponse
     */
    'aggregated_at'?: string | null;
    /**
     * 
     * @type {Array<ChallengeResponse>}
     * @memberof MemberStatusResponse
     */
    'challenges'?: Array<ChallengeResponse>;
    /**
     * 
     * @type {string}
     * @memberof MemberStatusResponse
     */
    'connection_status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemberStatusResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberStatusResponse
     */
    'has_processed_account_numbers'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberStatusResponse
     */
    'has_processed_accounts'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberStatusResponse
     */
    'has_processed_transactions'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberStatusResponse
     */
    'is_authenticated'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MemberStatusResponse
     */
    'is_being_aggregated'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof MemberStatusResponse
     */
    'successfully_aggregated_at'?: string | null;
}
/**
 * 
 * @export
 * @interface MemberStatusResponseBody
 */
export interface MemberStatusResponseBody {
    /**
     * 
     * @type {MemberStatusResponse}
     * @memberof MemberStatusResponseBody
     */
    'member'?: MemberStatusResponse;
}
/**
 * 
 * @export
 * @interface MemberUpdateRequest
 */
export interface MemberUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof MemberUpdateRequest
     */
    'background_aggregation_is_disabled'?: boolean;
    /**
     * 
     * @type {Array<CredentialRequest>}
     * @memberof MemberUpdateRequest
     */
    'credentials'?: Array<CredentialRequest>;
    /**
     * 
     * @type {string}
     * @memberof MemberUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberUpdateRequest
     */
    'metadata'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberUpdateRequest
     */
    'skip_aggregation'?: boolean;
    /**
     * The use case associated with the member. Valid values are `PFM` and/or `MONEY_MOVEMENT`. Only set this if you\'ve met with MX and have opted in to using this field.
     * @type {Array<string>}
     * @memberof MemberUpdateRequest
     */
    'use_cases'?: Array<MemberUpdateRequestUseCasesEnum>;
}

export const MemberUpdateRequestUseCasesEnum = {
    MoneyMovement: 'MONEY_MOVEMENT',
    Pfm: 'PFM'
} as const;

export type MemberUpdateRequestUseCasesEnum = typeof MemberUpdateRequestUseCasesEnum[keyof typeof MemberUpdateRequestUseCasesEnum];

/**
 * 
 * @export
 * @interface MemberUpdateRequestBody
 */
export interface MemberUpdateRequestBody {
    /**
     * 
     * @type {MemberUpdateRequest}
     * @memberof MemberUpdateRequestBody
     */
    'member'?: MemberUpdateRequest;
}
/**
 * 
 * @export
 * @interface MembersResponseBody
 */
export interface MembersResponseBody {
    /**
     * 
     * @type {Array<MemberResponse>}
     * @memberof MembersResponseBody
     */
    'members'?: Array<MemberResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof MembersResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface MerchantLocationResponse
 */
export interface MerchantLocationResponse {
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MerchantLocationResponse
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MerchantLocationResponse
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'merchant_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'postal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'state'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'street_address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantLocationResponse
     */
    'updated_at'?: string | null;
}
/**
 * 
 * @export
 * @interface MerchantLocationResponseBody
 */
export interface MerchantLocationResponseBody {
    /**
     * 
     * @type {MerchantLocationResponse}
     * @memberof MerchantLocationResponseBody
     */
    'merchant_location'?: MerchantLocationResponse;
}
/**
 * 
 * @export
 * @interface MerchantResponse
 */
export interface MerchantResponse {
    /**
     * 
     * @type {string}
     * @memberof MerchantResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponse
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponse
     */
    'website_url'?: string | null;
}
/**
 * 
 * @export
 * @interface MerchantResponseBody
 */
export interface MerchantResponseBody {
    /**
     * 
     * @type {MerchantResponse}
     * @memberof MerchantResponseBody
     */
    'merchant'?: MerchantResponse;
}
/**
 * 
 * @export
 * @interface MerchantsResponseBody
 */
export interface MerchantsResponseBody {
    /**
     * 
     * @type {Array<MerchantResponse>}
     * @memberof MerchantsResponseBody
     */
    'merchants'?: Array<MerchantResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof MerchantsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface MicrodepositElements
 */
export interface MicrodepositElements {
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'account_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'account_type': string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositElements
     */
    'routing_number': string;
}
/**
 * 
 * @export
 * @interface MicrodepositRequestBody
 */
export interface MicrodepositRequestBody {
    /**
     * 
     * @type {MicrodepositElements}
     * @memberof MicrodepositRequestBody
     */
    'micro_deposit'?: MicrodepositElements;
}
/**
 * 
 * @export
 * @interface MicrodepositResponse
 */
export interface MicrodepositResponse {
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'error_message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'institution_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'institution_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponse
     */
    'verified_at'?: string | null;
}
/**
 * 
 * @export
 * @interface MicrodepositResponseBody
 */
export interface MicrodepositResponseBody {
    /**
     * 
     * @type {Array<MicrodepositResponseBodyMicroDepositInner>}
     * @memberof MicrodepositResponseBody
     */
    'micro_deposit'?: Array<MicrodepositResponseBodyMicroDepositInner>;
}
/**
 * 
 * @export
 * @interface MicrodepositResponseBodyMicroDepositInner
 */
export interface MicrodepositResponseBodyMicroDepositInner {
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'account_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'account_type': string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'routing_number': string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'error_message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'institution_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'institution_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrodepositResponseBodyMicroDepositInner
     */
    'verified_at'?: string | null;
}
/**
 * 
 * @export
 * @interface MicrodepositVerifyRequest
 */
export interface MicrodepositVerifyRequest {
    /**
     * 
     * @type {number}
     * @memberof MicrodepositVerifyRequest
     */
    'deposit_amount_1'?: number;
    /**
     * 
     * @type {number}
     * @memberof MicrodepositVerifyRequest
     */
    'deposit_amount_2'?: number;
}
/**
 * 
 * @export
 * @interface MicrodepositVerifyRequestBody
 */
export interface MicrodepositVerifyRequestBody {
    /**
     * 
     * @type {MicrodepositVerifyRequest}
     * @memberof MicrodepositVerifyRequestBody
     */
    'micro_deposit'?: MicrodepositVerifyRequest;
}
/**
 * 
 * @export
 * @interface MicrodepositsResponseBody
 */
export interface MicrodepositsResponseBody {
    /**
     * 
     * @type {Array<MicrodepositResponse>}
     * @memberof MicrodepositsResponseBody
     */
    'micro_deposits'?: Array<MicrodepositResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof MicrodepositsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface MonthlyCashFlowProfileRequest
 */
export interface MonthlyCashFlowProfileRequest {
    /**
     * The monthly dollar amount allocated for goals.
     * @type {number}
     * @memberof MonthlyCashFlowProfileRequest
     */
    'goals_contribution'?: number;
    /**
     * Determines if the user uses estimated goals contribution.
     * @type {boolean}
     * @memberof MonthlyCashFlowProfileRequest
     */
    'uses_estimated_goals_contribution'?: boolean;
}
/**
 * 
 * @export
 * @interface MonthlyCashFlowProfileRequestBody
 */
export interface MonthlyCashFlowProfileRequestBody {
    /**
     * 
     * @type {MonthlyCashFlowProfileRequest}
     * @memberof MonthlyCashFlowProfileRequestBody
     */
    'institution'?: MonthlyCashFlowProfileRequest;
}
/**
 * 
 * @export
 * @interface MonthlyCashFlowResponse
 */
export interface MonthlyCashFlowResponse {
    /**
     * Unique identifier for the monthly cash flow profile. Defined by MX.
     * @type {string}
     * @memberof MonthlyCashFlowResponse
     */
    'guid'?: string;
    /**
     * Unique identifier for the user the monthly cash flow profile is attached to. Defined by MX.
     * @type {string}
     * @memberof MonthlyCashFlowResponse
     */
    'user_guid'?: string;
    /**
     * The amount of the budgeted income for the user.
     * @type {number}
     * @memberof MonthlyCashFlowResponse
     */
    'budgeted_income'?: number;
    /**
     * The amount of the budgeted expenses for the user.
     * @type {number}
     * @memberof MonthlyCashFlowResponse
     */
    'budgeted_expenses'?: number;
    /**
     * The monthly dollar amount allocated for goals.
     * @type {number}
     * @memberof MonthlyCashFlowResponse
     */
    'goals_contribution'?: number;
    /**
     * The estimated monthly dollar amount allocated for goals calculated from income and budgets.
     * @type {number}
     * @memberof MonthlyCashFlowResponse
     */
    'estimated_goals_contribution'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MonthlyCashFlowResponse
     */
    'uses_estimated_goals_contribution'?: boolean;
}
/**
 * 
 * @export
 * @interface MonthlyCashFlowResponseBody
 */
export interface MonthlyCashFlowResponseBody {
    /**
     * 
     * @type {MonthlyCashFlowResponse}
     * @memberof MonthlyCashFlowResponseBody
     */
    'monthly_cash_flow_profile'?: MonthlyCashFlowResponse;
}
/**
 * 
 * @export
 * @interface NotificationResponse
 */
export interface NotificationResponse {
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'guid'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'content'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'deep_link_guid'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'delivered_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'entity_guid'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'has_been_delivered'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'has_been_viewed'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'notification_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'subject'?: any;
    /**
     * 
     * @type {any}
     * @memberof NotificationResponse
     */
    'channel'?: any;
}
/**
 * 
 * @export
 * @interface NotificationResponseBody
 */
export interface NotificationResponseBody {
    /**
     * 
     * @type {NotificationResponse}
     * @memberof NotificationResponseBody
     */
    'notification'?: NotificationResponse;
}
/**
 * 
 * @export
 * @interface NotificationsResponseBody
 */
export interface NotificationsResponseBody {
    /**
     * 
     * @type {Array<NotificationResponse>}
     * @memberof NotificationsResponseBody
     */
    'notifications'?: Array<NotificationResponse>;
}
/**
 * 
 * @export
 * @interface OAuthWindowResponse
 */
export interface OAuthWindowResponse {
    /**
     * 
     * @type {string}
     * @memberof OAuthWindowResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OAuthWindowResponse
     */
    'oauth_window_uri'?: string | null;
}
/**
 * 
 * @export
 * @interface OAuthWindowResponseBody
 */
export interface OAuthWindowResponseBody {
    /**
     * 
     * @type {OAuthWindowResponse}
     * @memberof OAuthWindowResponseBody
     */
    'member'?: OAuthWindowResponse;
}
/**
 * 
 * @export
 * @interface OptionResponse
 */
export interface OptionResponse {
    /**
     * 
     * @type {string}
     * @memberof OptionResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OptionResponse
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OptionResponse
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PaginationResponse
 */
export interface PaginationResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginationResponse
     */
    'current_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResponse
     */
    'per_page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResponse
     */
    'total_entries'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResponse
     */
    'total_pages'?: number;
}
/**
 * 
 * @export
 * @interface PaymentAccount
 */
export interface PaymentAccount {
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'account_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'account_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'account_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'available_balance'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'balance'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'routing_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'transit_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccount
     */
    'updated_at'?: any;
}
/**
 * 
 * @export
 * @interface PaymentAccountBody
 */
export interface PaymentAccountBody {
    /**
     * 
     * @type {PaymentAccountBodyPaymentAccount}
     * @memberof PaymentAccountBody
     */
    'payment_account'?: PaymentAccountBodyPaymentAccount;
}
/**
 * 
 * @export
 * @interface PaymentAccountBodyPaymentAccount
 */
export interface PaymentAccountBodyPaymentAccount {
    /**
     * 
     * @type {string}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'user_guid'?: string;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'account_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'account_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'account_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'available_balance'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'balance'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'routing_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'transit_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PaymentAccountBodyPaymentAccount
     */
    'updated_at'?: any;
}
/**
 * 
 * @export
 * @interface PaymentProcessorAuthorizationCodeRequest
 */
export interface PaymentProcessorAuthorizationCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentProcessorAuthorizationCodeRequest
     */
    'account_guid': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentProcessorAuthorizationCodeRequest
     */
    'member_guid': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentProcessorAuthorizationCodeRequest
     */
    'user_guid': string;
}
/**
 * 
 * @export
 * @interface PaymentProcessorAuthorizationCodeRequestBody
 */
export interface PaymentProcessorAuthorizationCodeRequestBody {
    /**
     * 
     * @type {PaymentProcessorAuthorizationCodeRequest}
     * @memberof PaymentProcessorAuthorizationCodeRequestBody
     */
    'payment_processor_authorization_code'?: PaymentProcessorAuthorizationCodeRequest;
}
/**
 * 
 * @export
 * @interface PaymentProcessorAuthorizationCodeResponse
 */
export interface PaymentProcessorAuthorizationCodeResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentProcessorAuthorizationCodeResponse
     */
    'authorization_code'?: string | null;
}
/**
 * 
 * @export
 * @interface PaymentProcessorAuthorizationCodeResponseBody
 */
export interface PaymentProcessorAuthorizationCodeResponseBody {
    /**
     * 
     * @type {PaymentProcessorAuthorizationCodeResponse}
     * @memberof PaymentProcessorAuthorizationCodeResponseBody
     */
    'payment_processor_authorization_code'?: PaymentProcessorAuthorizationCodeResponse;
}
/**
 * 
 * @export
 * @interface ProcessorAccountNumber
 */
export interface ProcessorAccountNumber {
    /**
     * 
     * @type {number}
     * @memberof ProcessorAccountNumber
     */
    'account_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessorAccountNumber
     */
    'guid'?: string;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumber
     */
    'institution_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumber
     */
    'loan_guarantor'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumber
     */
    'loan_reference_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumber
     */
    'passed_validation'?: any;
    /**
     * 
     * @type {number}
     * @memberof ProcessorAccountNumber
     */
    'routing_number'?: number;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumber
     */
    'sequence_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumber
     */
    'transit_number'?: any;
}
/**
 * 
 * @export
 * @interface ProcessorAccountNumberBody
 */
export interface ProcessorAccountNumberBody {
    /**
     * 
     * @type {Array<ProcessorAccountNumberBodyAccountNumbersInner>}
     * @memberof ProcessorAccountNumberBody
     */
    'account_numbers'?: Array<ProcessorAccountNumberBodyAccountNumbersInner>;
}
/**
 * 
 * @export
 * @interface ProcessorAccountNumberBodyAccountNumbersInner
 */
export interface ProcessorAccountNumberBodyAccountNumbersInner {
    /**
     * 
     * @type {string}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'user_guid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'account_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'guid'?: string;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'institution_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'loan_guarantor'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'loan_reference_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'passed_validation'?: any;
    /**
     * 
     * @type {number}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'routing_number'?: number;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'sequence_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorAccountNumberBodyAccountNumbersInner
     */
    'transit_number'?: any;
}
/**
 * 
 * @export
 * @interface ProcessorOwner
 */
export interface ProcessorOwner {
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'guid'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'owner_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'city'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'state'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'postal_code'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'country'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwner
     */
    'phone'?: any;
}
/**
 * 
 * @export
 * @interface ProcessorOwnerBody
 */
export interface ProcessorOwnerBody {
    /**
     * 
     * @type {Array<ProcessorOwnerBodyAccountOwnersInner>}
     * @memberof ProcessorOwnerBody
     */
    'account_owners'?: Array<ProcessorOwnerBodyAccountOwnersInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof ProcessorOwnerBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface ProcessorOwnerBodyAccountOwnersInner
 */
export interface ProcessorOwnerBodyAccountOwnersInner {
    /**
     * 
     * @type {string}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'user_guid'?: string;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'guid'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'owner_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'address'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'city'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'state'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'postal_code'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'country'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'email'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProcessorOwnerBodyAccountOwnersInner
     */
    'phone'?: any;
}
/**
 * 
 * @export
 * @interface RepeatingTransactionResponse
 */
export interface RepeatingTransactionResponse {
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RepeatingTransactionResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'merchant_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'last_posted_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'predicted_occurs_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'recurrence_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'user_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'repeating_transaction_type'?: RepeatingTransactionResponseRepeatingTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RepeatingTransactionResponse
     */
    'transaction_type'?: RepeatingTransactionResponseTransactionTypeEnum;
}

export const RepeatingTransactionResponseRepeatingTransactionTypeEnum = {
    Bill: 'BILL',
    Subscription: 'SUBSCRIPTION',
    Income: 'INCOME',
    Unknown: 'UNKNOWN'
} as const;

export type RepeatingTransactionResponseRepeatingTransactionTypeEnum = typeof RepeatingTransactionResponseRepeatingTransactionTypeEnum[keyof typeof RepeatingTransactionResponseRepeatingTransactionTypeEnum];
export const RepeatingTransactionResponseTransactionTypeEnum = {
    Debit: 'DEBIT',
    Credit: 'CREDIT'
} as const;

export type RepeatingTransactionResponseTransactionTypeEnum = typeof RepeatingTransactionResponseTransactionTypeEnum[keyof typeof RepeatingTransactionResponseTransactionTypeEnum];

/**
 * 
 * @export
 * @interface RepeatingTransactionsResponseBody
 */
export interface RepeatingTransactionsResponseBody {
    /**
     * 
     * @type {Array<RepeatingTransactionResponse>}
     * @memberof RepeatingTransactionsResponseBody
     */
    'repeating_transactions'?: Array<RepeatingTransactionResponse>;
}
/**
 * 
 * @export
 * @interface RepositionRequest
 */
export interface RepositionRequest {
    /**
     * The unique identifier for the goal. Defined by MX.
     * @type {string}
     * @memberof RepositionRequest
     */
    'guid': string;
    /**
     * The priority of the goal in relation to multiple goals.
     * @type {number}
     * @memberof RepositionRequest
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface RepositionRequestBody
 */
export interface RepositionRequestBody {
    /**
     * 
     * @type {Array<RepositionRequest>}
     * @memberof RepositionRequestBody
     */
    'goals'?: Array<RepositionRequest>;
}
/**
 * 
 * @export
 * @interface RepositionResponseBody
 */
export interface RepositionResponseBody {
    /**
     * 
     * @type {Array<GoalsResponse>}
     * @memberof RepositionResponseBody
     */
    'goals'?: Array<GoalsResponse>;
}
/**
 * 
 * @export
 * @interface RewardElements
 */
export interface RewardElements {
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'balance_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewardElements
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'expires_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'unit_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardElements
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface RewardResponseBody
 */
export interface RewardResponseBody {
    /**
     * 
     * @type {RewardsResponseBodyRewardsInner}
     * @memberof RewardResponseBody
     */
    'reward'?: RewardsResponseBodyRewardsInner;
}
/**
 * 
 * @export
 * @interface RewardsResponseBody
 */
export interface RewardsResponseBody {
    /**
     * 
     * @type {Array<RewardsResponseBodyRewardsInner>}
     * @memberof RewardsResponseBody
     */
    'rewards'?: Array<RewardsResponseBodyRewardsInner>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof RewardsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface RewardsResponseBodyRewardsInner
 */
export interface RewardsResponseBodyRewardsInner {
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'member_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'user_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'balance_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'expires_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'unit_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardsResponseBodyRewardsInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ScheduledPaymentResponse
 */
export interface ScheduledPaymentResponse {
    /**
     * 
     * @type {number}
     * @memberof ScheduledPaymentResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduledPaymentResponse
     */
    'is_completed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduledPaymentResponse
     */
    'is_recurring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'merchant_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'occurs_on'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduledPaymentResponse
     */
    'recurrence_day'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'recurrence_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'transaction_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledPaymentResponse
     */
    'user_guid'?: string;
}
/**
 * 
 * @export
 * @interface ScheduledPaymentsResponseBody
 */
export interface ScheduledPaymentsResponseBody {
    /**
     * 
     * @type {Array<ScheduledPaymentResponse>}
     * @memberof ScheduledPaymentsResponseBody
     */
    'scheduled_payments'?: Array<ScheduledPaymentResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof ScheduledPaymentsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface SpendingPlanAccountResponse
 */
export interface SpendingPlanAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'account_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'client_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'spending_plan_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanAccountResponse
     */
    'user_guid'?: string;
}
/**
 * 
 * @export
 * @interface SpendingPlanAccountsResponse
 */
export interface SpendingPlanAccountsResponse {
    /**
     * 
     * @type {Array<SpendingPlanAccountResponse>}
     * @memberof SpendingPlanAccountsResponse
     */
    'spending_plan_accounts'?: Array<SpendingPlanAccountResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof SpendingPlanAccountsResponse
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface SpendingPlanIterationItemCreateRequestBody
 */
export interface SpendingPlanIterationItemCreateRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemCreateRequestBody
     */
    'category_guid'?: string;
    /**
     * 
     * @type {number}
     * @memberof SpendingPlanIterationItemCreateRequestBody
     */
    'item_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof SpendingPlanIterationItemCreateRequestBody
     */
    'planned_amount': number;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemCreateRequestBody
     */
    'scheduled_payment_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemCreateRequestBody
     */
    'top_level_category_guid'?: string;
}
/**
 * 
 * @export
 * @interface SpendingPlanIterationItemResponse
 */
export interface SpendingPlanIterationItemResponse {
    /**
     * 
     * @type {number}
     * @memberof SpendingPlanIterationItemResponse
     */
    'actual_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'category_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'item_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SpendingPlanIterationItemResponse
     */
    'planned_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'scheduled_payment_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'spending_plan_iteration_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'top_level_category_guid'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SpendingPlanIterationItemResponse
     */
    'transaction_guids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationItemResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface SpendingPlanIterationItemsResponseBody
 */
export interface SpendingPlanIterationItemsResponseBody {
    /**
     * 
     * @type {Array<SpendingPlanIterationItemResponse>}
     * @memberof SpendingPlanIterationItemsResponseBody
     */
    'iteration_items'?: Array<SpendingPlanIterationItemResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof SpendingPlanIterationItemsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface SpendingPlanIterationResponse
 */
export interface SpendingPlanIterationResponse {
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'end_on'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SpendingPlanIterationResponse
     */
    'iteration_number'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'spending_plan_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'start_on'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanIterationResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface SpendingPlanIterationsResponse
 */
export interface SpendingPlanIterationsResponse {
    /**
     * 
     * @type {Array<SpendingPlanIterationResponse>}
     * @memberof SpendingPlanIterationsResponse
     */
    'iterations'?: Array<SpendingPlanIterationResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof SpendingPlanIterationsResponse
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface SpendingPlanResponse
 */
export interface SpendingPlanResponse {
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SpendingPlanResponse
     */
    'current_iteration_number'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpendingPlanResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface SpendingPlansResponseBody
 */
export interface SpendingPlansResponseBody {
    /**
     * 
     * @type {Array<SpendingPlanResponse>}
     * @memberof SpendingPlansResponseBody
     */
    'spending_plans'?: Array<SpendingPlanResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof SpendingPlansResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface SplitTransactionRequest
 */
export interface SplitTransactionRequest {
    /**
     * Amount of money you want to re-categorize.
     * @type {number}
     * @memberof SplitTransactionRequest
     */
    'amount': number;
    /**
     * Description for the split transaction.
     * @type {string}
     * @memberof SplitTransactionRequest
     */
    'description'?: string;
    /**
     * Unique identifier of the category.
     * @type {string}
     * @memberof SplitTransactionRequest
     */
    'category_guid'?: string;
    /**
     * Memo for the split transaction
     * @type {string}
     * @memberof SplitTransactionRequest
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface SplitTransactionRequestBody
 */
export interface SplitTransactionRequestBody {
    /**
     * 
     * @type {SplitTransactionRequest}
     * @memberof SplitTransactionRequestBody
     */
    'transactions': SplitTransactionRequest;
}
/**
 * 
 * @export
 * @interface SplitTransactionsResponseBody
 */
export interface SplitTransactionsResponseBody {
    /**
     * 
     * @type {Array<TransactionResponse>}
     * @memberof SplitTransactionsResponseBody
     */
    'transactions'?: Array<TransactionResponse>;
}
/**
 * 
 * @export
 * @interface StatementResponse
 */
export interface StatementResponse {
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'content_hash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'uri'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatementResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface StatementResponseBody
 */
export interface StatementResponseBody {
    /**
     * 
     * @type {StatementResponse}
     * @memberof StatementResponseBody
     */
    'statement'?: StatementResponse;
}
/**
 * 
 * @export
 * @interface StatementsResponseBody
 */
export interface StatementsResponseBody {
    /**
     * 
     * @type {Array<StatementResponse>}
     * @memberof StatementsResponseBody
     */
    'statements'?: Array<StatementResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof StatementsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface TagCreateRequest
 */
export interface TagCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagCreateRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TagCreateRequestBody
 */
export interface TagCreateRequestBody {
    /**
     * 
     * @type {TagCreateRequest}
     * @memberof TagCreateRequestBody
     */
    'tag'?: TagCreateRequest;
}
/**
 * 
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
    /**
     * 
     * @type {string}
     * @memberof TagResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface TagResponseBody
 */
export interface TagResponseBody {
    /**
     * 
     * @type {TagResponse}
     * @memberof TagResponseBody
     */
    'tag'?: TagResponse;
}
/**
 * 
 * @export
 * @interface TagUpdateRequest
 */
export interface TagUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TagUpdateRequestBody
 */
export interface TagUpdateRequestBody {
    /**
     * 
     * @type {TagUpdateRequest}
     * @memberof TagUpdateRequestBody
     */
    'tag'?: TagUpdateRequest;
}
/**
 * 
 * @export
 * @interface TaggingCreateRequest
 */
export interface TaggingCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TaggingCreateRequest
     */
    'tag_guid': string;
    /**
     * 
     * @type {string}
     * @memberof TaggingCreateRequest
     */
    'transaction_guid': string;
}
/**
 * 
 * @export
 * @interface TaggingCreateRequestBody
 */
export interface TaggingCreateRequestBody {
    /**
     * 
     * @type {TaggingCreateRequest}
     * @memberof TaggingCreateRequestBody
     */
    'tagging'?: TaggingCreateRequest;
}
/**
 * 
 * @export
 * @interface TaggingResponse
 */
export interface TaggingResponse {
    /**
     * 
     * @type {string}
     * @memberof TaggingResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TaggingResponse
     */
    'member_is_managed_by_user'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TaggingResponse
     */
    'tag_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaggingResponse
     */
    'transaction_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaggingResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface TaggingResponseBody
 */
export interface TaggingResponseBody {
    /**
     * 
     * @type {TaggingResponse}
     * @memberof TaggingResponseBody
     */
    'tagging'?: TaggingResponse;
}
/**
 * 
 * @export
 * @interface TaggingUpdateRequest
 */
export interface TaggingUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TaggingUpdateRequest
     */
    'tag_guid': string;
}
/**
 * 
 * @export
 * @interface TaggingUpdateRequestBody
 */
export interface TaggingUpdateRequestBody {
    /**
     * 
     * @type {TaggingUpdateRequest}
     * @memberof TaggingUpdateRequestBody
     */
    'tagging'?: TaggingUpdateRequest;
}
/**
 * 
 * @export
 * @interface TaggingsResponseBody
 */
export interface TaggingsResponseBody {
    /**
     * 
     * @type {Array<TaggingResponse>}
     * @memberof TaggingsResponseBody
     */
    'taggings'?: Array<TaggingResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof TaggingsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface TagsResponseBody
 */
export interface TagsResponseBody {
    /**
     * 
     * @type {Array<TagResponse>}
     * @memberof TagsResponseBody
     */
    'tags'?: Array<TagResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof TagsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface TokenRequestBody
 */
export interface TokenRequestBody {
    /**
     * 
     * @type {MemberElements}
     * @memberof TokenRequestBody
     */
    'scope'?: MemberElements;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'payment_processor_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenResponse
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenResponseBody
 */
export interface TokenResponseBody {
    /**
     * 
     * @type {Array<TokenResponse>}
     * @memberof TokenResponseBody
     */
    'tokens'?: Array<TokenResponse>;
}
/**
 * 
 * @export
 * @interface TransactionCreateRequest
 */
export interface TransactionCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof TransactionCreateRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'description': string;
    /**
     * The type of transaction, which must be CREDIT or DEBIT. See Transaction Fields for more information.
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'type': string;
    /**
     * Unique identifier of the category.
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'category_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'currency_code'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateRequest
     */
    'has_been_viewed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateRequest
     */
    'is_hidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateRequest
     */
    'is_international'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateRequest
     */
    'metadata'?: string;
    /**
     * When set to true, this parameter will prevent a webhook from being triggered by the request.
     * @type {boolean}
     * @memberof TransactionCreateRequest
     */
    'skip_webhook'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionCreateRequestBody
 */
export interface TransactionCreateRequestBody {
    /**
     * 
     * @type {TransactionCreateRequest}
     * @memberof TransactionCreateRequestBody
     */
    'transaction'?: TransactionCreateRequest;
}
/**
 * 
 * @export
 * @interface TransactionCreateResponseBody
 */
export interface TransactionCreateResponseBody {
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCreateResponseBody
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'category_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'check_number_string'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'extended_transaction_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_bill_pay'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_direct_deposit'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_expense'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_income'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_international'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_manual'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_overdraft_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_payroll_advance'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_recurring'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'is_subscription'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCreateResponseBody
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'localized_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'localized_memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCreateResponseBody
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionCreateResponseBody
     */
    'member_is_managed_by_user'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCreateResponseBody
     */
    'merchant_category_code'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'merchant_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'merchant_location_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'metadata'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'original_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'posted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'top_level_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'transacted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'user_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCreateResponseBody
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionIncludesResponse
 */
export interface TransactionIncludesResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionIncludesResponse
     */
    'amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'category_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'check_number_string'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'extended_transaction_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_bill_pay'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_direct_deposit'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_expense'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_income'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_international'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_manual'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_overdraft_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_payroll_advance'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_recurring'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'is_subscription'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionIncludesResponse
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'localized_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'localized_memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionIncludesResponse
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIncludesResponse
     */
    'member_is_managed_by_user'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionIncludesResponse
     */
    'merchant_category_code'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'merchant_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'merchant_location_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'metadata'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'original_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'posted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'top_level_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'transacted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'user_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponse
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {TransactionIncludesResponseAllOfClassification}
     * @memberof TransactionIncludesResponse
     */
    'classification'?: TransactionIncludesResponseAllOfClassification | null;
    /**
     * 
     * @type {TransactionIncludesResponseAllOfGeolocation}
     * @memberof TransactionIncludesResponse
     */
    'geolocation'?: TransactionIncludesResponseAllOfGeolocation | null;
    /**
     * 
     * @type {TransactionIncludesResponseAllOfMerchant}
     * @memberof TransactionIncludesResponse
     */
    'merchant'?: TransactionIncludesResponseAllOfMerchant | null;
    /**
     * 
     * @type {TransactionIncludesResponseAllOfRepeatingTransaction}
     * @memberof TransactionIncludesResponse
     */
    'repeating_transaction'?: TransactionIncludesResponseAllOfRepeatingTransaction | null;
}
/**
 * 
 * @export
 * @interface TransactionIncludesResponseAllOfClassification
 */
export interface TransactionIncludesResponseAllOfClassification {
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfClassification
     */
    'parent_class'?: TransactionIncludesResponseAllOfClassificationParentClassEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfClassification
     */
    'guid'?: string;
}

export const TransactionIncludesResponseAllOfClassificationParentClassEnum = {
    Payroll: 'Payroll',
    Deposit: 'Deposit',
    Savings: 'Savings',
    Transfer: 'Transfer',
    Refunds: 'Refunds',
    Spend: 'Spend',
    Investment: 'Investment',
    Buy: 'Buy',
    Sell: 'Sell',
    Income: 'Income',
    Fees: 'Fees',
    Expenses: 'Expenses',
    CorporateActions: 'Corporate Actions',
    Other: 'Other'
} as const;

export type TransactionIncludesResponseAllOfClassificationParentClassEnum = typeof TransactionIncludesResponseAllOfClassificationParentClassEnum[keyof typeof TransactionIncludesResponseAllOfClassificationParentClassEnum];

/**
 * 
 * @export
 * @interface TransactionIncludesResponseAllOfGeolocation
 */
export interface TransactionIncludesResponseAllOfGeolocation {
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfGeolocation
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfGeolocation
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfGeolocation
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfGeolocation
     */
    'postal code'?: string;
}
/**
 * 
 * @export
 * @interface TransactionIncludesResponseAllOfMerchant
 */
export interface TransactionIncludesResponseAllOfMerchant {
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfMerchant
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfMerchant
     */
    'guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfMerchant
     */
    'logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfMerchant
     */
    'website_url'?: string;
}
/**
 * 
 * @export
 * @interface TransactionIncludesResponseAllOfRepeatingTransaction
 */
export interface TransactionIncludesResponseAllOfRepeatingTransaction {
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfRepeatingTransaction
     */
    'repeating_transaction_type'?: TransactionIncludesResponseAllOfRepeatingTransactionRepeatingTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfRepeatingTransaction
     */
    'recurrence_type'?: TransactionIncludesResponseAllOfRepeatingTransactionRecurrenceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionIncludesResponseAllOfRepeatingTransaction
     */
    'guid'?: string;
}

export const TransactionIncludesResponseAllOfRepeatingTransactionRepeatingTransactionTypeEnum = {
    Bill: 'BILL',
    Subscription: 'SUBSCRIPTION',
    Income: 'INCOME',
    Unknown: 'UNKNOWN'
} as const;

export type TransactionIncludesResponseAllOfRepeatingTransactionRepeatingTransactionTypeEnum = typeof TransactionIncludesResponseAllOfRepeatingTransactionRepeatingTransactionTypeEnum[keyof typeof TransactionIncludesResponseAllOfRepeatingTransactionRepeatingTransactionTypeEnum];
export const TransactionIncludesResponseAllOfRepeatingTransactionRecurrenceTypeEnum = {
    EveryOtherWeek: 'EVERY_OTHER_WEEK'
} as const;

export type TransactionIncludesResponseAllOfRepeatingTransactionRecurrenceTypeEnum = typeof TransactionIncludesResponseAllOfRepeatingTransactionRecurrenceTypeEnum[keyof typeof TransactionIncludesResponseAllOfRepeatingTransactionRecurrenceTypeEnum];

/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'account_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'account_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'category_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'check_number_string'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'currency_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'extended_transaction_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_bill_pay'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_direct_deposit'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_expense'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_income'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_international'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_manual'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_overdraft_fee'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_payroll_advance'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_recurring'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'is_subscription'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'localized_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'localized_memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'member_guid'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'member_is_managed_by_user'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'memo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionResponse
     */
    'merchant_category_code'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'merchant_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'merchant_location_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'metadata'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'original_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'posted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'top_level_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'transacted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'user_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionResponseBody
 */
export interface TransactionResponseBody {
    /**
     * 
     * @type {TransactionResponse}
     * @memberof TransactionResponseBody
     */
    'transaction'?: TransactionResponse;
}
/**
 * 
 * @export
 * @interface TransactionRuleCreateRequest
 */
export interface TransactionRuleCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleCreateRequest
     */
    'category_guid': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleCreateRequest
     */
    'match_description': string;
}
/**
 * 
 * @export
 * @interface TransactionRuleCreateRequestBody
 */
export interface TransactionRuleCreateRequestBody {
    /**
     * 
     * @type {TransactionRuleCreateRequest}
     * @memberof TransactionRuleCreateRequestBody
     */
    'transaction_rule'?: TransactionRuleCreateRequest;
}
/**
 * 
 * @export
 * @interface TransactionRuleResponse
 */
export interface TransactionRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'category_guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'match_description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleResponse
     */
    'user_guid'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionRuleResponseBody
 */
export interface TransactionRuleResponseBody {
    /**
     * 
     * @type {TransactionRuleResponse}
     * @memberof TransactionRuleResponseBody
     */
    'transaction_rule'?: TransactionRuleResponse;
}
/**
 * 
 * @export
 * @interface TransactionRuleUpdateRequest
 */
export interface TransactionRuleUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleUpdateRequest
     */
    'category_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRuleUpdateRequest
     */
    'match_description'?: string;
}
/**
 * 
 * @export
 * @interface TransactionRuleUpdateRequestBody
 */
export interface TransactionRuleUpdateRequestBody {
    /**
     * 
     * @type {TransactionRuleUpdateRequest}
     * @memberof TransactionRuleUpdateRequestBody
     */
    'transaction_rule'?: TransactionRuleUpdateRequest;
}
/**
 * 
 * @export
 * @interface TransactionRulesResponseBody
 */
export interface TransactionRulesResponseBody {
    /**
     * 
     * @type {Array<TransactionRuleResponse>}
     * @memberof TransactionRulesResponseBody
     */
    'transaction_rules'?: Array<TransactionRuleResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof TransactionRulesResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface TransactionUpdateRequest
 */
export interface TransactionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdateRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdateRequest
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdateRequest
     */
    'category_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TransactionUpdateRequestBody
 */
export interface TransactionUpdateRequestBody {
    /**
     * 
     * @type {TransactionUpdateRequest}
     * @memberof TransactionUpdateRequestBody
     */
    'transaction'?: TransactionUpdateRequest;
}
/**
 * 
 * @export
 * @interface TransactionsResponseBody
 */
export interface TransactionsResponseBody {
    /**
     * 
     * @type {Array<TransactionResponse>}
     * @memberof TransactionsResponseBody
     */
    'transactions'?: Array<TransactionResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof TransactionsResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface TransactionsResponseBodyIncludes
 */
export interface TransactionsResponseBodyIncludes {
    /**
     * 
     * @type {Array<TransactionIncludesResponse>}
     * @memberof TransactionsResponseBodyIncludes
     */
    'transactions'?: Array<TransactionIncludesResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof TransactionsResponseBodyIncludes
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface UpdateGoalRequest
 */
export interface UpdateGoalRequest {
    /**
     * Unique identifier of the account for the goal.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'account_guid'?: string;
    /**
     * Amount of the goal.
     * @type {number}
     * @memberof UpdateGoalRequest
     */
    'amount'?: number;
    /**
     * The goal type.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'goal_type_name'?: string;
    /**
     * The category of the goal.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'meta_type_name'?: string;
    /**
     * The name of the goal.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'name'?: string;
    /**
     * Date and time the goal was completed.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'completed_at'?: string;
    /**
     * Determines if the goal has been spent.
     * @type {boolean}
     * @memberof UpdateGoalRequest
     */
    'has_been_spent'?: boolean;
    /**
     * Determines if the goal is complete.
     * @type {boolean}
     * @memberof UpdateGoalRequest
     */
    'is_complete'?: boolean;
    /**
     * Additional information a partner can store on the goal.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'metadata'?: string;
    /**
     * The priority of the goal in relation to multiple goals.
     * @type {number}
     * @memberof UpdateGoalRequest
     */
    'position'?: number;
    /**
     * Date and time the goal is to complete. Intended for users to set their own goal completion dates.
     * @type {string}
     * @memberof UpdateGoalRequest
     */
    'targeted_to_complete_at'?: string;
}
/**
 * 
 * @export
 * @interface UpdateGoalRequestBody
 */
export interface UpdateGoalRequestBody {
    /**
     * 
     * @type {UpdateGoalRequest}
     * @memberof UpdateGoalRequestBody
     */
    'goal'?: UpdateGoalRequest;
}
/**
 * 
 * @export
 * @interface UserCreateRequest
 */
export interface UserCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreateRequest
     */
    'is_disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'metadata'?: string;
}
/**
 * 
 * @export
 * @interface UserCreateRequestBody
 */
export interface UserCreateRequestBody {
    /**
     * 
     * @type {UserCreateRequest}
     * @memberof UserCreateRequestBody
     */
    'user'?: UserCreateRequest;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'guid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_disabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'metadata'?: string | null;
}
/**
 * 
 * @export
 * @interface UserResponseBody
 */
export interface UserResponseBody {
    /**
     * 
     * @type {UserResponse}
     * @memberof UserResponseBody
     */
    'user'?: UserResponse;
}
/**
 * 
 * @export
 * @interface UserUpdateRequest
 */
export interface UserUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdateRequest
     */
    'is_disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'metadata'?: string;
}
/**
 * 
 * @export
 * @interface UserUpdateRequestBody
 */
export interface UserUpdateRequestBody {
    /**
     * 
     * @type {UserUpdateRequest}
     * @memberof UserUpdateRequestBody
     */
    'user'?: UserUpdateRequest;
}
/**
 * 
 * @export
 * @interface UsersResponseBody
 */
export interface UsersResponseBody {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof UsersResponseBody
     */
    'users'?: Array<UserResponse>;
    /**
     * 
     * @type {PaginationResponse}
     * @memberof UsersResponseBody
     */
    'pagination'?: PaginationResponse;
}
/**
 * 
 * @export
 * @interface VCResponse
 */
export interface VCResponse {
    /**
     * 
     * @type {string}
     * @memberof VCResponse
     */
    'verifiableCredential'?: string;
}
/**
 * 
 * @export
 * @interface WidgetRequest
 */
export interface WidgetRequest {
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This determines the redirect destination at the end of OAuth when used with `is_mobile_webview: true` or `oauth_referral_source: \'APP\'`. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'client_redirect_url'?: string;
    /**
     * This option can be passed to any `widget_type` but will not affect [legacy PFM widgets](products/experience/pfm/legacy-widget-overviews/). Load the widget with the specified `color_scheme`; options are `light`, `browser` (respects user\'s browser setting), and `dark`. Defaults to `light`.
     * @type {string}
     * @memberof WidgetRequest
     */
    'color_scheme'?: string;
    /**
     * To use this parameter, you must also set `use_cases` in the same request. If `connections_use_case_filter` is set to `true`, the Connections Widget will only show connections (members) with the `use_cases` you set in the same request. For some examples, see [Filter Connections](/products/experience/pfm/widget-overviews/connections-widget#example-1).
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'connections_use_case_filter'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. Load the widget into the credential view for the specified institution. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'current_institution_code'?: string;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. Load the widget into the credential view for the specified institution. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'current_institution_guid'?: string;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. Load the widget into a specific member that contains an error or requires multifactor authentication. The widget will determine the best view to load based on the member\'s current state. `current_member_guid` takes precedence over `current_institution_code` and `current_institution_guid`. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'current_member_guid'?: string;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This determines whether background aggregation is enabled or disabled for the member created by the Connect Widget. Defaults to `false` in `aggregation` mode and `true` in `verification` mode. A global default for all members can be set by reaching out to MX. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'disable_background_agg'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This determines whether the institution search is displayed within the Connect Widget. This option must be used with `current_institution_code`, `current_instituion_guid`, or `current_member_guid`. When set to `true`, the institution search feature will be disabled and end users will not be able to navigate to it. Defaults to `false`. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'disable_institution_search'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to `true`. When set to `false`, the widget will **not** direct the end user to the institution\'s mobile application. This setting is not persistent. This setting currently only affects Chase institutions. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'enable_app2app'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This determines whether an account owner identification (AOI, previously called identity verification) is run in addition to the process specified by the `mode`. Defaults to `false`. This can be set in either `aggregation` or `verification` mode. The AOI runs after the primary process is complete. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'include_identity'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This determines whether transaction data are retrieved. Defaults to `true` in aggregation mode and `false` in verification mode. This can be set in either `aggregation` or `verification` mode. This option does not affect future foreground or background aggregations. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'include_transactions'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `pulse_widget`. Set this to the insight guid you want to appear at the top of the insights feed. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'insight_guid'?: string | null;
    /**
     * An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include `US`, `CA`, and `MX` (Mexico). 
     * @type {Array<string>}
     * @memberof WidgetRequest
     */
    'iso_country_code'?: Array<string>;
    /**
     * This option is for all `widget_type`s. This configures the widget to render in a mobile WebView. JavaScript event postMessages are replaced with URL updates. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'is_mobile_webview'?: boolean;
    /**
     * Only use this option if the `widget_type` is set to `micro_pulse_carousel_widget`. Set this to a unique value for each instance of the Micro Widget. This lets us collect unique data for each instance of the widget. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'microwidget_instance_id'?: string | null;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. `mode` is the most important option for the Connect Widget. This determines what kind of process Connect will run, which affects how you should set many other options. Defaults to `aggregation`. `aggregation` mode retrieves account and transaction data; in other words, this runs a standard aggregation. `verification` mode retrieves account numbers and routing/transit numbers; in other words, it runs an Instant Account Verification (IAV). By default, verification mode does not retrieve transaction data; this default can be modified with secondary options. By default, background aggregation is disabled for all members created in verification mode; this default can be modified with secondary options. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'mode'?: string;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This determines how MX will respond to the result of an OAuth flow. When set to `APP`, MX will redirect to the URI specified in the `ui_message_webview_url_scheme`. When set to `BROWSER`, MX will send a postMessage but not redirect. If `is_mobile_webview` is `true`, this defaults to `APP`. If false, it defaults to `BROWSER`. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'oauth_referral_source'?: string;
    /**
     * This option is for all `widget_type`s. This determines which version of postMessage events are triggered. Defaults to 4. All new implementations must use version 4. Prior versions are deprecated. 
     * @type {number}
     * @memberof WidgetRequest
     */
    'ui_message_version'?: number;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. This is a client-defined scheme used in OAuth redirects in WebViews; also used in URL updates when these replace postMessages in WebViews. Defaults to `mx`. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'ui_message_webview_url_scheme'?: string;
    /**
     * Only use this option if the `widget_type` is set to `connect_widget`. Load the widget into a view that allows them to update the current member. Optionally used with `current_member_guid`. This option should be used sparingly. The best practice is to use `current_member_guid` and let the widget resolve the issue. 
     * @type {boolean}
     * @memberof WidgetRequest
     */
    'update_credentials'?: boolean;
    /**
     * The use case that will be associated with any members created through the widget. Valid values are `PFM` and/or `MONEY_MOVEMENT`. This is **required** if you\'ve met with MX, opted in to using this field, and are requesting a widget with a `widget_type` of `connect_widget` or `connections_widget`.
     * @type {Array<string>}
     * @memberof WidgetRequest
     */
    'use_cases'?: Array<WidgetRequestUseCasesEnum>;
    /**
     * This determines which widget URL you\'ll receive.  See [Widget Types](/api-reference/platform-api/reference/widget-types) for a list of potential values. Additional request parameters may only apply to some widget types. 
     * @type {string}
     * @memberof WidgetRequest
     */
    'widget_type': string;
}

export const WidgetRequestUseCasesEnum = {
    MoneyMovement: 'MONEY_MOVEMENT',
    Pfm: 'PFM'
} as const;

export type WidgetRequestUseCasesEnum = typeof WidgetRequestUseCasesEnum[keyof typeof WidgetRequestUseCasesEnum];

/**
 * 
 * @export
 * @interface WidgetRequestBody
 */
export interface WidgetRequestBody {
    /**
     * 
     * @type {WidgetRequest}
     * @memberof WidgetRequestBody
     */
    'widget_url'?: WidgetRequest;
}
/**
 * 
 * @export
 * @interface WidgetResponse
 */
export interface WidgetResponse {
    /**
     * 
     * @type {string}
     * @memberof WidgetResponse
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WidgetResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WidgetResponse
     */
    'user_id'?: string | null;
}
/**
 * 
 * @export
 * @interface WidgetResponseBody
 */
export interface WidgetResponseBody {
    /**
     * 
     * @type {WidgetResponse}
     * @memberof WidgetResponseBody
     */
    'widget_url'?: WidgetResponse;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can only be used to create manual accounts. Creating a manual account will automatically create it under the Manual Institution member. Since a manual account has no credentials tied to the member, the account will never aggregate or include data from a data feed..
         * @summary Create manual account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {AccountCreateRequestBody} accountCreateRequestBody Manual account object to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualAccount: async (userGuid: string, accountCreateRequestBody: AccountCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createManualAccount', 'userGuid', userGuid)
            // verify required parameter 'accountCreateRequestBody' is not null or undefined
            assertParamExists('createManualAccount', 'accountCreateRequestBody', accountCreateRequestBody)
            const localVarPath = `/users/{user_guid}/accounts`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes accounts that were manually created. The API will respond with an empty object and a status of `204 No Content`.
         * @summary Delete manual account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManualAccount: async (accountGuid: string, accept: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('deleteManualAccount', 'accountGuid', accountGuid)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('deleteManualAccount', 'accept', accept)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteManualAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of account numbers associated with the specified `account`.
         * @summary List account numbers by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountNumbersByAccount: async (accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('listAccountNumbersByAccount', 'accountGuid', accountGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listAccountNumbersByAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}/account_numbers`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of account numbers associated with the specified `member`.
         * @summary List account numbers by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountNumbersByMember: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listAccountNumbersByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listAccountNumbersByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/account_numbers`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns an array with information about every account associated with a particular member.
         * @summary List account owners by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountOwnersByMember: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listAccountOwnersByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listAccountOwnersByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/account_owners`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the accounts associated with the specified `member`.
         * @summary List accounts by member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberAccounts: async (userGuid: string, memberGuid: string, memberIsManagedByUser?: boolean, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listMemberAccounts', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listMemberAccounts', 'memberGuid', memberGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/accounts`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (memberIsManagedByUser !== undefined) {
                localVarQueryParameter['member_is_managed_by_user'] = memberIsManagedByUser;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the accounts associated with the specified `user`.  :::warning This request will not return the full account number. It may return the last four digits of the account number if that information has been provided during aggregation. If you need the full account number, please refer to [List account numbers by member](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-member/), [List account numbers by account](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-account/), or the [Fetch Account and Routing Numbers](https://docs.mx.com/products/connectivity/instant-account-verification/fetch-account-routing-number-api/#4-read-the-account-numbers) guide. ::: 
         * @summary List accounts
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
         * @param {boolean} [isManual] List only accounts that were manually created.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts: async (userGuid: string, page?: number, memberIsManagedByUser?: boolean, isManual?: boolean, recordsPerPage?: number, useCase?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listUserAccounts', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (memberIsManagedByUser !== undefined) {
                localVarQueryParameter['member_is_managed_by_user'] = memberIsManagedByUser;
            }

            if (isManual !== undefined) {
                localVarQueryParameter['is_manual'] = isManual;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (useCase !== undefined) {
                localVarQueryParameter['use_case'] = useCase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the specified `account` resource.
         * @summary Read account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAccount: async (accountGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('readAccount', 'accountGuid', accountGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to read the attributes of an `account` resource.
         * @summary Read account by member
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAccountByMember: async (accountGuid: string, memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('readAccountByMember', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readAccountByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readAccountByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to update certain attributes of an `account` resource, including manual accounts. For manual accounts, you can update every field listed. For aggregated accounts, you can only update `is_business`, `is_hidden` and `metadata`.
         * @summary Update account by member
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {AccountUpdateRequestBody} accountUpdateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountByMember: async (accountGuid: string, memberGuid: string, userGuid: string, accountUpdateRequestBody: AccountUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('updateAccountByMember', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('updateAccountByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateAccountByMember', 'userGuid', userGuid)
            // verify required parameter 'accountUpdateRequestBody' is not null or undefined
            assertParamExists('updateAccountByMember', 'accountUpdateRequestBody', accountUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint can only be used to create manual accounts. Creating a manual account will automatically create it under the Manual Institution member. Since a manual account has no credentials tied to the member, the account will never aggregate or include data from a data feed..
         * @summary Create manual account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {AccountCreateRequestBody} accountCreateRequestBody Manual account object to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManualAccount(userGuid: string, accountCreateRequestBody: AccountCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManualAccount(userGuid, accountCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes accounts that were manually created. The API will respond with an empty object and a status of `204 No Content`.
         * @summary Delete manual account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManualAccount(accountGuid: string, accept: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManualAccount(accountGuid, accept, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of account numbers associated with the specified `account`.
         * @summary List account numbers by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountNumbersByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountNumbersResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountNumbersByAccount(accountGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of account numbers associated with the specified `member`.
         * @summary List account numbers by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountNumbersByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountNumbersResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountNumbersByMember(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns an array with information about every account associated with a particular member.
         * @summary List account owners by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountOwnersByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOwnersResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountOwnersByMember(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the accounts associated with the specified `member`.
         * @summary List accounts by member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemberAccounts(userGuid: string, memberGuid: string, memberIsManagedByUser?: boolean, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemberAccounts(userGuid, memberGuid, memberIsManagedByUser, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the accounts associated with the specified `user`.  :::warning This request will not return the full account number. It may return the last four digits of the account number if that information has been provided during aggregation. If you need the full account number, please refer to [List account numbers by member](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-member/), [List account numbers by account](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-account/), or the [Fetch Account and Routing Numbers](https://docs.mx.com/products/connectivity/instant-account-verification/fetch-account-routing-number-api/#4-read-the-account-numbers) guide. ::: 
         * @summary List accounts
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
         * @param {boolean} [isManual] List only accounts that were manually created.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAccounts(userGuid: string, page?: number, memberIsManagedByUser?: boolean, isManual?: boolean, recordsPerPage?: number, useCase?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAccounts(userGuid, page, memberIsManagedByUser, isManual, recordsPerPage, useCase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the specified `account` resource.
         * @summary Read account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAccount(accountGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAccount(accountGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to read the attributes of an `account` resource.
         * @summary Read account by member
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAccountByMember(accountGuid: string, memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAccountByMember(accountGuid, memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to update certain attributes of an `account` resource, including manual accounts. For manual accounts, you can update every field listed. For aggregated accounts, you can only update `is_business`, `is_hidden` and `metadata`.
         * @summary Update account by member
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {AccountUpdateRequestBody} accountUpdateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountByMember(accountGuid: string, memberGuid: string, userGuid: string, accountUpdateRequestBody: AccountUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountByMember(accountGuid, memberGuid, userGuid, accountUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This endpoint can only be used to create manual accounts. Creating a manual account will automatically create it under the Manual Institution member. Since a manual account has no credentials tied to the member, the account will never aggregate or include data from a data feed..
         * @summary Create manual account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {AccountCreateRequestBody} accountCreateRequestBody Manual account object to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualAccount(userGuid: string, accountCreateRequestBody: AccountCreateRequestBody, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.createManualAccount(userGuid, accountCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes accounts that were manually created. The API will respond with an empty object and a status of `204 No Content`.
         * @summary Delete manual account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManualAccount(accountGuid: string, accept: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManualAccount(accountGuid, accept, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of account numbers associated with the specified `account`.
         * @summary List account numbers by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountNumbersByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<AccountNumbersResponseBody> {
            return localVarFp.listAccountNumbersByAccount(accountGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of account numbers associated with the specified `member`.
         * @summary List account numbers by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountNumbersByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<AccountNumbersResponseBody> {
            return localVarFp.listAccountNumbersByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns an array with information about every account associated with a particular member.
         * @summary List account owners by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountOwnersByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<AccountOwnersResponseBody> {
            return localVarFp.listAccountOwnersByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the accounts associated with the specified `member`.
         * @summary List accounts by member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberAccounts(userGuid: string, memberGuid: string, memberIsManagedByUser?: boolean, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<AccountsResponseBody> {
            return localVarFp.listMemberAccounts(userGuid, memberGuid, memberIsManagedByUser, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the accounts associated with the specified `user`.  :::warning This request will not return the full account number. It may return the last four digits of the account number if that information has been provided during aggregation. If you need the full account number, please refer to [List account numbers by member](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-member/), [List account numbers by account](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-account/), or the [Fetch Account and Routing Numbers](https://docs.mx.com/products/connectivity/instant-account-verification/fetch-account-routing-number-api/#4-read-the-account-numbers) guide. ::: 
         * @summary List accounts
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
         * @param {boolean} [isManual] List only accounts that were manually created.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(userGuid: string, page?: number, memberIsManagedByUser?: boolean, isManual?: boolean, recordsPerPage?: number, useCase?: string, options?: any): AxiosPromise<AccountsResponseBody> {
            return localVarFp.listUserAccounts(userGuid, page, memberIsManagedByUser, isManual, recordsPerPage, useCase, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the specified `account` resource.
         * @summary Read account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAccount(accountGuid: string, userGuid: string, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.readAccount(accountGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to read the attributes of an `account` resource.
         * @summary Read account by member
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAccountByMember(accountGuid: string, memberGuid: string, userGuid: string, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.readAccountByMember(accountGuid, memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to update certain attributes of an `account` resource, including manual accounts. For manual accounts, you can update every field listed. For aggregated accounts, you can only update `is_business`, `is_hidden` and `metadata`.
         * @summary Update account by member
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {AccountUpdateRequestBody} accountUpdateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountByMember(accountGuid: string, memberGuid: string, userGuid: string, accountUpdateRequestBody: AccountUpdateRequestBody, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.updateAccountByMember(accountGuid, memberGuid, userGuid, accountUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * This endpoint can only be used to create manual accounts. Creating a manual account will automatically create it under the Manual Institution member. Since a manual account has no credentials tied to the member, the account will never aggregate or include data from a data feed..
     * @summary Create manual account
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {AccountCreateRequestBody} accountCreateRequestBody Manual account object to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createManualAccount(userGuid: string, accountCreateRequestBody: AccountCreateRequestBody, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createManualAccount(userGuid, accountCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes accounts that were manually created. The API will respond with an empty object and a status of `204 No Content`.
     * @summary Delete manual account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} accept Specifies the media type expected in the response.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteManualAccount(accountGuid: string, accept: string, userGuid: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deleteManualAccount(accountGuid, accept, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of account numbers associated with the specified `account`.
     * @summary List account numbers by account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountNumbersByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountNumbersByAccount(accountGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of account numbers associated with the specified `member`.
     * @summary List account numbers by member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountNumbersByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountNumbersByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns an array with information about every account associated with a particular member.
     * @summary List account owners by member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccountOwnersByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccountOwnersByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the accounts associated with the specified `member`.
     * @summary List accounts by member
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listMemberAccounts(userGuid: string, memberGuid: string, memberIsManagedByUser?: boolean, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listMemberAccounts(userGuid, memberGuid, memberIsManagedByUser, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the accounts associated with the specified `user`.  :::warning This request will not return the full account number. It may return the last four digits of the account number if that information has been provided during aggregation. If you need the full account number, please refer to [List account numbers by member](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-member/), [List account numbers by account](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-account/), or the [Fetch Account and Routing Numbers](https://docs.mx.com/products/connectivity/instant-account-verification/fetch-account-routing-number-api/#4-read-the-account-numbers) guide. ::: 
     * @summary List accounts
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {boolean} [memberIsManagedByUser] List only accounts whose member is managed by the user.
     * @param {boolean} [isManual] List only accounts that were manually created.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listUserAccounts(userGuid: string, page?: number, memberIsManagedByUser?: boolean, isManual?: boolean, recordsPerPage?: number, useCase?: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listUserAccounts(userGuid, page, memberIsManagedByUser, isManual, recordsPerPage, useCase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the specified `account` resource.
     * @summary Read account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public readAccount(accountGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).readAccount(accountGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to read the attributes of an `account` resource.
     * @summary Read account by member
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public readAccountByMember(accountGuid: string, memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).readAccountByMember(accountGuid, memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to update certain attributes of an `account` resource, including manual accounts. For manual accounts, you can update every field listed. For aggregated accounts, you can only update `is_business`, `is_hidden` and `metadata`.
     * @summary Update account by member
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {AccountUpdateRequestBody} accountUpdateRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccountByMember(accountGuid: string, memberGuid: string, userGuid: string, accountUpdateRequestBody: AccountUpdateRequestBody, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccountByMember(accountGuid, memberGuid, userGuid, accountUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AchReturnApi - axios parameter creator
 * @export
 */
export const AchReturnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to create an ACH return in our system. 
         * @summary Create ACH Return
         * @param {ACHReturnCreateRequestBody} aCHReturnCreateRequestBody ACH return object to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACHReturn: async (aCHReturnCreateRequestBody: ACHReturnCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aCHReturnCreateRequestBody' is not null or undefined
            assertParamExists('createACHReturn', 'aCHReturnCreateRequestBody', aCHReturnCreateRequestBody)
            const localVarPath = `/ach_returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aCHReturnCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get all ACH returns. 
         * @summary List ACH Returns
         * @param {string} [institutionGuid] The identifier for the institution associated with the ACH return. Defined by MX.
         * @param {string} [returnedAt] The date and time when the return was reported by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp.
         * @param {string} [resolvedStatusAt] The date and time when the return was resolved by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp
         * @param {string} [returnCode] The associated ACH return code and notice of change code. See [Return Codes](/api-reference/platform-api/reference/ach-return-fields#return-codes) for a complete list.
         * @param {string} [returnStatus] The status of the return. See [Return Statuses](/api-reference/platform-api/reference/ach-return-fields#return-status) for a complete list.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listACHRetruns: async (institutionGuid?: string, returnedAt?: string, resolvedStatusAt?: string, returnCode?: string, returnStatus?: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ach_returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (institutionGuid !== undefined) {
                localVarQueryParameter['institution_guid'] = institutionGuid;
            }

            if (returnedAt !== undefined) {
                localVarQueryParameter['returned_at'] = returnedAt;
            }

            if (resolvedStatusAt !== undefined) {
                localVarQueryParameter['resolved_status_at'] = resolvedStatusAt;
            }

            if (returnCode !== undefined) {
                localVarQueryParameter['return_code'] = returnCode;
            }

            if (returnStatus !== undefined) {
                localVarQueryParameter['return_status'] = returnStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get an ACH return by its `guid` or `id`. 
         * @summary Read ACH Return
         * @param {string} achReturnGuid The unique identifier (&#x60;guid&#x60;) for the ACH return. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readACHRetrun: async (achReturnGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'achReturnGuid' is not null or undefined
            assertParamExists('readACHRetrun', 'achReturnGuid', achReturnGuid)
            const localVarPath = `/ach_returns/{ach_return_guid}`
                .replace(`{${"ach_return_guid"}}`, encodeURIComponent(String(achReturnGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AchReturnApi - functional programming interface
 * @export
 */
export const AchReturnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AchReturnApiAxiosParamCreator(configuration)
    return {
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to create an ACH return in our system. 
         * @summary Create ACH Return
         * @param {ACHReturnCreateRequestBody} aCHReturnCreateRequestBody ACH return object to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createACHReturn(aCHReturnCreateRequestBody: ACHReturnCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACHReturnResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createACHReturn(aCHReturnCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get all ACH returns. 
         * @summary List ACH Returns
         * @param {string} [institutionGuid] The identifier for the institution associated with the ACH return. Defined by MX.
         * @param {string} [returnedAt] The date and time when the return was reported by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp.
         * @param {string} [resolvedStatusAt] The date and time when the return was resolved by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp
         * @param {string} [returnCode] The associated ACH return code and notice of change code. See [Return Codes](/api-reference/platform-api/reference/ach-return-fields#return-codes) for a complete list.
         * @param {string} [returnStatus] The status of the return. See [Return Statuses](/api-reference/platform-api/reference/ach-return-fields#return-status) for a complete list.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listACHRetruns(institutionGuid?: string, returnedAt?: string, resolvedStatusAt?: string, returnCode?: string, returnStatus?: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACHReturnsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listACHRetruns(institutionGuid, returnedAt, resolvedStatusAt, returnCode, returnStatus, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get an ACH return by its `guid` or `id`. 
         * @summary Read ACH Return
         * @param {string} achReturnGuid The unique identifier (&#x60;guid&#x60;) for the ACH return. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readACHRetrun(achReturnGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACHReturnResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readACHRetrun(achReturnGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AchReturnApi - factory interface
 * @export
 */
export const AchReturnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AchReturnApiFp(configuration)
    return {
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to create an ACH return in our system. 
         * @summary Create ACH Return
         * @param {ACHReturnCreateRequestBody} aCHReturnCreateRequestBody ACH return object to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createACHReturn(aCHReturnCreateRequestBody: ACHReturnCreateRequestBody, options?: any): AxiosPromise<ACHReturnResponseBody> {
            return localVarFp.createACHReturn(aCHReturnCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get all ACH returns. 
         * @summary List ACH Returns
         * @param {string} [institutionGuid] The identifier for the institution associated with the ACH return. Defined by MX.
         * @param {string} [returnedAt] The date and time when the return was reported by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp.
         * @param {string} [resolvedStatusAt] The date and time when the return was resolved by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp
         * @param {string} [returnCode] The associated ACH return code and notice of change code. See [Return Codes](/api-reference/platform-api/reference/ach-return-fields#return-codes) for a complete list.
         * @param {string} [returnStatus] The status of the return. See [Return Statuses](/api-reference/platform-api/reference/ach-return-fields#return-status) for a complete list.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listACHRetruns(institutionGuid?: string, returnedAt?: string, resolvedStatusAt?: string, returnCode?: string, returnStatus?: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<ACHReturnsResponseBody> {
            return localVarFp.listACHRetruns(institutionGuid, returnedAt, resolvedStatusAt, returnCode, returnStatus, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get an ACH return by its `guid` or `id`. 
         * @summary Read ACH Return
         * @param {string} achReturnGuid The unique identifier (&#x60;guid&#x60;) for the ACH return. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readACHRetrun(achReturnGuid: string, options?: any): AxiosPromise<ACHReturnResponseBody> {
            return localVarFp.readACHRetrun(achReturnGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AchReturnApi - object-oriented interface
 * @export
 * @class AchReturnApi
 * @extends {BaseAPI}
 */
export class AchReturnApi extends BaseAPI {
    /**
     * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to create an ACH return in our system. 
     * @summary Create ACH Return
     * @param {ACHReturnCreateRequestBody} aCHReturnCreateRequestBody ACH return object to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchReturnApi
     */
    public createACHReturn(aCHReturnCreateRequestBody: ACHReturnCreateRequestBody, options?: AxiosRequestConfig) {
        return AchReturnApiFp(this.configuration).createACHReturn(aCHReturnCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get all ACH returns. 
     * @summary List ACH Returns
     * @param {string} [institutionGuid] The identifier for the institution associated with the ACH return. Defined by MX.
     * @param {string} [returnedAt] The date and time when the return was reported by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp.
     * @param {string} [resolvedStatusAt] The date and time when the return was resolved by the Receiving Financial Depository Institution (RDFI) in ISO 8601 format without timestamp
     * @param {string} [returnCode] The associated ACH return code and notice of change code. See [Return Codes](/api-reference/platform-api/reference/ach-return-fields#return-codes) for a complete list.
     * @param {string} [returnStatus] The status of the return. See [Return Statuses](/api-reference/platform-api/reference/ach-return-fields#return-status) for a complete list.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchReturnApi
     */
    public listACHRetruns(institutionGuid?: string, returnedAt?: string, resolvedStatusAt?: string, returnCode?: string, returnStatus?: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return AchReturnApiFp(this.configuration).listACHRetruns(institutionGuid, returnedAt, resolvedStatusAt, returnCode, returnStatus, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :::warning The features documented here are in a beta state, and this documentation is considered draft material subject to frequent change. :::  Use this endpoint to get an ACH return by its `guid` or `id`. 
     * @summary Read ACH Return
     * @param {string} achReturnGuid The unique identifier (&#x60;guid&#x60;) for the ACH return. Defined by MX.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchReturnApi
     */
    public readACHRetrun(achReturnGuid: string, options?: AxiosRequestConfig) {
        return AchReturnApiFp(this.configuration).readACHRetrun(achReturnGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BudgetsApi - axios parameter creator
 * @export
 */
export const BudgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will automatically create budgets for several categories based on existing transactions; these budgets are returned as an array. Specifically, budgets will only be generated if the `user` has at least one `transaction` in a given category during each of the two previous calendar months. For example, if the request is made on March 6, and there is at least one \"Bills & Utilities\" `transaction` in both January and February, a budget will be generated for \"Bills & Utilities.\" If there are two \"Bills & Utilities\" transactions in February but none in January, no budget will be generated for that category. If budgets already exist for particular categories, new budgets will be generated and returned based on the available transactions. If one or more budgets remain unchanged, they will nevertheless be returned in the response. If no transaction data for the `user` meet the above criteria, a `422 Unprocessable Entity` error will be returned with status code 4221 along with the message, `There aren\'t enough transactions to automatically create any budgets`.
         * @summary Auto-generate budgets
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGenerateBudgets: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('autoGenerateBudgets', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/budgets/generate`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a budget. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter. You cannot create a duplicate budget. For example, if you attempt to create a budget for \"Gas\", but that budget already exist, the request will fail. You can retrieve a list of all existing categories by using the List Categories endpoint.
         * @summary Create a budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {BudgetCreateRequestBody} budgetCreateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBudget: async (userGuid: string, budgetCreateRequestBody: BudgetCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createBudget', 'userGuid', userGuid)
            // verify required parameter 'budgetCreateRequestBody' is not null or undefined
            assertParamExists('createBudget', 'budgetCreateRequestBody', budgetCreateRequestBody)
            const localVarPath = `/users/{user_guid}/budgets`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.mx.api.v1+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a budget.
         * @summary Delete a budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: async (userGuid: string, budgetGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteBudget', 'userGuid', userGuid)
            // verify required parameter 'budgetGuid' is not null or undefined
            assertParamExists('deleteBudget', 'budgetGuid', budgetGuid)
            const localVarPath = `/users/{user_guid}/budgets/{budget_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"budget_guid"}}`, encodeURIComponent(String(budgetGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all budgets
         * @summary List all budgets
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllBudgets: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listAllBudgets', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/budgets`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a specific budget.
         * @summary Read a specific budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpecificBudget: async (userGuid: string, budgetGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readSpecificBudget', 'userGuid', userGuid)
            // verify required parameter 'budgetGuid' is not null or undefined
            assertParamExists('readSpecificBudget', 'budgetGuid', budgetGuid)
            const localVarPath = `/users/{user_guid}/budgets/{budget_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"budget_guid"}}`, encodeURIComponent(String(budgetGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific budget.
         * @summary Update a specific budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {BudgetUpdateRequestBody} [budgetUpdateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpecificBudget: async (userGuid: string, budgetGuid: string, budgetUpdateRequestBody?: BudgetUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateSpecificBudget', 'userGuid', userGuid)
            // verify required parameter 'budgetGuid' is not null or undefined
            assertParamExists('updateSpecificBudget', 'budgetGuid', budgetGuid)
            const localVarPath = `/users/{user_guid}/budgets/{budget_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"budget_guid"}}`, encodeURIComponent(String(budgetGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.mx.api.v1+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(budgetUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will automatically create budgets for several categories based on existing transactions; these budgets are returned as an array. Specifically, budgets will only be generated if the `user` has at least one `transaction` in a given category during each of the two previous calendar months. For example, if the request is made on March 6, and there is at least one \"Bills & Utilities\" `transaction` in both January and February, a budget will be generated for \"Bills & Utilities.\" If there are two \"Bills & Utilities\" transactions in February but none in January, no budget will be generated for that category. If budgets already exist for particular categories, new budgets will be generated and returned based on the available transactions. If one or more budgets remain unchanged, they will nevertheless be returned in the response. If no transaction data for the `user` meet the above criteria, a `422 Unprocessable Entity` error will be returned with status code 4221 along with the message, `There aren\'t enough transactions to automatically create any budgets`.
         * @summary Auto-generate budgets
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGenerateBudgets(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGenerateBudgets(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a budget. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter. You cannot create a duplicate budget. For example, if you attempt to create a budget for \"Gas\", but that budget already exist, the request will fail. You can retrieve a list of all existing categories by using the List Categories endpoint.
         * @summary Create a budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {BudgetCreateRequestBody} budgetCreateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBudget(userGuid: string, budgetCreateRequestBody: BudgetCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBudget(userGuid, budgetCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a budget.
         * @summary Delete a budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudget(userGuid: string, budgetGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudget(userGuid, budgetGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all budgets
         * @summary List all budgets
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllBudgets(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllBudgets(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read a specific budget.
         * @summary Read a specific budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSpecificBudget(userGuid: string, budgetGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSpecificBudget(userGuid, budgetGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific budget.
         * @summary Update a specific budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {BudgetUpdateRequestBody} [budgetUpdateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpecificBudget(userGuid: string, budgetGuid: string, budgetUpdateRequestBody?: BudgetUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BudgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSpecificBudget(userGuid, budgetGuid, budgetUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetsApiFp(configuration)
    return {
        /**
         * This endpoint will automatically create budgets for several categories based on existing transactions; these budgets are returned as an array. Specifically, budgets will only be generated if the `user` has at least one `transaction` in a given category during each of the two previous calendar months. For example, if the request is made on March 6, and there is at least one \"Bills & Utilities\" `transaction` in both January and February, a budget will be generated for \"Bills & Utilities.\" If there are two \"Bills & Utilities\" transactions in February but none in January, no budget will be generated for that category. If budgets already exist for particular categories, new budgets will be generated and returned based on the available transactions. If one or more budgets remain unchanged, they will nevertheless be returned in the response. If no transaction data for the `user` meet the above criteria, a `422 Unprocessable Entity` error will be returned with status code 4221 along with the message, `There aren\'t enough transactions to automatically create any budgets`.
         * @summary Auto-generate budgets
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGenerateBudgets(userGuid: string, options?: any): AxiosPromise<BudgetResponseBody> {
            return localVarFp.autoGenerateBudgets(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a budget. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter. You cannot create a duplicate budget. For example, if you attempt to create a budget for \"Gas\", but that budget already exist, the request will fail. You can retrieve a list of all existing categories by using the List Categories endpoint.
         * @summary Create a budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {BudgetCreateRequestBody} budgetCreateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBudget(userGuid: string, budgetCreateRequestBody: BudgetCreateRequestBody, options?: any): AxiosPromise<BudgetResponseBody> {
            return localVarFp.createBudget(userGuid, budgetCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a budget.
         * @summary Delete a budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(userGuid: string, budgetGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBudget(userGuid, budgetGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List all budgets
         * @summary List all budgets
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllBudgets(userGuid: string, options?: any): AxiosPromise<BudgetResponseBody> {
            return localVarFp.listAllBudgets(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a specific budget.
         * @summary Read a specific budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpecificBudget(userGuid: string, budgetGuid: string, options?: any): AxiosPromise<BudgetResponseBody> {
            return localVarFp.readSpecificBudget(userGuid, budgetGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific budget.
         * @summary Update a specific budget
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
         * @param {BudgetUpdateRequestBody} [budgetUpdateRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpecificBudget(userGuid: string, budgetGuid: string, budgetUpdateRequestBody?: BudgetUpdateRequestBody, options?: any): AxiosPromise<BudgetResponseBody> {
            return localVarFp.updateSpecificBudget(userGuid, budgetGuid, budgetUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * This endpoint will automatically create budgets for several categories based on existing transactions; these budgets are returned as an array. Specifically, budgets will only be generated if the `user` has at least one `transaction` in a given category during each of the two previous calendar months. For example, if the request is made on March 6, and there is at least one \"Bills & Utilities\" `transaction` in both January and February, a budget will be generated for \"Bills & Utilities.\" If there are two \"Bills & Utilities\" transactions in February but none in January, no budget will be generated for that category. If budgets already exist for particular categories, new budgets will be generated and returned based on the available transactions. If one or more budgets remain unchanged, they will nevertheless be returned in the response. If no transaction data for the `user` meet the above criteria, a `422 Unprocessable Entity` error will be returned with status code 4221 along with the message, `There aren\'t enough transactions to automatically create any budgets`.
     * @summary Auto-generate budgets
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public autoGenerateBudgets(userGuid: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).autoGenerateBudgets(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a budget. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter. You cannot create a duplicate budget. For example, if you attempt to create a budget for \"Gas\", but that budget already exist, the request will fail. You can retrieve a list of all existing categories by using the List Categories endpoint.
     * @summary Create a budget
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {BudgetCreateRequestBody} budgetCreateRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public createBudget(userGuid: string, budgetCreateRequestBody: BudgetCreateRequestBody, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).createBudget(userGuid, budgetCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a budget.
     * @summary Delete a budget
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public deleteBudget(userGuid: string, budgetGuid: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).deleteBudget(userGuid, budgetGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all budgets
     * @summary List all budgets
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public listAllBudgets(userGuid: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).listAllBudgets(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a specific budget.
     * @summary Read a specific budget
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public readSpecificBudget(userGuid: string, budgetGuid: string, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).readSpecificBudget(userGuid, budgetGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific budget.
     * @summary Update a specific budget
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} budgetGuid The unique identifier for the budget. Defined by MX.
     * @param {BudgetUpdateRequestBody} [budgetUpdateRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public updateSpecificBudget(userGuid: string, budgetGuid: string, budgetUpdateRequestBody?: BudgetUpdateRequestBody, options?: AxiosRequestConfig) {
        return BudgetsApiFp(this.configuration).updateSpecificBudget(userGuid, budgetGuid, budgetUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a new custom category for a specific `user`.
         * @summary Create category
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {CategoryCreateRequestBody} categoryCreateRequestBody Custom category object to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (userGuid: string, categoryCreateRequestBody: CategoryCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createCategory', 'userGuid', userGuid)
            // verify required parameter 'categoryCreateRequestBody' is not null or undefined
            assertParamExists('createCategory', 'categoryCreateRequestBody', categoryCreateRequestBody)
            const localVarPath = `/users/{user_guid}/categories`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a specific custom category according to its unique GUID. The API will respond with an empty object and a status of `204 No Content`.
         * @summary Delete category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryGuid' is not null or undefined
            assertParamExists('deleteCategory', 'categoryGuid', categoryGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteCategory', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/categories/{category_guid}`
                .replace(`{${"category_guid"}}`, encodeURIComponent(String(categoryGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all categories associated with a `user`, including both default and custom categories.
         * @summary List categories
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listCategories', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/categories`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a list of all the default categories and subcategories offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
         * @summary List default categories
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefaultCategories: async (page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a list of all the default categories and subcategories, scoped by user, offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
         * @summary List default categories by user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefaultCategoriesByUser: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listDefaultCategoriesByUser', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/categories/default`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of either a default category or a custom category.
         * @summary Read a custom category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCategory: async (categoryGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryGuid' is not null or undefined
            assertParamExists('readCategory', 'categoryGuid', categoryGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readCategory', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/categories/{category_guid}`
                .replace(`{${"category_guid"}}`, encodeURIComponent(String(categoryGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a default category.
         * @summary Read a default category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDefaultCategory: async (categoryGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryGuid' is not null or undefined
            assertParamExists('readDefaultCategory', 'categoryGuid', categoryGuid)
            const localVarPath = `/categories/{category_guid}`
                .replace(`{${"category_guid"}}`, encodeURIComponent(String(categoryGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of a custom category according to its unique GUID.
         * @summary Update category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {CategoryUpdateRequestBody} categoryUpdateRequestBody Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (categoryGuid: string, userGuid: string, categoryUpdateRequestBody: CategoryUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryGuid' is not null or undefined
            assertParamExists('updateCategory', 'categoryGuid', categoryGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateCategory', 'userGuid', userGuid)
            // verify required parameter 'categoryUpdateRequestBody' is not null or undefined
            assertParamExists('updateCategory', 'categoryUpdateRequestBody', categoryUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/categories/{category_guid}`
                .replace(`{${"category_guid"}}`, encodeURIComponent(String(categoryGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a new custom category for a specific `user`.
         * @summary Create category
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {CategoryCreateRequestBody} categoryCreateRequestBody Custom category object to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(userGuid: string, categoryCreateRequestBody: CategoryCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(userGuid, categoryCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a specific custom category according to its unique GUID. The API will respond with an empty object and a status of `204 No Content`.
         * @summary Delete category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all categories associated with a `user`, including both default and custom categories.
         * @summary List categories
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategories(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategories(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to retrieve a list of all the default categories and subcategories offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
         * @summary List default categories
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDefaultCategories(page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDefaultCategories(page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to retrieve a list of all the default categories and subcategories, scoped by user, offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
         * @summary List default categories by user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDefaultCategoriesByUser(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDefaultCategoriesByUser(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of either a default category or a custom category.
         * @summary Read a custom category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCategory(categoryGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCategory(categoryGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a default category.
         * @summary Read a default category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDefaultCategory(categoryGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDefaultCategory(categoryGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of a custom category according to its unique GUID.
         * @summary Update category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {CategoryUpdateRequestBody} categoryUpdateRequestBody Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(categoryGuid: string, userGuid: string, categoryUpdateRequestBody: CategoryUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(categoryGuid, userGuid, categoryUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a new custom category for a specific `user`.
         * @summary Create category
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {CategoryCreateRequestBody} categoryCreateRequestBody Custom category object to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(userGuid: string, categoryCreateRequestBody: CategoryCreateRequestBody, options?: any): AxiosPromise<CategoryResponseBody> {
            return localVarFp.createCategory(userGuid, categoryCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a specific custom category according to its unique GUID. The API will respond with an empty object and a status of `204 No Content`.
         * @summary Delete category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(categoryGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all categories associated with a `user`, including both default and custom categories.
         * @summary List categories
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<CategoriesResponseBody> {
            return localVarFp.listCategories(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a list of all the default categories and subcategories offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
         * @summary List default categories
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefaultCategories(page?: number, recordsPerPage?: number, options?: any): AxiosPromise<CategoriesResponseBody> {
            return localVarFp.listDefaultCategories(page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a list of all the default categories and subcategories, scoped by user, offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
         * @summary List default categories by user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefaultCategoriesByUser(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<CategoriesResponseBody> {
            return localVarFp.listDefaultCategoriesByUser(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of either a default category or a custom category.
         * @summary Read a custom category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCategory(categoryGuid: string, userGuid: string, options?: any): AxiosPromise<CategoryResponseBody> {
            return localVarFp.readCategory(categoryGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a default category.
         * @summary Read a default category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDefaultCategory(categoryGuid: string, options?: any): AxiosPromise<CategoryResponseBody> {
            return localVarFp.readDefaultCategory(categoryGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of a custom category according to its unique GUID.
         * @summary Update category
         * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {CategoryUpdateRequestBody} categoryUpdateRequestBody Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryGuid: string, userGuid: string, categoryUpdateRequestBody: CategoryUpdateRequestBody, options?: any): AxiosPromise<CategoryResponseBody> {
            return localVarFp.updateCategory(categoryGuid, userGuid, categoryUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Use this endpoint to create a new custom category for a specific `user`.
     * @summary Create category
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {CategoryCreateRequestBody} categoryCreateRequestBody Custom category object to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public createCategory(userGuid: string, categoryCreateRequestBody: CategoryCreateRequestBody, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).createCategory(userGuid, categoryCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a specific custom category according to its unique GUID. The API will respond with an empty object and a status of `204 No Content`.
     * @summary Delete category
     * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(categoryGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).deleteCategory(categoryGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all categories associated with a `user`, including both default and custom categories.
     * @summary List categories
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategories(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listCategories(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a list of all the default categories and subcategories offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
     * @summary List default categories
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listDefaultCategories(page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listDefaultCategories(page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a list of all the default categories and subcategories, scoped by user, offered within the MX Platform API. In other words, each item in the returned list will have its `is_default` field set to `true`. There are currently 119 default categories and subcategories. Both the _list default categories_ and _list default categories by user_ endpoints return the same results. The different routes are provided for convenience.
     * @summary List default categories by user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listDefaultCategoriesByUser(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listDefaultCategoriesByUser(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of either a default category or a custom category.
     * @summary Read a custom category
     * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public readCategory(categoryGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).readCategory(categoryGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a default category.
     * @summary Read a default category
     * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public readDefaultCategory(categoryGuid: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).readDefaultCategory(categoryGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of a custom category according to its unique GUID.
     * @summary Update category
     * @param {string} categoryGuid The unique id for a &#x60;category&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {CategoryUpdateRequestBody} categoryUpdateRequestBody Category object to be updated (While no single parameter is required, the &#x60;category&#x60; object cannot be empty)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(categoryGuid: string, userGuid: string, categoryUpdateRequestBody: CategoryUpdateRequestBody, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).updateCategory(categoryGuid, userGuid, categoryUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoalsApi - axios parameter creator
 * @export
 */
export const GoalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a goal. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter.
         * @summary Create a goal
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {GoalRequestBody} goalRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoal: async (userGuid: string, goalRequestBody: GoalRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createGoal', 'userGuid', userGuid)
            // verify required parameter 'goalRequestBody' is not null or undefined
            assertParamExists('createGoal', 'goalRequestBody', goalRequestBody)
            const localVarPath = `/users/{user_guid}/goals`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.mx.api.v1+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a goal.
         * @summary Delete a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal: async (goalGuid: string, userGuid: string, accept: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalGuid' is not null or undefined
            assertParamExists('deleteGoal', 'goalGuid', goalGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteGoal', 'userGuid', userGuid)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('deleteGoal', 'accept', accept)
            const localVarPath = `/users/{user_guid}/goals/{goal_guid}`
                .replace(`{${"goal_guid"}}`, encodeURIComponent(String(goalGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all goals a user can set.
         * @summary List goals
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoals: async (accept: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('listGoals', 'accept', accept)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listGoals', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/goals`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a specific goal.
         * @summary Read a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGoal: async (goalGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalGuid' is not null or undefined
            assertParamExists('readGoal', 'goalGuid', goalGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readGoal', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/goals/{goal_guid}`
                .replace(`{${"goal_guid"}}`, encodeURIComponent(String(goalGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint repositions goal priority levels. If one goal is set to a lower priority, then any other goals need to be adjusted accordingly.
         * @summary Reposition goals
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {RepositionRequestBody} repositionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositionGoals: async (userGuid: string, repositionRequestBody: RepositionRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('repositionGoals', 'userGuid', userGuid)
            // verify required parameter 'repositionRequestBody' is not null or undefined
            assertParamExists('repositionGoals', 'repositionRequestBody', repositionRequestBody)
            const localVarPath = `/users/{user_guid}/goals/reposition`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.mx.api.v1+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates a specific goal.
         * @summary Update a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {UpdateGoalRequestBody} updateGoalRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal: async (goalGuid: string, userGuid: string, updateGoalRequestBody: UpdateGoalRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalGuid' is not null or undefined
            assertParamExists('updateGoal', 'goalGuid', goalGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateGoal', 'userGuid', userGuid)
            // verify required parameter 'updateGoalRequestBody' is not null or undefined
            assertParamExists('updateGoal', 'updateGoalRequestBody', updateGoalRequestBody)
            const localVarPath = `/users/{user_guid}/goals/{goal_guid}`
                .replace(`{${"goal_guid"}}`, encodeURIComponent(String(goalGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGoalRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a goal. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter.
         * @summary Create a goal
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {GoalRequestBody} goalRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGoal(userGuid: string, goalRequestBody: GoalRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGoal(userGuid, goalRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a goal.
         * @summary Delete a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoal(goalGuid: string, userGuid: string, accept: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoal(goalGuid, userGuid, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all goals a user can set.
         * @summary List goals
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGoals(accept: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGoals(accept, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read a specific goal.
         * @summary Read a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readGoal(goalGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readGoal(goalGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint repositions goal priority levels. If one goal is set to a lower priority, then any other goals need to be adjusted accordingly.
         * @summary Reposition goals
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {RepositionRequestBody} repositionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repositionGoals(userGuid: string, repositionRequestBody: RepositionRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repositionGoals(userGuid, repositionRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates a specific goal.
         * @summary Update a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {UpdateGoalRequestBody} updateGoalRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoal(goalGuid: string, userGuid: string, updateGoalRequestBody: UpdateGoalRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoal(goalGuid, userGuid, updateGoalRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoalsApiFp(configuration)
    return {
        /**
         * Create a goal. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter.
         * @summary Create a goal
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {GoalRequestBody} goalRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoal(userGuid: string, goalRequestBody: GoalRequestBody, options?: any): AxiosPromise<GoalResponseBody> {
            return localVarFp.createGoal(userGuid, goalRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a goal.
         * @summary Delete a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(goalGuid: string, userGuid: string, accept: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGoal(goalGuid, userGuid, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List all goals a user can set.
         * @summary List goals
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoals(accept: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<GoalsResponseBody> {
            return localVarFp.listGoals(accept, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a specific goal.
         * @summary Read a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGoal(goalGuid: string, userGuid: string, options?: any): AxiosPromise<GoalResponseBody> {
            return localVarFp.readGoal(goalGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint repositions goal priority levels. If one goal is set to a lower priority, then any other goals need to be adjusted accordingly.
         * @summary Reposition goals
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {RepositionRequestBody} repositionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repositionGoals(userGuid: string, repositionRequestBody: RepositionRequestBody, options?: any): AxiosPromise<RepositionResponseBody> {
            return localVarFp.repositionGoals(userGuid, repositionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates a specific goal.
         * @summary Update a goal
         * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {UpdateGoalRequestBody} updateGoalRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(goalGuid: string, userGuid: string, updateGoalRequestBody: UpdateGoalRequestBody, options?: any): AxiosPromise<GoalResponseBody> {
            return localVarFp.updateGoal(goalGuid, userGuid, updateGoalRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI {
    /**
     * Create a goal. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter.
     * @summary Create a goal
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {GoalRequestBody} goalRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public createGoal(userGuid: string, goalRequestBody: GoalRequestBody, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).createGoal(userGuid, goalRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a goal.
     * @summary Delete a goal
     * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} accept Specifies the media type expected in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public deleteGoal(goalGuid: string, userGuid: string, accept: string, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).deleteGoal(goalGuid, userGuid, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all goals a user can set.
     * @summary List goals
     * @param {string} accept Specifies the media type expected in the response.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public listGoals(accept: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).listGoals(accept, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a specific goal.
     * @summary Read a goal
     * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public readGoal(goalGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).readGoal(goalGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint repositions goal priority levels. If one goal is set to a lower priority, then any other goals need to be adjusted accordingly.
     * @summary Reposition goals
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {RepositionRequestBody} repositionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public repositionGoals(userGuid: string, repositionRequestBody: RepositionRequestBody, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).repositionGoals(userGuid, repositionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates a specific goal.
     * @summary Update a goal
     * @param {string} goalGuid The unique identifier for a goal. Defined by MX.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {UpdateGoalRequestBody} updateGoalRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public updateGoal(goalGuid: string, userGuid: string, updateGoalRequestBody: UpdateGoalRequestBody, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).updateGoal(goalGuid, userGuid, updateGoalRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InsightsApi - axios parameter creator
 * @export
 */
export const InsightsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to list all the accounts associated with the insight.
         * @summary List all accounts associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountsInsight: async (userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listAccountsInsight', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('listAccountsInsight', 'insightGuid', insightGuid)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}/accounts`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the categories associated with the insight.
         * @summary List all categories associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesInsight: async (userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listCategoriesInsight', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('listCategoriesInsight', 'insightGuid', insightGuid)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}/categories`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all insights associated with an account GUID.
         * @summary List insights by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInsightsByAccount: async (accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('listInsightsByAccount', 'accountGuid', accountGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listInsightsByAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}/insights`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all insights associated with a transaction GUID.
         * @summary List insights by transaction
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInsightsByTransaction: async (transactionGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('listInsightsByTransaction', 'transactionGuid', transactionGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listInsightsByTransaction', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transactions/{transaction_guid}/insights`
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the insights associated with the user.
         * @summary List all insights for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInsightsUser: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listInsightsUser', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/insights`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the merchants associated with the insight.
         * @summary List all merchants associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchantsInsight: async (userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listMerchantsInsight', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('listMerchantsInsight', 'insightGuid', insightGuid)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}/merchants`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the scheduled payments associated with the insight.
         * @summary List all scheduled payments associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPaymentsInsight: async (userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listScheduledPaymentsInsight', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('listScheduledPaymentsInsight', 'insightGuid', insightGuid)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}/scheduled_payments`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the transactions associated with the insight.
         * @summary List all transactions associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsInsight: async (userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTransactionsInsight', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('listTransactionsInsight', 'insightGuid', insightGuid)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}/transactions`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of an insight according to its unique GUID.
         * @summary Read insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readInsightUser: async (userGuid: string, insightGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readInsightUser', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('readInsightUser', 'insightGuid', insightGuid)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of an insight according to its unique GUID.
         * @summary Update insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {InsightUpdateRequestBody} insightUpdateRequestBody The insight to be updated (None of these parameters are required, but the user object cannot be empty.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInsight: async (userGuid: string, insightGuid: string, insightUpdateRequestBody: InsightUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateInsight', 'userGuid', userGuid)
            // verify required parameter 'insightGuid' is not null or undefined
            assertParamExists('updateInsight', 'insightGuid', insightGuid)
            // verify required parameter 'insightUpdateRequestBody' is not null or undefined
            assertParamExists('updateInsight', 'insightUpdateRequestBody', insightUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/insights/{insight_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"insight_guid"}}`, encodeURIComponent(String(insightGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insightUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsApi - functional programming interface
 * @export
 */
export const InsightsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to list all the accounts associated with the insight.
         * @summary List all accounts associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountsInsight(userGuid, insightGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the categories associated with the insight.
         * @summary List all categories associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategoriesInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategoriesInsight(userGuid, insightGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all insights associated with an account GUID.
         * @summary List insights by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInsightsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInsightsByAccount(accountGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all insights associated with a transaction GUID.
         * @summary List insights by transaction
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInsightsByTransaction(transactionGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInsightsByTransaction(transactionGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the insights associated with the user.
         * @summary List all insights for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInsightsUser(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInsightsUser(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the merchants associated with the insight.
         * @summary List all merchants associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMerchantsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMerchantsInsight(userGuid, insightGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the scheduled payments associated with the insight.
         * @summary List all scheduled payments associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listScheduledPaymentsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledPaymentsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listScheduledPaymentsInsight(userGuid, insightGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the transactions associated with the insight.
         * @summary List all transactions associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsInsight(userGuid, insightGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of an insight according to its unique GUID.
         * @summary Read insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readInsightUser(userGuid: string, insightGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readInsightUser(userGuid, insightGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of an insight according to its unique GUID.
         * @summary Update insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {InsightUpdateRequestBody} insightUpdateRequestBody The insight to be updated (None of these parameters are required, but the user object cannot be empty.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInsight(userGuid: string, insightGuid: string, insightUpdateRequestBody: InsightUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InsightResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInsight(userGuid, insightGuid, insightUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightsApi - factory interface
 * @export
 */
export const InsightsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightsApiFp(configuration)
    return {
        /**
         * Use this endpoint to list all the accounts associated with the insight.
         * @summary List all accounts associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<AccountsResponseBody> {
            return localVarFp.listAccountsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the categories associated with the insight.
         * @summary List all categories associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<CategoriesResponseBody> {
            return localVarFp.listCategoriesInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all insights associated with an account GUID.
         * @summary List insights by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInsightsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InsightsResponseBody> {
            return localVarFp.listInsightsByAccount(accountGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all insights associated with a transaction GUID.
         * @summary List insights by transaction
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInsightsByTransaction(transactionGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InsightsResponseBody> {
            return localVarFp.listInsightsByTransaction(transactionGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the insights associated with the user.
         * @summary List all insights for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInsightsUser(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InsightsResponseBody> {
            return localVarFp.listInsightsUser(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the merchants associated with the insight.
         * @summary List all merchants associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchantsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<MerchantsResponseBody> {
            return localVarFp.listMerchantsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the scheduled payments associated with the insight.
         * @summary List all scheduled payments associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScheduledPaymentsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<ScheduledPaymentsResponseBody> {
            return localVarFp.listScheduledPaymentsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the transactions associated with the insight.
         * @summary List all transactions associated with an insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<TransactionsResponseBody> {
            return localVarFp.listTransactionsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of an insight according to its unique GUID.
         * @summary Read insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readInsightUser(userGuid: string, insightGuid: string, options?: any): AxiosPromise<InsightResponseBody> {
            return localVarFp.readInsightUser(userGuid, insightGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of an insight according to its unique GUID.
         * @summary Update insight
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
         * @param {InsightUpdateRequestBody} insightUpdateRequestBody The insight to be updated (None of these parameters are required, but the user object cannot be empty.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInsight(userGuid: string, insightGuid: string, insightUpdateRequestBody: InsightUpdateRequestBody, options?: any): AxiosPromise<InsightResponse> {
            return localVarFp.updateInsight(userGuid, insightGuid, insightUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightsApi - object-oriented interface
 * @export
 * @class InsightsApi
 * @extends {BaseAPI}
 */
export class InsightsApi extends BaseAPI {
    /**
     * Use this endpoint to list all the accounts associated with the insight.
     * @summary List all accounts associated with an insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listAccountsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listAccountsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the categories associated with the insight.
     * @summary List all categories associated with an insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listCategoriesInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listCategoriesInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all insights associated with an account GUID.
     * @summary List insights by account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listInsightsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listInsightsByAccount(accountGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all insights associated with a transaction GUID.
     * @summary List insights by transaction
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listInsightsByTransaction(transactionGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listInsightsByTransaction(transactionGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the insights associated with the user.
     * @summary List all insights for a user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listInsightsUser(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listInsightsUser(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the merchants associated with the insight.
     * @summary List all merchants associated with an insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listMerchantsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listMerchantsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the scheduled payments associated with the insight.
     * @summary List all scheduled payments associated with an insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listScheduledPaymentsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listScheduledPaymentsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the transactions associated with the insight.
     * @summary List all transactions associated with an insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public listTransactionsInsight(userGuid: string, insightGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).listTransactionsInsight(userGuid, insightGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of an insight according to its unique GUID.
     * @summary Read insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public readInsightUser(userGuid: string, insightGuid: string, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).readInsightUser(userGuid, insightGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of an insight according to its unique GUID.
     * @summary Update insight
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} insightGuid The unique identifier for the insight. Defined by MX.
     * @param {InsightUpdateRequestBody} insightUpdateRequestBody The insight to be updated (None of these parameters are required, but the user object cannot be empty.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public updateInsight(userGuid: string, insightGuid: string, insightUpdateRequestBody: InsightUpdateRequestBody, options?: AxiosRequestConfig) {
        return InsightsApiFp(this.configuration).updateInsight(userGuid, insightGuid, insightUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstitutionsApi - axios parameter creator
 * @export
 */
export const InstitutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a paginated list containing institutions that have been set as the partnerâ€™s favorites, sorted by popularity. Please contact MX to set a list of favorites.
         * @summary List favorite institutions
         * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavoriteInstitutions: async (isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/institutions/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (isoCountryCode) {
                localVarQueryParameter['iso_country_code'] = isoCountryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to see which credentials will be needed to create a member for a specific institution.  Passing an invalid `institution_code` returns a `404`. 
         * @summary List institution credentials
         * @param {string} institutionCode The institution_code of the institution.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutionCredentials: async (institutionCode: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'institutionCode' is not null or undefined
            assertParamExists('listInstitutionCredentials', 'institutionCode', institutionCode)
            const localVarPath = `/institutions/{institution_code}/credentials`
                .replace(`{${"institution_code"}}`, encodeURIComponent(String(institutionCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of institutions based on the specified search term or parameter.
         * @summary List institutions
         * @param {string} [name] This will list only institutions in which the appended string appears.
         * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {boolean} [supportsAccountIdentification] Filter only institutions which support account identification.
         * @param {boolean} [supportsAccountStatement] Filter only institutions which support account statements.
         * @param {boolean} [supportsAccountVerification] Filter only institutions which support account verification.
         * @param {boolean} [supportsTransactionHistory] Filter only institutions which support extended transaction history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutions: async (name?: string, isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, supportsAccountIdentification?: boolean, supportsAccountStatement?: boolean, supportsAccountVerification?: boolean, supportsTransactionHistory?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/institutions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isoCountryCode) {
                localVarQueryParameter['iso_country_code'] = isoCountryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (supportsAccountIdentification !== undefined) {
                localVarQueryParameter['supports_account_identification'] = supportsAccountIdentification;
            }

            if (supportsAccountStatement !== undefined) {
                localVarQueryParameter['supports_account_statement'] = supportsAccountStatement;
            }

            if (supportsAccountVerification !== undefined) {
                localVarQueryParameter['supports_account_verification'] = supportsAccountVerification;
            }

            if (supportsTransactionHistory !== undefined) {
                localVarQueryParameter['supports_transaction_history'] = supportsTransactionHistory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about the institution specified by `institution_code`.
         * @summary Read institution
         * @param {string} institutionCode The institution_code of the institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readInstitution: async (institutionCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'institutionCode' is not null or undefined
            assertParamExists('readInstitution', 'institutionCode', institutionCode)
            const localVarPath = `/institutions/{institution_code}`
                .replace(`{${"institution_code"}}`, encodeURIComponent(String(institutionCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstitutionsApi - functional programming interface
 * @export
 */
export const InstitutionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstitutionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a paginated list containing institutions that have been set as the partnerâ€™s favorites, sorted by popularity. Please contact MX to set a list of favorites.
         * @summary List favorite institutions
         * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFavoriteInstitutions(isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFavoriteInstitutions(isoCountryCode, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to see which credentials will be needed to create a member for a specific institution.  Passing an invalid `institution_code` returns a `404`. 
         * @summary List institution credentials
         * @param {string} institutionCode The institution_code of the institution.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstitutionCredentials(institutionCode: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutionCredentials(institutionCode, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of institutions based on the specified search term or parameter.
         * @summary List institutions
         * @param {string} [name] This will list only institutions in which the appended string appears.
         * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {boolean} [supportsAccountIdentification] Filter only institutions which support account identification.
         * @param {boolean} [supportsAccountStatement] Filter only institutions which support account statements.
         * @param {boolean} [supportsAccountVerification] Filter only institutions which support account verification.
         * @param {boolean} [supportsTransactionHistory] Filter only institutions which support extended transaction history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstitutions(name?: string, isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, supportsAccountIdentification?: boolean, supportsAccountStatement?: boolean, supportsAccountVerification?: boolean, supportsTransactionHistory?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(name, isoCountryCode, page, recordsPerPage, supportsAccountIdentification, supportsAccountStatement, supportsAccountVerification, supportsTransactionHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about the institution specified by `institution_code`.
         * @summary Read institution
         * @param {string} institutionCode The institution_code of the institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readInstitution(institutionCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readInstitution(institutionCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InstitutionsApi - factory interface
 * @export
 */
export const InstitutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstitutionsApiFp(configuration)
    return {
        /**
         * This endpoint returns a paginated list containing institutions that have been set as the partnerâ€™s favorites, sorted by popularity. Please contact MX to set a list of favorites.
         * @summary List favorite institutions
         * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavoriteInstitutions(isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InstitutionsResponseBody> {
            return localVarFp.listFavoriteInstitutions(isoCountryCode, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to see which credentials will be needed to create a member for a specific institution.  Passing an invalid `institution_code` returns a `404`. 
         * @summary List institution credentials
         * @param {string} institutionCode The institution_code of the institution.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutionCredentials(institutionCode: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<CredentialsResponseBody> {
            return localVarFp.listInstitutionCredentials(institutionCode, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of institutions based on the specified search term or parameter.
         * @summary List institutions
         * @param {string} [name] This will list only institutions in which the appended string appears.
         * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {boolean} [supportsAccountIdentification] Filter only institutions which support account identification.
         * @param {boolean} [supportsAccountStatement] Filter only institutions which support account statements.
         * @param {boolean} [supportsAccountVerification] Filter only institutions which support account verification.
         * @param {boolean} [supportsTransactionHistory] Filter only institutions which support extended transaction history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstitutions(name?: string, isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, supportsAccountIdentification?: boolean, supportsAccountStatement?: boolean, supportsAccountVerification?: boolean, supportsTransactionHistory?: boolean, options?: any): AxiosPromise<InstitutionsResponseBody> {
            return localVarFp.listInstitutions(name, isoCountryCode, page, recordsPerPage, supportsAccountIdentification, supportsAccountStatement, supportsAccountVerification, supportsTransactionHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about the institution specified by `institution_code`.
         * @summary Read institution
         * @param {string} institutionCode The institution_code of the institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readInstitution(institutionCode: string, options?: any): AxiosPromise<InstitutionResponseBody> {
            return localVarFp.readInstitution(institutionCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstitutionsApi - object-oriented interface
 * @export
 * @class InstitutionsApi
 * @extends {BaseAPI}
 */
export class InstitutionsApi extends BaseAPI {
    /**
     * This endpoint returns a paginated list containing institutions that have been set as the partnerâ€™s favorites, sorted by popularity. Please contact MX to set a list of favorites.
     * @summary List favorite institutions
     * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public listFavoriteInstitutions(isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).listFavoriteInstitutions(isoCountryCode, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to see which credentials will be needed to create a member for a specific institution.  Passing an invalid `institution_code` returns a `404`. 
     * @summary List institution credentials
     * @param {string} institutionCode The institution_code of the institution.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public listInstitutionCredentials(institutionCode: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).listInstitutionCredentials(institutionCode, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of institutions based on the specified search term or parameter.
     * @summary List institutions
     * @param {string} [name] This will list only institutions in which the appended string appears.
     * @param {Array<string>} [isoCountryCode] An array of strings that filters institutions in the widget by the specified country code. Acceptable codes include &#x60;US&#x60;, &#x60;CA&#x60;, and &#x60;MX&#x60; (Mexico).
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;100&#x60;. If the value exceeds &#x60;100&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {boolean} [supportsAccountIdentification] Filter only institutions which support account identification.
     * @param {boolean} [supportsAccountStatement] Filter only institutions which support account statements.
     * @param {boolean} [supportsAccountVerification] Filter only institutions which support account verification.
     * @param {boolean} [supportsTransactionHistory] Filter only institutions which support extended transaction history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public listInstitutions(name?: string, isoCountryCode?: Array<string>, page?: number, recordsPerPage?: number, supportsAccountIdentification?: boolean, supportsAccountStatement?: boolean, supportsAccountVerification?: boolean, supportsTransactionHistory?: boolean, options?: AxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).listInstitutions(name, isoCountryCode, page, recordsPerPage, supportsAccountIdentification, supportsAccountStatement, supportsAccountVerification, supportsTransactionHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about the institution specified by `institution_code`.
     * @summary Read institution
     * @param {string} institutionCode The institution_code of the institution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    public readInstitution(institutionCode: string, options?: AxiosRequestConfig) {
        return InstitutionsApiFp(this.configuration).readInstitution(institutionCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvestmentHoldingsApi - axios parameter creator
 * @export
 */
export const InvestmentHoldingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint deactivates the specific user from the `/investment_holdings` product. To reactivate a user, use any of the current `/investment_holding` endpoints.
         * @summary Deactivate user from Investment Holdings
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deactivateUser', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/investment_holdings_deactivate`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all holdings associated with the user across all accounts.
         * @summary List holdings by user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHoldings: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listHoldings', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/investment_holdings`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all holdings associated with the particular account defined.
         * @summary List holdings by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHoldingsByAccount: async (accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('listHoldingsByAccount', 'accountGuid', accountGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listHoldingsByAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}/investment_holdings`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint lists all holdings associated with the specified member.
         * @summary List holdings by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHoldingsByMember: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listHoldingsByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listHoldingsByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/investment_holdings`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific `holding`.
         * @summary Read holding
         * @param {string} holdingGuid The unique id for a &#x60;holding&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHolding: async (holdingGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'holdingGuid' is not null or undefined
            assertParamExists('readHolding', 'holdingGuid', holdingGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readHolding', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/investment_holdings/{holding_guid}`
                .replace(`{${"holding_guid"}}`, encodeURIComponent(String(holdingGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvestmentHoldingsApi - functional programming interface
 * @export
 */
export const InvestmentHoldingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvestmentHoldingsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint deactivates the specific user from the `/investment_holdings` product. To reactivate a user, use any of the current `/investment_holding` endpoints.
         * @summary Deactivate user from Investment Holdings
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUser(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentHoldingsDeactivation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUser(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists all holdings associated with the user across all accounts.
         * @summary List holdings by user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHoldings(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentHoldingsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHoldings(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists all holdings associated with the particular account defined.
         * @summary List holdings by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHoldingsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentHoldingsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHoldingsByAccount(accountGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint lists all holdings associated with the specified member.
         * @summary List holdings by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHoldingsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentHoldingsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHoldingsByMember(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific `holding`.
         * @summary Read holding
         * @param {string} holdingGuid The unique id for a &#x60;holding&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readHolding(holdingGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentHoldingResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readHolding(holdingGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvestmentHoldingsApi - factory interface
 * @export
 */
export const InvestmentHoldingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvestmentHoldingsApiFp(configuration)
    return {
        /**
         * This endpoint deactivates the specific user from the `/investment_holdings` product. To reactivate a user, use any of the current `/investment_holding` endpoints.
         * @summary Deactivate user from Investment Holdings
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(userGuid: string, options?: any): AxiosPromise<InvestmentHoldingsDeactivation> {
            return localVarFp.deactivateUser(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists all holdings associated with the user across all accounts.
         * @summary List holdings by user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHoldings(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InvestmentHoldingsResponseBody> {
            return localVarFp.listHoldings(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists all holdings associated with the particular account defined.
         * @summary List holdings by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHoldingsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InvestmentHoldingsResponseBody> {
            return localVarFp.listHoldingsByAccount(accountGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint lists all holdings associated with the specified member.
         * @summary List holdings by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHoldingsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InvestmentHoldingsResponseBody> {
            return localVarFp.listHoldingsByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific `holding`.
         * @summary Read holding
         * @param {string} holdingGuid The unique id for a &#x60;holding&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readHolding(holdingGuid: string, userGuid: string, options?: any): AxiosPromise<InvestmentHoldingResponseBody> {
            return localVarFp.readHolding(holdingGuid, userGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvestmentHoldingsApi - object-oriented interface
 * @export
 * @class InvestmentHoldingsApi
 * @extends {BaseAPI}
 */
export class InvestmentHoldingsApi extends BaseAPI {
    /**
     * This endpoint deactivates the specific user from the `/investment_holdings` product. To reactivate a user, use any of the current `/investment_holding` endpoints.
     * @summary Deactivate user from Investment Holdings
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvestmentHoldingsApi
     */
    public deactivateUser(userGuid: string, options?: AxiosRequestConfig) {
        return InvestmentHoldingsApiFp(this.configuration).deactivateUser(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists all holdings associated with the user across all accounts.
     * @summary List holdings by user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvestmentHoldingsApi
     */
    public listHoldings(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InvestmentHoldingsApiFp(this.configuration).listHoldings(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists all holdings associated with the particular account defined.
     * @summary List holdings by account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvestmentHoldingsApi
     */
    public listHoldingsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InvestmentHoldingsApiFp(this.configuration).listHoldingsByAccount(accountGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint lists all holdings associated with the specified member.
     * @summary List holdings by member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvestmentHoldingsApi
     */
    public listHoldingsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return InvestmentHoldingsApiFp(this.configuration).listHoldingsByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific `holding`.
     * @summary Read holding
     * @param {string} holdingGuid The unique id for a &#x60;holding&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvestmentHoldingsApi
     */
    public readHolding(holdingGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return InvestmentHoldingsApiFp(this.configuration).readHolding(holdingGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManagedDataApi - axios parameter creator
 * @export
 */
export const ManagedDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a partner-managed account.
         * @summary Create managed account
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedAccountCreateRequestBody} managedAccountCreateRequestBody Managed account to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManagedAccount: async (memberGuid: string, userGuid: string, managedAccountCreateRequestBody: ManagedAccountCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('createManagedAccount', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createManagedAccount', 'userGuid', userGuid)
            // verify required parameter 'managedAccountCreateRequestBody' is not null or undefined
            assertParamExists('createManagedAccount', 'managedAccountCreateRequestBody', managedAccountCreateRequestBody)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedAccountCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a new partner-managed `member`.
         * @summary Create managed member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedMemberCreateRequestBody} managedMemberCreateRequestBody Managed member to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManagedMember: async (userGuid: string, managedMemberCreateRequestBody: ManagedMemberCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createManagedMember', 'userGuid', userGuid)
            // verify required parameter 'managedMemberCreateRequestBody' is not null or undefined
            assertParamExists('createManagedMember', 'managedMemberCreateRequestBody', managedMemberCreateRequestBody)
            const localVarPath = `/users/{user_guid}/managed_members`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedMemberCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a new partner-managed `transaction`.
         * @summary Create managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedTransactionCreateRequestBody} managedTransactionCreateRequestBody Managed transaction to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManagedTransaction: async (accountGuid: string, memberGuid: string, userGuid: string, managedTransactionCreateRequestBody: ManagedTransactionCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('createManagedTransaction', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('createManagedTransaction', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createManagedTransaction', 'userGuid', userGuid)
            // verify required parameter 'managedTransactionCreateRequestBody' is not null or undefined
            assertParamExists('createManagedTransaction', 'managedTransactionCreateRequestBody', managedTransactionCreateRequestBody)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}/transactions`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedTransactionCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a partner-managed account according to its unique GUID. If successful, the API will respond with a status of `204 No Content`.
         * @summary Delete managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedAccount: async (accountGuid: string, memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('deleteManagedAccount', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('deleteManagedAccount', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteManagedAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete the specified partner-managed `member`. The endpoint will respond with a status of `204 No Content` without a resource.
         * @summary Delete managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedMember: async (memberGuid: string, accept: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('deleteManagedMember', 'memberGuid', memberGuid)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('deleteManagedMember', 'accept', accept)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteManagedMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete the specified partner-managed `transaction`. The endpoint will respond with a status of `204 No Content` without a resource.
         * @summary Delete managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedTransaction: async (accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('deleteManagedTransaction', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('deleteManagedTransaction', 'memberGuid', memberGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('deleteManagedTransaction', 'transactionGuid', transactionGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteManagedTransaction', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}/transactions/{transaction_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a list of all the partner-managed accounts associated with the given partner-managed member.
         * @summary List managed accounts
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedAccounts: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listManagedAccounts', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listManagedAccounts', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of institutions which can be used to create partner-managed members.
         * @summary List managed institutions
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedInstitutions: async (page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/managed_institutions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the partner-managed members associated with the specified `user`.
         * @summary List managed members
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedMembers: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listManagedMembers', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of all the partner-managed transactions associated with the specified `account`, scoped through a `user` and a `member`.
         * @summary List managed transactions
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedTransactions: async (accountGuid: string, memberGuid: string, userGuid: string, page?: number, fromDate?: string, toDate?: string, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('listManagedTransactions', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listManagedTransactions', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listManagedTransactions', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}/transactions`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a partner-managed account according to its unique guid.
         * @summary Read managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readManagedAccount: async (accountGuid: string, memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('readManagedAccount', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readManagedAccount', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readManagedAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the attributes of the specified partner-managed`member`.
         * @summary Read managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readManagedMember: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readManagedMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readManagedMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests to this endpoint will return the attributes of the specified partner-managed `transaction`.
         * @summary Read managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readManagedTransaction: async (accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('readManagedTransaction', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readManagedTransaction', 'memberGuid', memberGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('readManagedTransaction', 'transactionGuid', transactionGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readManagedTransaction', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}/transactions/{transaction_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of a partner-managed account according to its unique GUID.
         * @summary Update managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedAccountUpdateRequestBody} managedAccountUpdateRequestBody Managed account object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedAccount: async (accountGuid: string, memberGuid: string, userGuid: string, managedAccountUpdateRequestBody: ManagedAccountUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('updateManagedAccount', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('updateManagedAccount', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateManagedAccount', 'userGuid', userGuid)
            // verify required parameter 'managedAccountUpdateRequestBody' is not null or undefined
            assertParamExists('updateManagedAccount', 'managedAccountUpdateRequestBody', managedAccountUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedAccountUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of the specified partner_managed `member`.
         * @summary Update managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedMemberUpdateRequestBody} managedMemberUpdateRequestBody Managed member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedMember: async (memberGuid: string, userGuid: string, managedMemberUpdateRequestBody: ManagedMemberUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('updateManagedMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateManagedMember', 'userGuid', userGuid)
            // verify required parameter 'managedMemberUpdateRequestBody' is not null or undefined
            assertParamExists('updateManagedMember', 'managedMemberUpdateRequestBody', managedMemberUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedMemberUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of the specified partner_managed `transaction`.
         * @summary Update managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedTransactionUpdateRequestBody} managedTransactionUpdateRequestBody Managed transaction object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedTransaction: async (accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, managedTransactionUpdateRequestBody: ManagedTransactionUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('updateManagedTransaction', 'accountGuid', accountGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('updateManagedTransaction', 'memberGuid', memberGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('updateManagedTransaction', 'transactionGuid', transactionGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateManagedTransaction', 'userGuid', userGuid)
            // verify required parameter 'managedTransactionUpdateRequestBody' is not null or undefined
            assertParamExists('updateManagedTransaction', 'managedTransactionUpdateRequestBody', managedTransactionUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/managed_members/{member_guid}/accounts/{account_guid}/transactions/{transaction_guid}`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(managedTransactionUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagedDataApi - functional programming interface
 * @export
 */
export const ManagedDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a partner-managed account.
         * @summary Create managed account
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedAccountCreateRequestBody} managedAccountCreateRequestBody Managed account to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedAccount(memberGuid: string, userGuid: string, managedAccountCreateRequestBody: ManagedAccountCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedAccount(memberGuid, userGuid, managedAccountCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to create a new partner-managed `member`.
         * @summary Create managed member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedMemberCreateRequestBody} managedMemberCreateRequestBody Managed member to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedMember(userGuid: string, managedMemberCreateRequestBody: ManagedMemberCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedMember(userGuid, managedMemberCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to create a new partner-managed `transaction`.
         * @summary Create managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedTransactionCreateRequestBody} managedTransactionCreateRequestBody Managed transaction to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManagedTransaction(accountGuid: string, memberGuid: string, userGuid: string, managedTransactionCreateRequestBody: ManagedTransactionCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManagedTransaction(accountGuid, memberGuid, userGuid, managedTransactionCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a partner-managed account according to its unique GUID. If successful, the API will respond with a status of `204 No Content`.
         * @summary Delete managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedAccount(accountGuid, memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete the specified partner-managed `member`. The endpoint will respond with a status of `204 No Content` without a resource.
         * @summary Delete managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedMember(memberGuid: string, accept: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedMember(memberGuid, accept, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete the specified partner-managed `transaction`. The endpoint will respond with a status of `204 No Content` without a resource.
         * @summary Delete managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to retrieve a list of all the partner-managed accounts associated with the given partner-managed member.
         * @summary List managed accounts
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManagedAccounts(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManagedAccounts(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of institutions which can be used to create partner-managed members.
         * @summary List managed institutions
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManagedInstitutions(page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstitutionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManagedInstitutions(page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the partner-managed members associated with the specified `user`.
         * @summary List managed members
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManagedMembers(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembersResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManagedMembers(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of all the partner-managed transactions associated with the specified `account`, scoped through a `user` and a `member`.
         * @summary List managed transactions
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManagedTransactions(accountGuid: string, memberGuid: string, userGuid: string, page?: number, fromDate?: string, toDate?: string, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManagedTransactions(accountGuid, memberGuid, userGuid, page, fromDate, toDate, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a partner-managed account according to its unique guid.
         * @summary Read managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readManagedAccount(accountGuid, memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the attributes of the specified partner-managed`member`.
         * @summary Read managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readManagedMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readManagedMember(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests to this endpoint will return the attributes of the specified partner-managed `transaction`.
         * @summary Read managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of a partner-managed account according to its unique GUID.
         * @summary Update managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedAccountUpdateRequestBody} managedAccountUpdateRequestBody Managed account object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, managedAccountUpdateRequestBody: ManagedAccountUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedAccount(accountGuid, memberGuid, userGuid, managedAccountUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of the specified partner_managed `member`.
         * @summary Update managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedMemberUpdateRequestBody} managedMemberUpdateRequestBody Managed member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedMember(memberGuid: string, userGuid: string, managedMemberUpdateRequestBody: ManagedMemberUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedMember(memberGuid, userGuid, managedMemberUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of the specified partner_managed `transaction`.
         * @summary Update managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedTransactionUpdateRequestBody} managedTransactionUpdateRequestBody Managed transaction object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, managedTransactionUpdateRequestBody: ManagedTransactionUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, managedTransactionUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagedDataApi - factory interface
 * @export
 */
export const ManagedDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagedDataApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a partner-managed account.
         * @summary Create managed account
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedAccountCreateRequestBody} managedAccountCreateRequestBody Managed account to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManagedAccount(memberGuid: string, userGuid: string, managedAccountCreateRequestBody: ManagedAccountCreateRequestBody, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.createManagedAccount(memberGuid, userGuid, managedAccountCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a new partner-managed `member`.
         * @summary Create managed member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedMemberCreateRequestBody} managedMemberCreateRequestBody Managed member to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManagedMember(userGuid: string, managedMemberCreateRequestBody: ManagedMemberCreateRequestBody, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.createManagedMember(userGuid, managedMemberCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a new partner-managed `transaction`.
         * @summary Create managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedTransactionCreateRequestBody} managedTransactionCreateRequestBody Managed transaction to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManagedTransaction(accountGuid: string, memberGuid: string, userGuid: string, managedTransactionCreateRequestBody: ManagedTransactionCreateRequestBody, options?: any): AxiosPromise<TransactionResponseBody> {
            return localVarFp.createManagedTransaction(accountGuid, memberGuid, userGuid, managedTransactionCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a partner-managed account according to its unique GUID. If successful, the API will respond with a status of `204 No Content`.
         * @summary Delete managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManagedAccount(accountGuid, memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete the specified partner-managed `member`. The endpoint will respond with a status of `204 No Content` without a resource.
         * @summary Delete managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedMember(memberGuid: string, accept: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManagedMember(memberGuid, accept, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete the specified partner-managed `transaction`. The endpoint will respond with a status of `204 No Content` without a resource.
         * @summary Delete managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a list of all the partner-managed accounts associated with the given partner-managed member.
         * @summary List managed accounts
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedAccounts(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<AccountsResponseBody> {
            return localVarFp.listManagedAccounts(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of institutions which can be used to create partner-managed members.
         * @summary List managed institutions
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedInstitutions(page?: number, recordsPerPage?: number, options?: any): AxiosPromise<InstitutionsResponseBody> {
            return localVarFp.listManagedInstitutions(page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the partner-managed members associated with the specified `user`.
         * @summary List managed members
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedMembers(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<MembersResponseBody> {
            return localVarFp.listManagedMembers(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of all the partner-managed transactions associated with the specified `account`, scoped through a `user` and a `member`.
         * @summary List managed transactions
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManagedTransactions(accountGuid: string, memberGuid: string, userGuid: string, page?: number, fromDate?: string, toDate?: string, recordsPerPage?: number, options?: any): AxiosPromise<TransactionsResponseBody> {
            return localVarFp.listManagedTransactions(accountGuid, memberGuid, userGuid, page, fromDate, toDate, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a partner-managed account according to its unique guid.
         * @summary Read managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.readManagedAccount(accountGuid, memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the attributes of the specified partner-managed`member`.
         * @summary Read managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readManagedMember(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.readManagedMember(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests to this endpoint will return the attributes of the specified partner-managed `transaction`.
         * @summary Read managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options?: any): AxiosPromise<TransactionResponseBody> {
            return localVarFp.readManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of a partner-managed account according to its unique GUID.
         * @summary Update managed account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedAccountUpdateRequestBody} managedAccountUpdateRequestBody Managed account object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, managedAccountUpdateRequestBody: ManagedAccountUpdateRequestBody, options?: any): AxiosPromise<AccountResponseBody> {
            return localVarFp.updateManagedAccount(accountGuid, memberGuid, userGuid, managedAccountUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of the specified partner_managed `member`.
         * @summary Update managed member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedMemberUpdateRequestBody} managedMemberUpdateRequestBody Managed member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedMember(memberGuid: string, userGuid: string, managedMemberUpdateRequestBody: ManagedMemberUpdateRequestBody, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.updateManagedMember(memberGuid, userGuid, managedMemberUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of the specified partner_managed `transaction`.
         * @summary Update managed transaction
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ManagedTransactionUpdateRequestBody} managedTransactionUpdateRequestBody Managed transaction object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, managedTransactionUpdateRequestBody: ManagedTransactionUpdateRequestBody, options?: any): AxiosPromise<TransactionResponseBody> {
            return localVarFp.updateManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, managedTransactionUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagedDataApi - object-oriented interface
 * @export
 * @class ManagedDataApi
 * @extends {BaseAPI}
 */
export class ManagedDataApi extends BaseAPI {
    /**
     * Use this endpoint to create a partner-managed account.
     * @summary Create managed account
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ManagedAccountCreateRequestBody} managedAccountCreateRequestBody Managed account to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public createManagedAccount(memberGuid: string, userGuid: string, managedAccountCreateRequestBody: ManagedAccountCreateRequestBody, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).createManagedAccount(memberGuid, userGuid, managedAccountCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a new partner-managed `member`.
     * @summary Create managed member
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ManagedMemberCreateRequestBody} managedMemberCreateRequestBody Managed member to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public createManagedMember(userGuid: string, managedMemberCreateRequestBody: ManagedMemberCreateRequestBody, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).createManagedMember(userGuid, managedMemberCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a new partner-managed `transaction`.
     * @summary Create managed transaction
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ManagedTransactionCreateRequestBody} managedTransactionCreateRequestBody Managed transaction to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public createManagedTransaction(accountGuid: string, memberGuid: string, userGuid: string, managedTransactionCreateRequestBody: ManagedTransactionCreateRequestBody, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).createManagedTransaction(accountGuid, memberGuid, userGuid, managedTransactionCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a partner-managed account according to its unique GUID. If successful, the API will respond with a status of `204 No Content`.
     * @summary Delete managed account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public deleteManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).deleteManagedAccount(accountGuid, memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete the specified partner-managed `member`. The endpoint will respond with a status of `204 No Content` without a resource.
     * @summary Delete managed member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} accept Specifies the media type expected in the response.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public deleteManagedMember(memberGuid: string, accept: string, userGuid: string, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).deleteManagedMember(memberGuid, accept, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete the specified partner-managed `transaction`. The endpoint will respond with a status of `204 No Content` without a resource.
     * @summary Delete managed transaction
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public deleteManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).deleteManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a list of all the partner-managed accounts associated with the given partner-managed member.
     * @summary List managed accounts
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public listManagedAccounts(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).listManagedAccounts(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of institutions which can be used to create partner-managed members.
     * @summary List managed institutions
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public listManagedInstitutions(page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).listManagedInstitutions(page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the partner-managed members associated with the specified `user`.
     * @summary List managed members
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public listManagedMembers(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).listManagedMembers(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of all the partner-managed transactions associated with the specified `account`, scoped through a `user` and a `member`.
     * @summary List managed transactions
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
     * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public listManagedTransactions(accountGuid: string, memberGuid: string, userGuid: string, page?: number, fromDate?: string, toDate?: string, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).listManagedTransactions(accountGuid, memberGuid, userGuid, page, fromDate, toDate, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a partner-managed account according to its unique guid.
     * @summary Read managed account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public readManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).readManagedAccount(accountGuid, memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the attributes of the specified partner-managed`member`.
     * @summary Read managed member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public readManagedMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).readManagedMember(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests to this endpoint will return the attributes of the specified partner-managed `transaction`.
     * @summary Read managed transaction
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public readManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).readManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of a partner-managed account according to its unique GUID.
     * @summary Update managed account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ManagedAccountUpdateRequestBody} managedAccountUpdateRequestBody Managed account object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public updateManagedAccount(accountGuid: string, memberGuid: string, userGuid: string, managedAccountUpdateRequestBody: ManagedAccountUpdateRequestBody, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).updateManagedAccount(accountGuid, memberGuid, userGuid, managedAccountUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of the specified partner_managed `member`.
     * @summary Update managed member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ManagedMemberUpdateRequestBody} managedMemberUpdateRequestBody Managed member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public updateManagedMember(memberGuid: string, userGuid: string, managedMemberUpdateRequestBody: ManagedMemberUpdateRequestBody, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).updateManagedMember(memberGuid, userGuid, managedMemberUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of the specified partner_managed `transaction`.
     * @summary Update managed transaction
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ManagedTransactionUpdateRequestBody} managedTransactionUpdateRequestBody Managed transaction object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedDataApi
     */
    public updateManagedTransaction(accountGuid: string, memberGuid: string, transactionGuid: string, userGuid: string, managedTransactionUpdateRequestBody: ManagedTransactionUpdateRequestBody, options?: AxiosRequestConfig) {
        return ManagedDataApiFp(this.configuration).updateManagedTransaction(accountGuid, memberGuid, transactionGuid, userGuid, managedTransactionUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calling this endpoint initiates an aggregation event for the member. This brings in the latest account and transaction data from the connected institution. If this data has recently been updated, MX may not initiate an aggregation event.
         * @summary Aggregate member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {boolean} [includeHoldings] When set to &#x60;false&#x60;, the aggregation will not gather holdings data. Defaults to &#x60;true&#x60;.
         * @param {boolean} [includeTransactions] When set to &#x60;false&#x60;, the aggregation will not gather transactions data. Defaults to &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateMember: async (memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, includeHoldings?: boolean, includeTransactions?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('aggregateMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('aggregateMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/aggregate`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includeHoldings !== undefined) {
                localVarQueryParameter['include_holdings'] = includeHoldings;
            }

            if (includeTransactions !== undefined) {
                localVarQueryParameter['include_transactions'] = includeTransactions;
            }

            if (xCALLBACKPAYLOAD != null) {
                localVarHeaderParameter['X-CALLBACK-PAYLOAD'] = String(xCALLBACKPAYLOAD);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint operates much like the aggregate member endpoint except that it gathers only account balance information; it does not gather any transaction data.
         * @summary Check balances
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkBalances: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('checkBalances', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('checkBalances', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/check_balance`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to create a new member. Members are created with the required parameters credentials and institution_code, and the optional parameters id and metadata. When creating a member, youll need to include the correct type of credential required by the financial institution and provided by the user. You can find out which credential type is required with the `/institutions/{institution_code}/credentials` endpoint. If successful, the MX Platform API will respond with the newly-created member object. Once you successfully create a member, MX will immediately validate the provided credentials and attempt to aggregate data for accounts and transactions.
         * @summary Create member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberCreateRequestBody} memberCreateRequestBody Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code)
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember: async (userGuid: string, memberCreateRequestBody: MemberCreateRequestBody, xCALLBACKPAYLOAD?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createMember', 'userGuid', userGuid)
            // verify required parameter 'memberCreateRequestBody' is not null or undefined
            assertParamExists('createMember', 'memberCreateRequestBody', memberCreateRequestBody)
            const localVarPath = `/users/{user_guid}/members`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xCALLBACKPAYLOAD != null) {
                localVarHeaderParameter['X-CALLBACK-PAYLOAD'] = String(xCALLBACKPAYLOAD);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accessing this endpoint will permanently delete a member.
         * @summary Delete member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('deleteMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The identify endpoint begins an identification process for an already-existing member.
         * @summary Identify member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyMember: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('identifyMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('identifyMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/identify`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint for information on what multi-factor authentication challenges need to be answered in order to aggregate a member. If the aggregation is not challenged, i.e., the member does not have a connection status of `CHALLENGED`, then code `204 No Content` will be returned. If the aggregation has been challenged, i.e., the member does have a connection status of `CHALLENGED`, then code `200 OK` will be returned - along with the corresponding credentials.
         * @summary List member challenges
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberChallenges: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listMemberChallenges', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listMemberChallenges', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/challenges`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns an array which contains information on every non-MFA credential associated with a specific member.
         * @summary List member credentials
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberCredentials: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listMemberCredentials', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listMemberCredentials', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/credentials`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns an array which contains information on every member associated with a specific user.
         * @summary List members
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (userGuid: string, page?: number, recordsPerPage?: number, useCase?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listMembers', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (useCase !== undefined) {
                localVarQueryParameter['use_case'] = useCase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific member.
         * @summary Read member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMember: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides the status of the members most recent aggregation event. This is an important step in the aggregation process, and the results returned by this endpoint should determine what you do next in order to successfully aggregate a member. MX has introduced new, more detailed information on the current status of a members connection to a financial institution and the state of its aggregation - the connection_status field. These are intended to replace and expand upon the information provided in the status field, which will soon be deprecated; support for the status field remains for the time being.
         * @summary Read member status
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMemberStatus: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readMemberStatus', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readMemberStatus', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/status`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint answers the challenges needed when a member has been challenged by multi-factor authentication.
         * @summary Resume aggregation
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberResumeRequestBody} memberResumeRequestBody Member object with MFA challenge answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeAggregation: async (memberGuid: string, userGuid: string, memberResumeRequestBody: MemberResumeRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('resumeAggregation', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('resumeAggregation', 'userGuid', userGuid)
            // verify required parameter 'memberResumeRequestBody' is not null or undefined
            assertParamExists('resumeAggregation', 'memberResumeRequestBody', memberResumeRequestBody)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/resume`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberResumeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a members attributes. Only the credentials, id, and metadata parameters can be updated. To get a list of the required credentials for the member, use the list member credentials endpoint.
         * @summary Update member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberUpdateRequestBody} memberUpdateRequestBody Member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember: async (memberGuid: string, userGuid: string, memberUpdateRequestBody: MemberUpdateRequestBody, xCALLBACKPAYLOAD?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('updateMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateMember', 'userGuid', userGuid)
            // verify required parameter 'memberUpdateRequestBody' is not null or undefined
            assertParamExists('updateMember', 'memberUpdateRequestBody', memberUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/members/{member_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xCALLBACKPAYLOAD != null) {
                localVarHeaderParameter['X-CALLBACK-PAYLOAD'] = String(xCALLBACKPAYLOAD);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The verify endpoint begins a verification process for a member.
         * @summary Verify member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMember: async (memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('verifyMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('verifyMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/verify`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xCALLBACKPAYLOAD != null) {
                localVarHeaderParameter['X-CALLBACK-PAYLOAD'] = String(xCALLBACKPAYLOAD);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * Calling this endpoint initiates an aggregation event for the member. This brings in the latest account and transaction data from the connected institution. If this data has recently been updated, MX may not initiate an aggregation event.
         * @summary Aggregate member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {boolean} [includeHoldings] When set to &#x60;false&#x60;, the aggregation will not gather holdings data. Defaults to &#x60;true&#x60;.
         * @param {boolean} [includeTransactions] When set to &#x60;false&#x60;, the aggregation will not gather transactions data. Defaults to &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateMember(memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, includeHoldings?: boolean, includeTransactions?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateMember(memberGuid, userGuid, xCALLBACKPAYLOAD, includeHoldings, includeTransactions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint operates much like the aggregate member endpoint except that it gathers only account balance information; it does not gather any transaction data.
         * @summary Check balances
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkBalances(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkBalances(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to create a new member. Members are created with the required parameters credentials and institution_code, and the optional parameters id and metadata. When creating a member, youll need to include the correct type of credential required by the financial institution and provided by the user. You can find out which credential type is required with the `/institutions/{institution_code}/credentials` endpoint. If successful, the MX Platform API will respond with the newly-created member object. Once you successfully create a member, MX will immediately validate the provided credentials and attempt to aggregate data for accounts and transactions.
         * @summary Create member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberCreateRequestBody} memberCreateRequestBody Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code)
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMember(userGuid: string, memberCreateRequestBody: MemberCreateRequestBody, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMember(userGuid, memberCreateRequestBody, xCALLBACKPAYLOAD, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accessing this endpoint will permanently delete a member.
         * @summary Delete member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMember(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The identify endpoint begins an identification process for an already-existing member.
         * @summary Identify member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifyMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifyMember(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint for information on what multi-factor authentication challenges need to be answered in order to aggregate a member. If the aggregation is not challenged, i.e., the member does not have a connection status of `CHALLENGED`, then code `204 No Content` will be returned. If the aggregation has been challenged, i.e., the member does have a connection status of `CHALLENGED`, then code `200 OK` will be returned - along with the corresponding credentials.
         * @summary List member challenges
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemberChallenges(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChallengesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemberChallenges(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns an array which contains information on every non-MFA credential associated with a specific member.
         * @summary List member credentials
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemberCredentials(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemberCredentials(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns an array which contains information on every member associated with a specific user.
         * @summary List members
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(userGuid: string, page?: number, recordsPerPage?: number, useCase?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembersResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(userGuid, page, recordsPerPage, useCase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific member.
         * @summary Read member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMember(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint provides the status of the members most recent aggregation event. This is an important step in the aggregation process, and the results returned by this endpoint should determine what you do next in order to successfully aggregate a member. MX has introduced new, more detailed information on the current status of a members connection to a financial institution and the state of its aggregation - the connection_status field. These are intended to replace and expand upon the information provided in the status field, which will soon be deprecated; support for the status field remains for the time being.
         * @summary Read member status
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMemberStatus(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberStatusResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMemberStatus(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint answers the challenges needed when a member has been challenged by multi-factor authentication.
         * @summary Resume aggregation
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberResumeRequestBody} memberResumeRequestBody Member object with MFA challenge answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeAggregation(memberGuid: string, userGuid: string, memberResumeRequestBody: MemberResumeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeAggregation(memberGuid, userGuid, memberResumeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update a members attributes. Only the credentials, id, and metadata parameters can be updated. To get a list of the required credentials for the member, use the list member credentials endpoint.
         * @summary Update member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberUpdateRequestBody} memberUpdateRequestBody Member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMember(memberGuid: string, userGuid: string, memberUpdateRequestBody: MemberUpdateRequestBody, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMember(memberGuid, userGuid, memberUpdateRequestBody, xCALLBACKPAYLOAD, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The verify endpoint begins a verification process for a member.
         * @summary Verify member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMember(memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMember(memberGuid, userGuid, xCALLBACKPAYLOAD, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * Calling this endpoint initiates an aggregation event for the member. This brings in the latest account and transaction data from the connected institution. If this data has recently been updated, MX may not initiate an aggregation event.
         * @summary Aggregate member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {boolean} [includeHoldings] When set to &#x60;false&#x60;, the aggregation will not gather holdings data. Defaults to &#x60;true&#x60;.
         * @param {boolean} [includeTransactions] When set to &#x60;false&#x60;, the aggregation will not gather transactions data. Defaults to &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateMember(memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, includeHoldings?: boolean, includeTransactions?: boolean, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.aggregateMember(memberGuid, userGuid, xCALLBACKPAYLOAD, includeHoldings, includeTransactions, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint operates much like the aggregate member endpoint except that it gathers only account balance information; it does not gather any transaction data.
         * @summary Check balances
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkBalances(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.checkBalances(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create a new member. Members are created with the required parameters credentials and institution_code, and the optional parameters id and metadata. When creating a member, youll need to include the correct type of credential required by the financial institution and provided by the user. You can find out which credential type is required with the `/institutions/{institution_code}/credentials` endpoint. If successful, the MX Platform API will respond with the newly-created member object. Once you successfully create a member, MX will immediately validate the provided credentials and attempt to aggregate data for accounts and transactions.
         * @summary Create member
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberCreateRequestBody} memberCreateRequestBody Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code)
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(userGuid: string, memberCreateRequestBody: MemberCreateRequestBody, xCALLBACKPAYLOAD?: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.createMember(userGuid, memberCreateRequestBody, xCALLBACKPAYLOAD, options).then((request) => request(axios, basePath));
        },
        /**
         * Accessing this endpoint will permanently delete a member.
         * @summary Delete member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(memberGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMember(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * The identify endpoint begins an identification process for an already-existing member.
         * @summary Identify member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyMember(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.identifyMember(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint for information on what multi-factor authentication challenges need to be answered in order to aggregate a member. If the aggregation is not challenged, i.e., the member does not have a connection status of `CHALLENGED`, then code `204 No Content` will be returned. If the aggregation has been challenged, i.e., the member does have a connection status of `CHALLENGED`, then code `200 OK` will be returned - along with the corresponding credentials.
         * @summary List member challenges
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberChallenges(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<ChallengesResponseBody> {
            return localVarFp.listMemberChallenges(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns an array which contains information on every non-MFA credential associated with a specific member.
         * @summary List member credentials
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemberCredentials(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<CredentialsResponseBody> {
            return localVarFp.listMemberCredentials(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns an array which contains information on every member associated with a specific user.
         * @summary List members
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(userGuid: string, page?: number, recordsPerPage?: number, useCase?: string, options?: any): AxiosPromise<MembersResponseBody> {
            return localVarFp.listMembers(userGuid, page, recordsPerPage, useCase, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific member.
         * @summary Read member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMember(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.readMember(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides the status of the members most recent aggregation event. This is an important step in the aggregation process, and the results returned by this endpoint should determine what you do next in order to successfully aggregate a member. MX has introduced new, more detailed information on the current status of a members connection to a financial institution and the state of its aggregation - the connection_status field. These are intended to replace and expand upon the information provided in the status field, which will soon be deprecated; support for the status field remains for the time being.
         * @summary Read member status
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMemberStatus(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberStatusResponseBody> {
            return localVarFp.readMemberStatus(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint answers the challenges needed when a member has been challenged by multi-factor authentication.
         * @summary Resume aggregation
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberResumeRequestBody} memberResumeRequestBody Member object with MFA challenge answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeAggregation(memberGuid: string, userGuid: string, memberResumeRequestBody: MemberResumeRequestBody, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.resumeAggregation(memberGuid, userGuid, memberResumeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a members attributes. Only the credentials, id, and metadata parameters can be updated. To get a list of the required credentials for the member, use the list member credentials endpoint.
         * @summary Update member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MemberUpdateRequestBody} memberUpdateRequestBody Member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMember(memberGuid: string, userGuid: string, memberUpdateRequestBody: MemberUpdateRequestBody, xCALLBACKPAYLOAD?: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.updateMember(memberGuid, userGuid, memberUpdateRequestBody, xCALLBACKPAYLOAD, options).then((request) => request(axios, basePath));
        },
        /**
         * The verify endpoint begins a verification process for a member.
         * @summary Verify member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMember(memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.verifyMember(memberGuid, userGuid, xCALLBACKPAYLOAD, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * Calling this endpoint initiates an aggregation event for the member. This brings in the latest account and transaction data from the connected institution. If this data has recently been updated, MX may not initiate an aggregation event.
     * @summary Aggregate member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
     * @param {boolean} [includeHoldings] When set to &#x60;false&#x60;, the aggregation will not gather holdings data. Defaults to &#x60;true&#x60;.
     * @param {boolean} [includeTransactions] When set to &#x60;false&#x60;, the aggregation will not gather transactions data. Defaults to &#x60;true&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public aggregateMember(memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, includeHoldings?: boolean, includeTransactions?: boolean, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).aggregateMember(memberGuid, userGuid, xCALLBACKPAYLOAD, includeHoldings, includeTransactions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint operates much like the aggregate member endpoint except that it gathers only account balance information; it does not gather any transaction data.
     * @summary Check balances
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public checkBalances(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).checkBalances(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to create a new member. Members are created with the required parameters credentials and institution_code, and the optional parameters id and metadata. When creating a member, youll need to include the correct type of credential required by the financial institution and provided by the user. You can find out which credential type is required with the `/institutions/{institution_code}/credentials` endpoint. If successful, the MX Platform API will respond with the newly-created member object. Once you successfully create a member, MX will immediately validate the provided credentials and attempt to aggregate data for accounts and transactions.
     * @summary Create member
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {MemberCreateRequestBody} memberCreateRequestBody Member object to be created with optional parameters (id and metadata) and required parameters (credentials and institution_code)
     * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public createMember(userGuid: string, memberCreateRequestBody: MemberCreateRequestBody, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).createMember(userGuid, memberCreateRequestBody, xCALLBACKPAYLOAD, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accessing this endpoint will permanently delete a member.
     * @summary Delete member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public deleteMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).deleteMember(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The identify endpoint begins an identification process for an already-existing member.
     * @summary Identify member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public identifyMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).identifyMember(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint for information on what multi-factor authentication challenges need to be answered in order to aggregate a member. If the aggregation is not challenged, i.e., the member does not have a connection status of `CHALLENGED`, then code `204 No Content` will be returned. If the aggregation has been challenged, i.e., the member does have a connection status of `CHALLENGED`, then code `200 OK` will be returned - along with the corresponding credentials.
     * @summary List member challenges
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMemberChallenges(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMemberChallenges(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns an array which contains information on every non-MFA credential associated with a specific member.
     * @summary List member credentials
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMemberCredentials(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMemberCredentials(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns an array which contains information on every member associated with a specific user.
     * @summary List members
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMembers(userGuid: string, page?: number, recordsPerPage?: number, useCase?: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMembers(userGuid, page, recordsPerPage, useCase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific member.
     * @summary Read member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public readMember(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).readMember(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint provides the status of the members most recent aggregation event. This is an important step in the aggregation process, and the results returned by this endpoint should determine what you do next in order to successfully aggregate a member. MX has introduced new, more detailed information on the current status of a members connection to a financial institution and the state of its aggregation - the connection_status field. These are intended to replace and expand upon the information provided in the status field, which will soon be deprecated; support for the status field remains for the time being.
     * @summary Read member status
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public readMemberStatus(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).readMemberStatus(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint answers the challenges needed when a member has been challenged by multi-factor authentication.
     * @summary Resume aggregation
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {MemberResumeRequestBody} memberResumeRequestBody Member object with MFA challenge answers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public resumeAggregation(memberGuid: string, userGuid: string, memberResumeRequestBody: MemberResumeRequestBody, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).resumeAggregation(memberGuid, userGuid, memberResumeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a members attributes. Only the credentials, id, and metadata parameters can be updated. To get a list of the required credentials for the member, use the list member credentials endpoint.
     * @summary Update member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {MemberUpdateRequestBody} memberUpdateRequestBody Member object to be updated (While no single parameter is required, the request body can\&#39;t be empty)
     * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public updateMember(memberGuid: string, userGuid: string, memberUpdateRequestBody: MemberUpdateRequestBody, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).updateMember(memberGuid, userGuid, memberUpdateRequestBody, xCALLBACKPAYLOAD, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The verify endpoint begins a verification process for a member.
     * @summary Verify member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public verifyMember(memberGuid: string, userGuid: string, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).verifyMember(memberGuid, userGuid, xCALLBACKPAYLOAD, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MerchantsApi - axios parameter creator
 * @export
 */
export const MerchantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a paginated list of all the merchants in the MX system.
         * @summary List merchants
         * @param {string} [name] This will list only merchants in which the appended string appears.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchants: async (name?: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a particular merchant, such as a logo, name, and website.
         * @summary Read merchant
         * @param {string} merchantGuid The unique id for a &#x60;merchant&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMerchant: async (merchantGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantGuid' is not null or undefined
            assertParamExists('readMerchant', 'merchantGuid', merchantGuid)
            const localVarPath = `/merchants/{merchant_guid}`
                .replace(`{${"merchant_guid"}}`, encodeURIComponent(String(merchantGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the specified `merchant_location` resource. The `merchant_location_guid` can be found on `transaction` objects.
         * @summary Read merchant location
         * @param {string} merchantLocationGuid The unique id for a &#x60;merchant_location&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMerchantLocation: async (merchantLocationGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantLocationGuid' is not null or undefined
            assertParamExists('readMerchantLocation', 'merchantLocationGuid', merchantLocationGuid)
            const localVarPath = `/merchant_locations/{merchant_location_guid}`
                .replace(`{${"merchant_location_guid"}}`, encodeURIComponent(String(merchantLocationGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantsApi - functional programming interface
 * @export
 */
export const MerchantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a paginated list of all the merchants in the MX system.
         * @summary List merchants
         * @param {string} [name] This will list only merchants in which the appended string appears.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMerchants(name?: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMerchants(name, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information about a particular merchant, such as a logo, name, and website.
         * @summary Read merchant
         * @param {string} merchantGuid The unique id for a &#x60;merchant&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMerchant(merchantGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMerchant(merchantGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the specified `merchant_location` resource. The `merchant_location_guid` can be found on `transaction` objects.
         * @summary Read merchant location
         * @param {string} merchantLocationGuid The unique id for a &#x60;merchant_location&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMerchantLocation(merchantLocationGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantLocationResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMerchantLocation(merchantLocationGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MerchantsApi - factory interface
 * @export
 */
export const MerchantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantsApiFp(configuration)
    return {
        /**
         * This endpoint returns a paginated list of all the merchants in the MX system.
         * @summary List merchants
         * @param {string} [name] This will list only merchants in which the appended string appears.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchants(name?: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<MerchantsResponseBody> {
            return localVarFp.listMerchants(name, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a particular merchant, such as a logo, name, and website.
         * @summary Read merchant
         * @param {string} merchantGuid The unique id for a &#x60;merchant&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMerchant(merchantGuid: string, options?: any): AxiosPromise<MerchantResponseBody> {
            return localVarFp.readMerchant(merchantGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the specified `merchant_location` resource. The `merchant_location_guid` can be found on `transaction` objects.
         * @summary Read merchant location
         * @param {string} merchantLocationGuid The unique id for a &#x60;merchant_location&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMerchantLocation(merchantLocationGuid: string, options?: any): AxiosPromise<MerchantLocationResponseBody> {
            return localVarFp.readMerchantLocation(merchantLocationGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantsApi - object-oriented interface
 * @export
 * @class MerchantsApi
 * @extends {BaseAPI}
 */
export class MerchantsApi extends BaseAPI {
    /**
     * This endpoint returns a paginated list of all the merchants in the MX system.
     * @summary List merchants
     * @param {string} [name] This will list only merchants in which the appended string appears.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public listMerchants(name?: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).listMerchants(name, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a particular merchant, such as a logo, name, and website.
     * @summary Read merchant
     * @param {string} merchantGuid The unique id for a &#x60;merchant&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public readMerchant(merchantGuid: string, options?: AxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).readMerchant(merchantGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the specified `merchant_location` resource. The `merchant_location_guid` can be found on `transaction` objects.
     * @summary Read merchant location
     * @param {string} merchantLocationGuid The unique id for a &#x60;merchant_location&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public readMerchantLocation(merchantLocationGuid: string, options?: AxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).readMerchantLocation(merchantLocationGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MicrodepositsApi - axios parameter creator
 * @export
 */
export const MicrodepositsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create or pre-initiate a microdeposit. The response will include the new microdeposit record with a status of `INITIATED` or `PREINITIATED` respectively.  To pre-initiate a microdeposit, you only need to set `email` (string), `first_name` (string), and `last_name` (string) in the request body.   Pre-initiating a microdeposit allows you to pass the end user\'s first name, last name, and email if this data has already been collected. If the end user selects an institution which requires the microdeposit flow, the pre-initiated `micro_deposit` will be used and the Connect Widget step that normally requests this info from the end user will be skipped. However, if the end user selects an institution which supports IAV, the pre-initiated `micro_deposit` will be deleted and IAV will be used instead. When requesting a Connect Widget URL after pre-initiating, make sure to set the `current_microdeposit_guid` to the resulting microdeposit\'s `guid` and set the `mode` to `verification`. If you use this enhanced flow, a `micro_deposit` should be pre-initiated for all connect sessions in verification mode. After pre-initiating a microdeposit, pass the GUID to the config as `current_microdeposit_guid` and set the `mode` to `verification` when requesting a Connect URL.  Pre-initiating a microdeposit is optional. If you choose to implement this flow, it should be used for all Connect Widget sessions in verification mode. 
         * @summary Create or pre-initiate a microdeposit
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MicrodepositRequestBody} microdepositRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMicrodeposit: async (userGuid: string, microdepositRequestBody: MicrodepositRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createMicrodeposit', 'userGuid', userGuid)
            // verify required parameter 'microdepositRequestBody' is not null or undefined
            assertParamExists('createMicrodeposit', 'microdepositRequestBody', microdepositRequestBody)
            const localVarPath = `/users/{user_guid}/micro_deposits`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(microdepositRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete the specified microdeposit.
         * @summary Delete a microdeposit
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMicrodeposit: async (microDepositGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'microDepositGuid' is not null or undefined
            assertParamExists('deleteMicrodeposit', 'microDepositGuid', microDepositGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteMicrodeposit', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/micro_deposits/{micro_deposit_guid}`
                .replace(`{${"micro_deposit_guid"}}`, encodeURIComponent(String(microDepositGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID.
         * @summary List all microdeposits for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserMicrodeposits: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listUserMicrodeposits', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/micro_deposits`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of the account verifications associated with the user, as well as the status of those verifications. 
         * @summary List all verifications for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserVerifications: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listUserVerifications', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/account_verifications`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID. <br /><br /> Webhooks for microdeposit status changes are triggered when a status changes. The actual status of the microdeposit guid updates every minute. You may force a status update by calling the read microdeposit endpoint.
         * @summary Read a microdeposit for a user
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMicrodeposit: async (microDepositGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'microDepositGuid' is not null or undefined
            assertParamExists('readUserMicrodeposit', 'microDepositGuid', microDepositGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readUserMicrodeposit', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/micro_deposits/{micro_deposit_guid}`
                .replace(`{${"micro_deposit_guid"}}`, encodeURIComponent(String(microDepositGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to verify the amounts deposited into the account during a microdeposit verification. The verification has not successfully completed until the `status` is `VERIFIED`. Poll the `/users/{user_guid}/micro_deposits/{micro_deposit_guid}` (read microdeposit) endpoint until you see this status or an error state.
         * @summary Verify a Microdeposit
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {MicrodepositVerifyRequestBody} [microdepositVerifyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMicrodeposit: async (microDepositGuid: string, microdepositVerifyRequestBody?: MicrodepositVerifyRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'microDepositGuid' is not null or undefined
            assertParamExists('verifyMicrodeposit', 'microDepositGuid', microDepositGuid)
            const localVarPath = `/micro_deposits/{micro_deposit_guid}/verify`
                .replace(`{${"micro_deposit_guid"}}`, encodeURIComponent(String(microDepositGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(microdepositVerifyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MicrodepositsApi - functional programming interface
 * @export
 */
export const MicrodepositsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MicrodepositsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create or pre-initiate a microdeposit. The response will include the new microdeposit record with a status of `INITIATED` or `PREINITIATED` respectively.  To pre-initiate a microdeposit, you only need to set `email` (string), `first_name` (string), and `last_name` (string) in the request body.   Pre-initiating a microdeposit allows you to pass the end user\'s first name, last name, and email if this data has already been collected. If the end user selects an institution which requires the microdeposit flow, the pre-initiated `micro_deposit` will be used and the Connect Widget step that normally requests this info from the end user will be skipped. However, if the end user selects an institution which supports IAV, the pre-initiated `micro_deposit` will be deleted and IAV will be used instead. When requesting a Connect Widget URL after pre-initiating, make sure to set the `current_microdeposit_guid` to the resulting microdeposit\'s `guid` and set the `mode` to `verification`. If you use this enhanced flow, a `micro_deposit` should be pre-initiated for all connect sessions in verification mode. After pre-initiating a microdeposit, pass the GUID to the config as `current_microdeposit_guid` and set the `mode` to `verification` when requesting a Connect URL.  Pre-initiating a microdeposit is optional. If you choose to implement this flow, it should be used for all Connect Widget sessions in verification mode. 
         * @summary Create or pre-initiate a microdeposit
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MicrodepositRequestBody} microdepositRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMicrodeposit(userGuid: string, microdepositRequestBody: MicrodepositRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrodepositResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMicrodeposit(userGuid, microdepositRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete the specified microdeposit.
         * @summary Delete a microdeposit
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMicrodeposit(microDepositGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMicrodeposit(microDepositGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID.
         * @summary List all microdeposits for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserMicrodeposits(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrodepositsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserMicrodeposits(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of the account verifications associated with the user, as well as the status of those verifications. 
         * @summary List all verifications for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserVerifications(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrodepositResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserVerifications(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID. <br /><br /> Webhooks for microdeposit status changes are triggered when a status changes. The actual status of the microdeposit guid updates every minute. You may force a status update by calling the read microdeposit endpoint.
         * @summary Read a microdeposit for a user
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMicrodeposit(microDepositGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrodepositResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserMicrodeposit(microDepositGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to verify the amounts deposited into the account during a microdeposit verification. The verification has not successfully completed until the `status` is `VERIFIED`. Poll the `/users/{user_guid}/micro_deposits/{micro_deposit_guid}` (read microdeposit) endpoint until you see this status or an error state.
         * @summary Verify a Microdeposit
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {MicrodepositVerifyRequestBody} [microdepositVerifyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMicrodeposit(microDepositGuid: string, microdepositVerifyRequestBody?: MicrodepositVerifyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrodepositResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMicrodeposit(microDepositGuid, microdepositVerifyRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MicrodepositsApi - factory interface
 * @export
 */
export const MicrodepositsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MicrodepositsApiFp(configuration)
    return {
        /**
         * Use this endpoint to create or pre-initiate a microdeposit. The response will include the new microdeposit record with a status of `INITIATED` or `PREINITIATED` respectively.  To pre-initiate a microdeposit, you only need to set `email` (string), `first_name` (string), and `last_name` (string) in the request body.   Pre-initiating a microdeposit allows you to pass the end user\'s first name, last name, and email if this data has already been collected. If the end user selects an institution which requires the microdeposit flow, the pre-initiated `micro_deposit` will be used and the Connect Widget step that normally requests this info from the end user will be skipped. However, if the end user selects an institution which supports IAV, the pre-initiated `micro_deposit` will be deleted and IAV will be used instead. When requesting a Connect Widget URL after pre-initiating, make sure to set the `current_microdeposit_guid` to the resulting microdeposit\'s `guid` and set the `mode` to `verification`. If you use this enhanced flow, a `micro_deposit` should be pre-initiated for all connect sessions in verification mode. After pre-initiating a microdeposit, pass the GUID to the config as `current_microdeposit_guid` and set the `mode` to `verification` when requesting a Connect URL.  Pre-initiating a microdeposit is optional. If you choose to implement this flow, it should be used for all Connect Widget sessions in verification mode. 
         * @summary Create or pre-initiate a microdeposit
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MicrodepositRequestBody} microdepositRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMicrodeposit(userGuid: string, microdepositRequestBody: MicrodepositRequestBody, options?: any): AxiosPromise<MicrodepositResponseBody> {
            return localVarFp.createMicrodeposit(userGuid, microdepositRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete the specified microdeposit.
         * @summary Delete a microdeposit
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMicrodeposit(microDepositGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMicrodeposit(microDepositGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID.
         * @summary List all microdeposits for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserMicrodeposits(userGuid: string, options?: any): AxiosPromise<MicrodepositsResponseBody> {
            return localVarFp.listUserMicrodeposits(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of the account verifications associated with the user, as well as the status of those verifications. 
         * @summary List all verifications for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserVerifications(userGuid: string, options?: any): AxiosPromise<MicrodepositResponseBody> {
            return localVarFp.listUserVerifications(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID. <br /><br /> Webhooks for microdeposit status changes are triggered when a status changes. The actual status of the microdeposit guid updates every minute. You may force a status update by calling the read microdeposit endpoint.
         * @summary Read a microdeposit for a user
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMicrodeposit(microDepositGuid: string, userGuid: string, options?: any): AxiosPromise<MicrodepositResponseBody> {
            return localVarFp.readUserMicrodeposit(microDepositGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to verify the amounts deposited into the account during a microdeposit verification. The verification has not successfully completed until the `status` is `VERIFIED`. Poll the `/users/{user_guid}/micro_deposits/{micro_deposit_guid}` (read microdeposit) endpoint until you see this status or an error state.
         * @summary Verify a Microdeposit
         * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
         * @param {MicrodepositVerifyRequestBody} [microdepositVerifyRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMicrodeposit(microDepositGuid: string, microdepositVerifyRequestBody?: MicrodepositVerifyRequestBody, options?: any): AxiosPromise<MicrodepositResponseBody> {
            return localVarFp.verifyMicrodeposit(microDepositGuid, microdepositVerifyRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MicrodepositsApi - object-oriented interface
 * @export
 * @class MicrodepositsApi
 * @extends {BaseAPI}
 */
export class MicrodepositsApi extends BaseAPI {
    /**
     * Use this endpoint to create or pre-initiate a microdeposit. The response will include the new microdeposit record with a status of `INITIATED` or `PREINITIATED` respectively.  To pre-initiate a microdeposit, you only need to set `email` (string), `first_name` (string), and `last_name` (string) in the request body.   Pre-initiating a microdeposit allows you to pass the end user\'s first name, last name, and email if this data has already been collected. If the end user selects an institution which requires the microdeposit flow, the pre-initiated `micro_deposit` will be used and the Connect Widget step that normally requests this info from the end user will be skipped. However, if the end user selects an institution which supports IAV, the pre-initiated `micro_deposit` will be deleted and IAV will be used instead. When requesting a Connect Widget URL after pre-initiating, make sure to set the `current_microdeposit_guid` to the resulting microdeposit\'s `guid` and set the `mode` to `verification`. If you use this enhanced flow, a `micro_deposit` should be pre-initiated for all connect sessions in verification mode. After pre-initiating a microdeposit, pass the GUID to the config as `current_microdeposit_guid` and set the `mode` to `verification` when requesting a Connect URL.  Pre-initiating a microdeposit is optional. If you choose to implement this flow, it should be used for all Connect Widget sessions in verification mode. 
     * @summary Create or pre-initiate a microdeposit
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {MicrodepositRequestBody} microdepositRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodepositsApi
     */
    public createMicrodeposit(userGuid: string, microdepositRequestBody: MicrodepositRequestBody, options?: AxiosRequestConfig) {
        return MicrodepositsApiFp(this.configuration).createMicrodeposit(userGuid, microdepositRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete the specified microdeposit.
     * @summary Delete a microdeposit
     * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodepositsApi
     */
    public deleteMicrodeposit(microDepositGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MicrodepositsApiFp(this.configuration).deleteMicrodeposit(microDepositGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID.
     * @summary List all microdeposits for a user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodepositsApi
     */
    public listUserMicrodeposits(userGuid: string, options?: AxiosRequestConfig) {
        return MicrodepositsApiFp(this.configuration).listUserMicrodeposits(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of the account verifications associated with the user, as well as the status of those verifications. 
     * @summary List all verifications for a user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodepositsApi
     */
    public listUserVerifications(userGuid: string, options?: AxiosRequestConfig) {
        return MicrodepositsApiFp(this.configuration).listUserVerifications(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID. <br /><br /> Webhooks for microdeposit status changes are triggered when a status changes. The actual status of the microdeposit guid updates every minute. You may force a status update by calling the read microdeposit endpoint.
     * @summary Read a microdeposit for a user
     * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodepositsApi
     */
    public readUserMicrodeposit(microDepositGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return MicrodepositsApiFp(this.configuration).readUserMicrodeposit(microDepositGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to verify the amounts deposited into the account during a microdeposit verification. The verification has not successfully completed until the `status` is `VERIFIED`. Poll the `/users/{user_guid}/micro_deposits/{micro_deposit_guid}` (read microdeposit) endpoint until you see this status or an error state.
     * @summary Verify a Microdeposit
     * @param {string} microDepositGuid The unique identifier for the microdeposit. Defined by MX.
     * @param {MicrodepositVerifyRequestBody} [microdepositVerifyRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodepositsApi
     */
    public verifyMicrodeposit(microDepositGuid: string, microdepositVerifyRequestBody?: MicrodepositVerifyRequestBody, options?: AxiosRequestConfig) {
        return MicrodepositsApiFp(this.configuration).verifyMicrodeposit(microDepositGuid, microdepositVerifyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MonthlyCashFlowProfileApi - axios parameter creator
 * @export
 */
export const MonthlyCashFlowProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read monthly cash flow profile.
         * @summary Read monthly cash flow profile
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMonthlyCashFlowProfile: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readMonthlyCashFlowProfile', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/monthly_cash_flow_profile`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of a `monthly_cash_flow_profile`.
         * @summary Update monthly cash flow profile
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MonthlyCashFlowProfileRequestBody} monthlyCashFlowProfileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMonthlyCashFlowProfile: async (userGuid: string, monthlyCashFlowProfileRequestBody: MonthlyCashFlowProfileRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateMonthlyCashFlowProfile', 'userGuid', userGuid)
            // verify required parameter 'monthlyCashFlowProfileRequestBody' is not null or undefined
            assertParamExists('updateMonthlyCashFlowProfile', 'monthlyCashFlowProfileRequestBody', monthlyCashFlowProfileRequestBody)
            const localVarPath = `/users/{user_guid}/monthly_cash_flow_profile`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(monthlyCashFlowProfileRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonthlyCashFlowProfileApi - functional programming interface
 * @export
 */
export const MonthlyCashFlowProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonthlyCashFlowProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Read monthly cash flow profile.
         * @summary Read monthly cash flow profile
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMonthlyCashFlowProfile(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyCashFlowResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMonthlyCashFlowProfile(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of a `monthly_cash_flow_profile`.
         * @summary Update monthly cash flow profile
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MonthlyCashFlowProfileRequestBody} monthlyCashFlowProfileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMonthlyCashFlowProfile(userGuid: string, monthlyCashFlowProfileRequestBody: MonthlyCashFlowProfileRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonthlyCashFlowResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMonthlyCashFlowProfile(userGuid, monthlyCashFlowProfileRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonthlyCashFlowProfileApi - factory interface
 * @export
 */
export const MonthlyCashFlowProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonthlyCashFlowProfileApiFp(configuration)
    return {
        /**
         * Read monthly cash flow profile.
         * @summary Read monthly cash flow profile
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMonthlyCashFlowProfile(userGuid: string, options?: any): AxiosPromise<MonthlyCashFlowResponseBody> {
            return localVarFp.readMonthlyCashFlowProfile(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of a `monthly_cash_flow_profile`.
         * @summary Update monthly cash flow profile
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {MonthlyCashFlowProfileRequestBody} monthlyCashFlowProfileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMonthlyCashFlowProfile(userGuid: string, monthlyCashFlowProfileRequestBody: MonthlyCashFlowProfileRequestBody, options?: any): AxiosPromise<MonthlyCashFlowResponseBody> {
            return localVarFp.updateMonthlyCashFlowProfile(userGuid, monthlyCashFlowProfileRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonthlyCashFlowProfileApi - object-oriented interface
 * @export
 * @class MonthlyCashFlowProfileApi
 * @extends {BaseAPI}
 */
export class MonthlyCashFlowProfileApi extends BaseAPI {
    /**
     * Read monthly cash flow profile.
     * @summary Read monthly cash flow profile
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonthlyCashFlowProfileApi
     */
    public readMonthlyCashFlowProfile(userGuid: string, options?: AxiosRequestConfig) {
        return MonthlyCashFlowProfileApiFp(this.configuration).readMonthlyCashFlowProfile(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of a `monthly_cash_flow_profile`.
     * @summary Update monthly cash flow profile
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {MonthlyCashFlowProfileRequestBody} monthlyCashFlowProfileRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonthlyCashFlowProfileApi
     */
    public updateMonthlyCashFlowProfile(userGuid: string, monthlyCashFlowProfileRequestBody: MonthlyCashFlowProfileRequestBody, options?: AxiosRequestConfig) {
        return MonthlyCashFlowProfileApiFp(this.configuration).updateMonthlyCashFlowProfile(userGuid, monthlyCashFlowProfileRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All notifications created through the API will be of notification type `API_NOTIFICATION`, channel `PUSH`, and will not be associated to an entity.  No other channels are supported.  This will only have an effect for clients using an MX mobile application.
         * @summary Create a notification
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} content The information related to the notification.
         * @param {string} subject The subject related to the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (userGuid: string, content: string, subject: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createNotification', 'userGuid', userGuid)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('createNotification', 'content', content)
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('createNotification', 'subject', subject)
            const localVarPath = `/users/{user_guid}/notifications`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All notifications for the user can be listed, including notifications created by MX for other channels besides `PUSH`.
         * @summary List notifications
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotifications: async (userGuid: string, fromDate?: string, toDate?: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listNotifications', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/notifications`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can pull up any notification associated with the user, including notifications created by MX for other channels besides `PUSH`. 
         * @summary Read notifications
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} notificationGuid The unique identifier for notifications. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNotifications: async (userGuid: string, notificationGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readNotifications', 'userGuid', userGuid)
            // verify required parameter 'notificationGuid' is not null or undefined
            assertParamExists('readNotifications', 'notificationGuid', notificationGuid)
            const localVarPath = `/users/{user_guid}/notifications/{notification_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"notification_guid"}}`, encodeURIComponent(String(notificationGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * All notifications created through the API will be of notification type `API_NOTIFICATION`, channel `PUSH`, and will not be associated to an entity.  No other channels are supported.  This will only have an effect for clients using an MX mobile application.
         * @summary Create a notification
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} content The information related to the notification.
         * @param {string} subject The subject related to the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(userGuid: string, content: string, subject: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(userGuid, content, subject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All notifications for the user can be listed, including notifications created by MX for other channels besides `PUSH`.
         * @summary List notifications
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotifications(userGuid: string, fromDate?: string, toDate?: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotifications(userGuid, fromDate, toDate, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can pull up any notification associated with the user, including notifications created by MX for other channels besides `PUSH`. 
         * @summary Read notifications
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} notificationGuid The unique identifier for notifications. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readNotifications(userGuid: string, notificationGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readNotifications(userGuid, notificationGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * All notifications created through the API will be of notification type `API_NOTIFICATION`, channel `PUSH`, and will not be associated to an entity.  No other channels are supported.  This will only have an effect for clients using an MX mobile application.
         * @summary Create a notification
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} content The information related to the notification.
         * @param {string} subject The subject related to the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(userGuid: string, content: string, subject: string, options?: any): AxiosPromise<NotificationResponseBody> {
            return localVarFp.createNotification(userGuid, content, subject, options).then((request) => request(axios, basePath));
        },
        /**
         * All notifications for the user can be listed, including notifications created by MX for other channels besides `PUSH`.
         * @summary List notifications
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotifications(userGuid: string, fromDate?: string, toDate?: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<NotificationsResponseBody> {
            return localVarFp.listNotifications(userGuid, fromDate, toDate, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Can pull up any notification associated with the user, including notifications created by MX for other channels besides `PUSH`. 
         * @summary Read notifications
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} notificationGuid The unique identifier for notifications. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNotifications(userGuid: string, notificationGuid: string, options?: any): AxiosPromise<NotificationResponseBody> {
            return localVarFp.readNotifications(userGuid, notificationGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * All notifications created through the API will be of notification type `API_NOTIFICATION`, channel `PUSH`, and will not be associated to an entity.  No other channels are supported.  This will only have an effect for clients using an MX mobile application.
     * @summary Create a notification
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} content The information related to the notification.
     * @param {string} subject The subject related to the notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createNotification(userGuid: string, content: string, subject: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).createNotification(userGuid, content, subject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All notifications for the user can be listed, including notifications created by MX for other channels besides `PUSH`.
     * @summary List notifications
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
     * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public listNotifications(userGuid: string, fromDate?: string, toDate?: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).listNotifications(userGuid, fromDate, toDate, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can pull up any notification associated with the user, including notifications created by MX for other channels besides `PUSH`. 
     * @summary Read notifications
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} notificationGuid The unique identifier for notifications. Defined by MX.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public readNotifications(userGuid: string, notificationGuid: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).readNotifications(userGuid, notificationGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProcessorTokenApi - axios parameter creator
 * @export
 */
export const ProcessorTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check the real-time account balance using your access token.
         * @summary Check Real Time Account Balance (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkRealTimeAccountBalance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/check_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (This endpoint is deprecated. Clients should use `/authorization_code`.) Clients use this endpoint to request an authorization_code according to a user, member, and account specified in the request body. Clients then pass this code to processors. Processor access is scoped only to the user/member/account specified in this request. Before requesting an authorization_code, clients must have verified the specified member.
         * @summary (Deprecated) Request an authorization code
         * @param {PaymentProcessorAuthorizationCodeRequestBody} paymentProcessorAuthorizationCodeRequestBody The scope for the authorization code.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deprecatedRequestPaymentProcessorAuthorizationCode: async (paymentProcessorAuthorizationCodeRequestBody: PaymentProcessorAuthorizationCodeRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentProcessorAuthorizationCodeRequestBody' is not null or undefined
            assertParamExists('deprecatedRequestPaymentProcessorAuthorizationCode', 'paymentProcessorAuthorizationCodeRequestBody', paymentProcessorAuthorizationCodeRequestBody)
            const localVarPath = `/payment_processor_authorization_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentProcessorAuthorizationCodeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account owner information (Processors Only)
         * @summary Get account owner information (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountOwnerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View a list of tokens that exist for a user, member, or account.
         * @summary View a List of Tokens
         * @param {TokenRequestBody} [tokenRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (tokenRequestBody?: TokenRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the account balance (Processors Only)
         * @summary Read the account balance (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAccountBalance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account information such as routing number and account number, scoped to your access token.
         * @summary Request an account number (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAccountNumber: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/account_numbers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients use this endpoint to request an authorization code according to the parameters specified in the scope. Clients then pass this code to processors. Processor access is scoped only to the GUIDs and features specified in this request. Before requesting an authorization code which includes a member in the scope, clients must have verified that member.
         * @summary Request an authorization code
         * @param {AuthorizationCodeRequestBody} authorizationCodeRequestBody The scope for the authorization code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthorizationCode: async (authorizationCodeRequestBody: AuthorizationCodeRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationCodeRequestBody' is not null or undefined
            assertParamExists('requestAuthorizationCode', 'authorizationCodeRequestBody', authorizationCodeRequestBody)
            const localVarPath = `/authorization_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationCodeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessorTokenApi - functional programming interface
 * @export
 */
export const ProcessorTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessorTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Check the real-time account balance using your access token.
         * @summary Check Real Time Account Balance (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkRealTimeAccountBalance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkRealTimeAccountBalance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (This endpoint is deprecated. Clients should use `/authorization_code`.) Clients use this endpoint to request an authorization_code according to a user, member, and account specified in the request body. Clients then pass this code to processors. Processor access is scoped only to the user/member/account specified in this request. Before requesting an authorization_code, clients must have verified the specified member.
         * @summary (Deprecated) Request an authorization code
         * @param {PaymentProcessorAuthorizationCodeRequestBody} paymentProcessorAuthorizationCodeRequestBody The scope for the authorization code.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deprecatedRequestPaymentProcessorAuthorizationCode(paymentProcessorAuthorizationCodeRequestBody: PaymentProcessorAuthorizationCodeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentProcessorAuthorizationCodeResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deprecatedRequestPaymentProcessorAuthorizationCode(paymentProcessorAuthorizationCodeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get account owner information (Processors Only)
         * @summary Get account owner information (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountOwnerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorOwnerBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountOwnerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View a list of tokens that exist for a user, member, or account.
         * @summary View a List of Tokens
         * @param {TokenRequestBody} [tokenRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(tokenRequestBody?: TokenRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(tokenRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read the account balance (Processors Only)
         * @summary Read the account balance (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAccountBalance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentAccountBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAccountBalance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get account information such as routing number and account number, scoped to your access token.
         * @summary Request an account number (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestAccountNumber(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorAccountNumberBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestAccountNumber(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clients use this endpoint to request an authorization code according to the parameters specified in the scope. Clients then pass this code to processors. Processor access is scoped only to the GUIDs and features specified in this request. Before requesting an authorization code which includes a member in the scope, clients must have verified that member.
         * @summary Request an authorization code
         * @param {AuthorizationCodeRequestBody} authorizationCodeRequestBody The scope for the authorization code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestAuthorizationCode(authorizationCodeRequestBody: AuthorizationCodeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationCodeResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestAuthorizationCode(authorizationCodeRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessorTokenApi - factory interface
 * @export
 */
export const ProcessorTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessorTokenApiFp(configuration)
    return {
        /**
         * Check the real-time account balance using your access token.
         * @summary Check Real Time Account Balance (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkRealTimeAccountBalance(options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.checkRealTimeAccountBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * (This endpoint is deprecated. Clients should use `/authorization_code`.) Clients use this endpoint to request an authorization_code according to a user, member, and account specified in the request body. Clients then pass this code to processors. Processor access is scoped only to the user/member/account specified in this request. Before requesting an authorization_code, clients must have verified the specified member.
         * @summary (Deprecated) Request an authorization code
         * @param {PaymentProcessorAuthorizationCodeRequestBody} paymentProcessorAuthorizationCodeRequestBody The scope for the authorization code.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deprecatedRequestPaymentProcessorAuthorizationCode(paymentProcessorAuthorizationCodeRequestBody: PaymentProcessorAuthorizationCodeRequestBody, options?: any): AxiosPromise<PaymentProcessorAuthorizationCodeResponseBody> {
            return localVarFp.deprecatedRequestPaymentProcessorAuthorizationCode(paymentProcessorAuthorizationCodeRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account owner information (Processors Only)
         * @summary Get account owner information (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountOwnerInfo(options?: any): AxiosPromise<ProcessorOwnerBody> {
            return localVarFp.getAccountOwnerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * View a list of tokens that exist for a user, member, or account.
         * @summary View a List of Tokens
         * @param {TokenRequestBody} [tokenRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(tokenRequestBody?: TokenRequestBody, options?: any): AxiosPromise<TokenResponseBody> {
            return localVarFp.listTokens(tokenRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the account balance (Processors Only)
         * @summary Read the account balance (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAccountBalance(options?: any): AxiosPromise<PaymentAccountBody> {
            return localVarFp.readAccountBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * Get account information such as routing number and account number, scoped to your access token.
         * @summary Request an account number (Processors Only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAccountNumber(options?: any): AxiosPromise<ProcessorAccountNumberBody> {
            return localVarFp.requestAccountNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * Clients use this endpoint to request an authorization code according to the parameters specified in the scope. Clients then pass this code to processors. Processor access is scoped only to the GUIDs and features specified in this request. Before requesting an authorization code which includes a member in the scope, clients must have verified that member.
         * @summary Request an authorization code
         * @param {AuthorizationCodeRequestBody} authorizationCodeRequestBody The scope for the authorization code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthorizationCode(authorizationCodeRequestBody: AuthorizationCodeRequestBody, options?: any): AxiosPromise<AuthorizationCodeResponseBody> {
            return localVarFp.requestAuthorizationCode(authorizationCodeRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessorTokenApi - object-oriented interface
 * @export
 * @class ProcessorTokenApi
 * @extends {BaseAPI}
 */
export class ProcessorTokenApi extends BaseAPI {
    /**
     * Check the real-time account balance using your access token.
     * @summary Check Real Time Account Balance (Processors Only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public checkRealTimeAccountBalance(options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).checkRealTimeAccountBalance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (This endpoint is deprecated. Clients should use `/authorization_code`.) Clients use this endpoint to request an authorization_code according to a user, member, and account specified in the request body. Clients then pass this code to processors. Processor access is scoped only to the user/member/account specified in this request. Before requesting an authorization_code, clients must have verified the specified member.
     * @summary (Deprecated) Request an authorization code
     * @param {PaymentProcessorAuthorizationCodeRequestBody} paymentProcessorAuthorizationCodeRequestBody The scope for the authorization code.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public deprecatedRequestPaymentProcessorAuthorizationCode(paymentProcessorAuthorizationCodeRequestBody: PaymentProcessorAuthorizationCodeRequestBody, options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).deprecatedRequestPaymentProcessorAuthorizationCode(paymentProcessorAuthorizationCodeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account owner information (Processors Only)
     * @summary Get account owner information (Processors Only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public getAccountOwnerInfo(options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).getAccountOwnerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View a list of tokens that exist for a user, member, or account.
     * @summary View a List of Tokens
     * @param {TokenRequestBody} [tokenRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public listTokens(tokenRequestBody?: TokenRequestBody, options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).listTokens(tokenRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the account balance (Processors Only)
     * @summary Read the account balance (Processors Only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public readAccountBalance(options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).readAccountBalance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account information such as routing number and account number, scoped to your access token.
     * @summary Request an account number (Processors Only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public requestAccountNumber(options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).requestAccountNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clients use this endpoint to request an authorization code according to the parameters specified in the scope. Clients then pass this code to processors. Processor access is scoped only to the GUIDs and features specified in this request. Before requesting an authorization code which includes a member in the scope, clients must have verified that member.
     * @summary Request an authorization code
     * @param {AuthorizationCodeRequestBody} authorizationCodeRequestBody The scope for the authorization code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorTokenApi
     */
    public requestAuthorizationCode(authorizationCodeRequestBody: AuthorizationCodeRequestBody, options?: AxiosRequestConfig) {
        return ProcessorTokenApiFp(this.configuration).requestAuthorizationCode(authorizationCodeRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewardsApi - axios parameter creator
 * @export
 */
export const RewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the specified `credit_card_product` according to the unique GUID.
         * @summary Read a Credit Card Product
         * @param {string} creditCardProductGuid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCard: async (creditCardProductGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditCardProductGuid' is not null or undefined
            assertParamExists('creditCard', 'creditCardProductGuid', creditCardProductGuid)
            const localVarPath = `/credit_card_products/{credit_card_product_guid}`
                .replace(`{${"credit_card_product_guid"}}`, encodeURIComponent(String(creditCardProductGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calling this endpoint initiates an aggregation-type event which will gather the member\'s rewards information, as well as account and transaction information. Rewards data is also gathered with daily background aggregations. Member and Rewards guids are defined by MX.
         * @summary Fetch Rewards
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRewards: async (userGuid: string, memberGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('fetchRewards', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('fetchRewards', 'memberGuid', memberGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/fetch_rewards`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the `rewards` associated with a specified `member`. Member guids are defined by MX.
         * @summary List Rewards
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards: async (userGuid: string, memberGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listRewards', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listRewards', 'memberGuid', memberGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/rewards`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read a specific `reward` based on its unique GUID. Member and Rewards guids are defined by MX.
         * @summary Read Reward
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} rewardGuid The unique identifier for the rewards. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRewards: async (userGuid: string, memberGuid: string, rewardGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readRewards', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readRewards', 'memberGuid', memberGuid)
            // verify required parameter 'rewardGuid' is not null or undefined
            assertParamExists('readRewards', 'rewardGuid', rewardGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/rewards/{reward_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"reward_guid"}}`, encodeURIComponent(String(rewardGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardsApi - functional programming interface
 * @export
 */
export const RewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the specified `credit_card_product` according to the unique GUID.
         * @summary Read a Credit Card Product
         * @param {string} creditCardProductGuid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditCard(creditCardProductGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCardProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditCard(creditCardProductGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calling this endpoint initiates an aggregation-type event which will gather the member\'s rewards information, as well as account and transaction information. Rewards data is also gathered with daily background aggregations. Member and Rewards guids are defined by MX.
         * @summary Fetch Rewards
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRewards(userGuid: string, memberGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRewards(userGuid, memberGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the `rewards` associated with a specified `member`. Member guids are defined by MX.
         * @summary List Rewards
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRewards(userGuid: string, memberGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewardsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRewards(userGuid, memberGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read a specific `reward` based on its unique GUID. Member and Rewards guids are defined by MX.
         * @summary Read Reward
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} rewardGuid The unique identifier for the rewards. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readRewards(userGuid: string, memberGuid: string, rewardGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewardResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readRewards(userGuid, memberGuid, rewardGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RewardsApi - factory interface
 * @export
 */
export const RewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewardsApiFp(configuration)
    return {
        /**
         * This endpoint returns the specified `credit_card_product` according to the unique GUID.
         * @summary Read a Credit Card Product
         * @param {string} creditCardProductGuid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditCard(creditCardProductGuid: string, options?: any): AxiosPromise<CreditCardProductResponse> {
            return localVarFp.creditCard(creditCardProductGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Calling this endpoint initiates an aggregation-type event which will gather the member\'s rewards information, as well as account and transaction information. Rewards data is also gathered with daily background aggregations. Member and Rewards guids are defined by MX.
         * @summary Fetch Rewards
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRewards(userGuid: string, memberGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.fetchRewards(userGuid, memberGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the `rewards` associated with a specified `member`. Member guids are defined by MX.
         * @summary List Rewards
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards(userGuid: string, memberGuid: string, options?: any): AxiosPromise<RewardsResponseBody> {
            return localVarFp.listRewards(userGuid, memberGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read a specific `reward` based on its unique GUID. Member and Rewards guids are defined by MX.
         * @summary Read Reward
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} rewardGuid The unique identifier for the rewards. Defined by MX.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readRewards(userGuid: string, memberGuid: string, rewardGuid: string, options?: any): AxiosPromise<RewardResponseBody> {
            return localVarFp.readRewards(userGuid, memberGuid, rewardGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardsApi - object-oriented interface
 * @export
 * @class RewardsApi
 * @extends {BaseAPI}
 */
export class RewardsApi extends BaseAPI {
    /**
     * This endpoint returns the specified `credit_card_product` according to the unique GUID.
     * @summary Read a Credit Card Product
     * @param {string} creditCardProductGuid The required &#x60;credit_card_product_guid&#x60; can be found on the &#x60;account&#x60; object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public creditCard(creditCardProductGuid: string, options?: AxiosRequestConfig) {
        return RewardsApiFp(this.configuration).creditCard(creditCardProductGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calling this endpoint initiates an aggregation-type event which will gather the member\'s rewards information, as well as account and transaction information. Rewards data is also gathered with daily background aggregations. Member and Rewards guids are defined by MX.
     * @summary Fetch Rewards
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public fetchRewards(userGuid: string, memberGuid: string, options?: AxiosRequestConfig) {
        return RewardsApiFp(this.configuration).fetchRewards(userGuid, memberGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the `rewards` associated with a specified `member`. Member guids are defined by MX.
     * @summary List Rewards
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public listRewards(userGuid: string, memberGuid: string, options?: AxiosRequestConfig) {
        return RewardsApiFp(this.configuration).listRewards(userGuid, memberGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read a specific `reward` based on its unique GUID. Member and Rewards guids are defined by MX.
     * @summary Read Reward
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} rewardGuid The unique identifier for the rewards. Defined by MX.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public readRewards(userGuid: string, memberGuid: string, rewardGuid: string, options?: AxiosRequestConfig) {
        return RewardsApiFp(this.configuration).readRewards(userGuid, memberGuid, rewardGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpendingPlanApi - axios parameter creator
 * @export
 */
export const SpendingPlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates a new `spending_plan` for the user.
         * @summary Create spending plan
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpendingPlan: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createSpendingPlan', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/spending_plans`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates a new `spending_plan_iteration_item`.
         * @summary Create spending plan iteration item
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be created with required parameter (planned_amount)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpendingPlanIterationItem: async (spendingPlanGuid: string, userGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('createSpendingPlanIterationItem', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createSpendingPlanIterationItem', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanIterationItemCreateRequestBody' is not null or undefined
            assertParamExists('createSpendingPlanIterationItem', 'spendingPlanIterationItemCreateRequestBody', spendingPlanIterationItemCreateRequestBody)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/current/iteration_items`
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spendingPlanIterationItemCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a user\'s `spending_plan`.
         * @summary Delete spending plan
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpendingPlan: async (userGuid: string, spendingPlanGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteSpendingPlan', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('deleteSpendingPlan', 'spendingPlanGuid', spendingPlanGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a `spending_plan_account`.
         * @summary Delete spending plan account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpendingPlanAccount: async (userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteSpendingPlanAccount', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('deleteSpendingPlanAccount', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'spendingPlanAccountGuid' is not null or undefined
            assertParamExists('deleteSpendingPlanAccount', 'spendingPlanAccountGuid', spendingPlanAccountGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/spending_plan_accounts/{spending_plan_account_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"spending_plan_account_guid"}}`, encodeURIComponent(String(spendingPlanAccountGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a spending plan `iteration_item`.
         * @summary Delete spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpendingPlanIterationItem: async (userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteSpendingPlanIterationItem', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('deleteSpendingPlanIterationItem', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'iterationItemGuid' is not null or undefined
            assertParamExists('deleteSpendingPlanIterationItem', 'iterationItemGuid', iterationItemGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/current/iteration_items/{iteration_item_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"iteration_item_guid"}}`, encodeURIComponent(String(iterationItemGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the spending plan accounts associated with the spending plan.
         * @summary List spending plan accounts
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlanAccounts: async (userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listSpendingPlanAccounts', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('listSpendingPlanAccounts', 'spendingPlanGuid', spendingPlanGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/spending_plan_accounts`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the spending plan `iteration_items` associated with the `iteration`.
         * @summary List spending plan iteration items
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlanIterationItems: async (userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listSpendingPlanIterationItems', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('listSpendingPlanIterationItems', 'spendingPlanGuid', spendingPlanGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/current/iteration_items`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the spending plan `iterations` associated with the `spending_plan`.
         * @summary List spending plan iterations
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlanIterations: async (userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listSpendingPlanIterations', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('listSpendingPlanIterations', 'spendingPlanGuid', spendingPlanGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all the spending plans associated with the user.
         * @summary List spending plans
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlans: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listSpendingPlans', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/spending_plans`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of the current spending plan `iteration`.
         * @summary Read current spending plan iteration
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCurrentSpendingPlanIteration: async (userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readCurrentSpendingPlanIteration', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('readCurrentSpendingPlanIteration', 'spendingPlanGuid', spendingPlanGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/current`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan account according to its unique GUID.
         * @summary Read spending plan account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanAccount: async (userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readSpendingPlanAccount', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('readSpendingPlanAccount', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'spendingPlanAccountGuid' is not null or undefined
            assertParamExists('readSpendingPlanAccount', 'spendingPlanAccountGuid', spendingPlanAccountGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/spending_plan_accounts/{spending_plan_account_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"spending_plan_account_guid"}}`, encodeURIComponent(String(spendingPlanAccountGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan `iteration` according to its `iteration_number`.
         * @summary Read a spending plan iteration
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} iterationNumber The current iteration number for the spending plan &#x60;iteration&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanIteration: async (userGuid: string, spendingPlanGuid: string, iterationNumber: number, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readSpendingPlanIteration', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('readSpendingPlanIteration', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'iterationNumber' is not null or undefined
            assertParamExists('readSpendingPlanIteration', 'iterationNumber', iterationNumber)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/{iteration_number}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"iteration_number"}}`, encodeURIComponent(String(iterationNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan `iteration_item` according to its unique GUID.
         * @summary Read a spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanIterationItem: async (userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readSpendingPlanIterationItem', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('readSpendingPlanIterationItem', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'iterationItemGuid' is not null or undefined
            assertParamExists('readSpendingPlanIterationItem', 'iterationItemGuid', iterationItemGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/current/iteration_items/{iteration_item_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"iteration_item_guid"}}`, encodeURIComponent(String(iterationItemGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan according to its unique GUID.
         * @summary Read a spending plan for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanUser: async (userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readSpendingPlanUser', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('readSpendingPlanUser', 'spendingPlanGuid', spendingPlanGuid)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update an existing `spending_plan_iteration_item`.
         * @summary Update a spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be updated with required parameter (planned_amount)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpendingPlanIterationItem: async (userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateSpendingPlanIterationItem', 'userGuid', userGuid)
            // verify required parameter 'spendingPlanGuid' is not null or undefined
            assertParamExists('updateSpendingPlanIterationItem', 'spendingPlanGuid', spendingPlanGuid)
            // verify required parameter 'iterationItemGuid' is not null or undefined
            assertParamExists('updateSpendingPlanIterationItem', 'iterationItemGuid', iterationItemGuid)
            // verify required parameter 'spendingPlanIterationItemCreateRequestBody' is not null or undefined
            assertParamExists('updateSpendingPlanIterationItem', 'spendingPlanIterationItemCreateRequestBody', spendingPlanIterationItemCreateRequestBody)
            const localVarPath = `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/current/iteration_items/{iteration_item_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"spending_plan_guid"}}`, encodeURIComponent(String(spendingPlanGuid)))
                .replace(`{${"iteration_item_guid"}}`, encodeURIComponent(String(iterationItemGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spendingPlanIterationItemCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpendingPlanApi - functional programming interface
 * @export
 */
export const SpendingPlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpendingPlanApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates a new `spending_plan` for the user.
         * @summary Create spending plan
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpendingPlan(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSpendingPlan(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint creates a new `spending_plan_iteration_item`.
         * @summary Create spending plan iteration item
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be created with required parameter (planned_amount)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpendingPlanIterationItem(spendingPlanGuid: string, userGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSpendingPlanIterationItem(spendingPlanGuid, userGuid, spendingPlanIterationItemCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a user\'s `spending_plan`.
         * @summary Delete spending plan
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpendingPlan(userGuid: string, spendingPlanGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpendingPlan(userGuid, spendingPlanGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a `spending_plan_account`.
         * @summary Delete spending plan account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpendingPlanAccount(userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpendingPlanAccount(userGuid, spendingPlanGuid, spendingPlanAccountGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a spending plan `iteration_item`.
         * @summary Delete spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the spending plan accounts associated with the spending plan.
         * @summary List spending plan accounts
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpendingPlanAccounts(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpendingPlanAccounts(userGuid, spendingPlanGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the spending plan `iteration_items` associated with the `iteration`.
         * @summary List spending plan iteration items
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpendingPlanIterationItems(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationItemsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpendingPlanIterationItems(userGuid, spendingPlanGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the spending plan `iterations` associated with the `spending_plan`.
         * @summary List spending plan iterations
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpendingPlanIterations(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpendingPlanIterations(userGuid, spendingPlanGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all the spending plans associated with the user.
         * @summary List spending plans
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpendingPlans(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlansResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpendingPlans(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of the current spending plan `iteration`.
         * @summary Read current spending plan iteration
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCurrentSpendingPlanIteration(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCurrentSpendingPlanIteration(userGuid, spendingPlanGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan account according to its unique GUID.
         * @summary Read spending plan account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSpendingPlanAccount(userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSpendingPlanAccount(userGuid, spendingPlanGuid, spendingPlanAccountGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan `iteration` according to its `iteration_number`.
         * @summary Read a spending plan iteration
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} iterationNumber The current iteration number for the spending plan &#x60;iteration&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSpendingPlanIteration(userGuid: string, spendingPlanGuid: string, iterationNumber: number, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSpendingPlanIteration(userGuid, spendingPlanGuid, iterationNumber, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan `iteration_item` according to its unique GUID.
         * @summary Read a spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan according to its unique GUID.
         * @summary Read a spending plan for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSpendingPlanUser(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSpendingPlanUser(userGuid, spendingPlanGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update an existing `spending_plan_iteration_item`.
         * @summary Update a spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be updated with required parameter (planned_amount)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendingPlanIterationItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, spendingPlanIterationItemCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpendingPlanApi - factory interface
 * @export
 */
export const SpendingPlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpendingPlanApiFp(configuration)
    return {
        /**
         * This endpoint creates a new `spending_plan` for the user.
         * @summary Create spending plan
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpendingPlan(userGuid: string, options?: any): AxiosPromise<SpendingPlanResponse> {
            return localVarFp.createSpendingPlan(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates a new `spending_plan_iteration_item`.
         * @summary Create spending plan iteration item
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be created with required parameter (planned_amount)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpendingPlanIterationItem(spendingPlanGuid: string, userGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options?: any): AxiosPromise<SpendingPlanIterationItemResponse> {
            return localVarFp.createSpendingPlanIterationItem(spendingPlanGuid, userGuid, spendingPlanIterationItemCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a user\'s `spending_plan`.
         * @summary Delete spending plan
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpendingPlan(userGuid: string, spendingPlanGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSpendingPlan(userGuid, spendingPlanGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a `spending_plan_account`.
         * @summary Delete spending plan account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpendingPlanAccount(userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSpendingPlanAccount(userGuid, spendingPlanGuid, spendingPlanAccountGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a spending plan `iteration_item`.
         * @summary Delete spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the spending plan accounts associated with the spending plan.
         * @summary List spending plan accounts
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlanAccounts(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanAccountsResponse> {
            return localVarFp.listSpendingPlanAccounts(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the spending plan `iteration_items` associated with the `iteration`.
         * @summary List spending plan iteration items
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlanIterationItems(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanIterationItemsResponseBody> {
            return localVarFp.listSpendingPlanIterationItems(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the spending plan `iterations` associated with the `spending_plan`.
         * @summary List spending plan iterations
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlanIterations(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanIterationsResponse> {
            return localVarFp.listSpendingPlanIterations(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all the spending plans associated with the user.
         * @summary List spending plans
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpendingPlans(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlansResponseBody> {
            return localVarFp.listSpendingPlans(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of the current spending plan `iteration`.
         * @summary Read current spending plan iteration
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCurrentSpendingPlanIteration(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanIterationResponse> {
            return localVarFp.readCurrentSpendingPlanIteration(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan account according to its unique GUID.
         * @summary Read spending plan account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanAccount(userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanAccountResponse> {
            return localVarFp.readSpendingPlanAccount(userGuid, spendingPlanGuid, spendingPlanAccountGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan `iteration` according to its `iteration_number`.
         * @summary Read a spending plan iteration
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} iterationNumber The current iteration number for the spending plan &#x60;iteration&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanIteration(userGuid: string, spendingPlanGuid: string, iterationNumber: number, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanIterationResponse> {
            return localVarFp.readSpendingPlanIteration(userGuid, spendingPlanGuid, iterationNumber, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan `iteration_item` according to its unique GUID.
         * @summary Read a spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanIterationItemResponse> {
            return localVarFp.readSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific spending plan according to its unique GUID.
         * @summary Read a spending plan for a user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSpendingPlanUser(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<SpendingPlanResponse> {
            return localVarFp.readSpendingPlanUser(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update an existing `spending_plan_iteration_item`.
         * @summary Update a spending plan iteration item
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
         * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
         * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be updated with required parameter (planned_amount)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options?: any): AxiosPromise<SpendingPlanIterationItemResponse> {
            return localVarFp.updateSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, spendingPlanIterationItemCreateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpendingPlanApi - object-oriented interface
 * @export
 * @class SpendingPlanApi
 * @extends {BaseAPI}
 */
export class SpendingPlanApi extends BaseAPI {
    /**
     * This endpoint creates a new `spending_plan` for the user.
     * @summary Create spending plan
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public createSpendingPlan(userGuid: string, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).createSpendingPlan(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates a new `spending_plan_iteration_item`.
     * @summary Create spending plan iteration item
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be created with required parameter (planned_amount)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public createSpendingPlanIterationItem(spendingPlanGuid: string, userGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).createSpendingPlanIterationItem(spendingPlanGuid, userGuid, spendingPlanIterationItemCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a user\'s `spending_plan`.
     * @summary Delete spending plan
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public deleteSpendingPlan(userGuid: string, spendingPlanGuid: string, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).deleteSpendingPlan(userGuid, spendingPlanGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a `spending_plan_account`.
     * @summary Delete spending plan account
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public deleteSpendingPlanAccount(userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).deleteSpendingPlanAccount(userGuid, spendingPlanGuid, spendingPlanAccountGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a spending plan `iteration_item`.
     * @summary Delete spending plan iteration item
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public deleteSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).deleteSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the spending plan accounts associated with the spending plan.
     * @summary List spending plan accounts
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public listSpendingPlanAccounts(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).listSpendingPlanAccounts(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the spending plan `iteration_items` associated with the `iteration`.
     * @summary List spending plan iteration items
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public listSpendingPlanIterationItems(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).listSpendingPlanIterationItems(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the spending plan `iterations` associated with the `spending_plan`.
     * @summary List spending plan iterations
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public listSpendingPlanIterations(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).listSpendingPlanIterations(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all the spending plans associated with the user.
     * @summary List spending plans
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public listSpendingPlans(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).listSpendingPlans(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of the current spending plan `iteration`.
     * @summary Read current spending plan iteration
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public readCurrentSpendingPlanIteration(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).readCurrentSpendingPlanIteration(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific spending plan account according to its unique GUID.
     * @summary Read spending plan account
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {string} spendingPlanAccountGuid The unique ID for the specified account.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public readSpendingPlanAccount(userGuid: string, spendingPlanGuid: string, spendingPlanAccountGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).readSpendingPlanAccount(userGuid, spendingPlanGuid, spendingPlanAccountGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific spending plan `iteration` according to its `iteration_number`.
     * @summary Read a spending plan iteration
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {number} iterationNumber The current iteration number for the spending plan &#x60;iteration&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public readSpendingPlanIteration(userGuid: string, spendingPlanGuid: string, iterationNumber: number, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).readSpendingPlanIteration(userGuid, spendingPlanGuid, iterationNumber, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific spending plan `iteration_item` according to its unique GUID.
     * @summary Read a spending plan iteration item
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public readSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).readSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific spending plan according to its unique GUID.
     * @summary Read a spending plan for a user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public readSpendingPlanUser(userGuid: string, spendingPlanGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).readSpendingPlanUser(userGuid, spendingPlanGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update an existing `spending_plan_iteration_item`.
     * @summary Update a spending plan iteration item
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} spendingPlanGuid The unique ID for the &#x60;spending_plan&#x60;.
     * @param {string} iterationItemGuid The unique ID for the &#x60;iteration_item&#x60;.
     * @param {SpendingPlanIterationItemCreateRequestBody} spendingPlanIterationItemCreateRequestBody Iteration item to be updated with required parameter (planned_amount)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpendingPlanApi
     */
    public updateSpendingPlanIterationItem(userGuid: string, spendingPlanGuid: string, iterationItemGuid: string, spendingPlanIterationItemCreateRequestBody: SpendingPlanIterationItemCreateRequestBody, options?: AxiosRequestConfig) {
        return SpendingPlanApiFp(this.configuration).updateSpendingPlanIterationItem(userGuid, spendingPlanGuid, iterationItemGuid, spendingPlanIterationItemCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatementsApi - axios parameter creator
 * @export
 */
export const StatementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to download a specified statement PDF.
         * @summary Download statement pdf
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadStatementPDF: async (memberGuid: string, statementGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('downloadStatementPDF', 'memberGuid', memberGuid)
            // verify required parameter 'statementGuid' is not null or undefined
            assertParamExists('downloadStatementPDF', 'statementGuid', statementGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('downloadStatementPDF', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/statements/{statement_guid}.pdf`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"statement_guid"}}`, encodeURIComponent(String(statementGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to fetch the statements associated with a particular member.
         * @summary Fetch statements
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatements: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('fetchStatements', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('fetchStatements', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/fetch_statements`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get an array of available statements.
         * @summary List statements by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStatementsByMember: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listStatementsByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listStatementsByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/statements`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read a JSON representation of the statement.
         * @summary Read statement by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStatementByMember: async (memberGuid: string, statementGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('readStatementByMember', 'memberGuid', memberGuid)
            // verify required parameter 'statementGuid' is not null or undefined
            assertParamExists('readStatementByMember', 'statementGuid', statementGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readStatementByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/statements/{statement_guid}`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"statement_guid"}}`, encodeURIComponent(String(statementGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatementsApi - functional programming interface
 * @export
 */
export const StatementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to download a specified statement PDF.
         * @summary Download statement pdf
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadStatementPDF(memberGuid: string, statementGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadStatementPDF(memberGuid, statementGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to fetch the statements associated with a particular member.
         * @summary Fetch statements
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStatements(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStatements(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to get an array of available statements.
         * @summary List statements by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStatementsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStatementsByMember(memberGuid, userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read a JSON representation of the statement.
         * @summary Read statement by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStatementByMember(memberGuid: string, statementGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStatementByMember(memberGuid, statementGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatementsApi - factory interface
 * @export
 */
export const StatementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatementsApiFp(configuration)
    return {
        /**
         * Use this endpoint to download a specified statement PDF.
         * @summary Download statement pdf
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadStatementPDF(memberGuid: string, statementGuid: string, userGuid: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadStatementPDF(memberGuid, statementGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to fetch the statements associated with a particular member.
         * @summary Fetch statements
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStatements(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.fetchStatements(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get an array of available statements.
         * @summary List statements by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStatementsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<StatementsResponseBody> {
            return localVarFp.listStatementsByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read a JSON representation of the statement.
         * @summary Read statement by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStatementByMember(memberGuid: string, statementGuid: string, userGuid: string, options?: any): AxiosPromise<StatementResponseBody> {
            return localVarFp.readStatementByMember(memberGuid, statementGuid, userGuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatementsApi - object-oriented interface
 * @export
 * @class StatementsApi
 * @extends {BaseAPI}
 */
export class StatementsApi extends BaseAPI {
    /**
     * Use this endpoint to download a specified statement PDF.
     * @summary Download statement pdf
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementsApi
     */
    public downloadStatementPDF(memberGuid: string, statementGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return StatementsApiFp(this.configuration).downloadStatementPDF(memberGuid, statementGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to fetch the statements associated with a particular member.
     * @summary Fetch statements
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementsApi
     */
    public fetchStatements(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return StatementsApiFp(this.configuration).fetchStatements(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get an array of available statements.
     * @summary List statements by member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementsApi
     */
    public listStatementsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return StatementsApiFp(this.configuration).listStatementsByMember(memberGuid, userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read a JSON representation of the statement.
     * @summary Read statement by member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} statementGuid The unique id for a &#x60;statement&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementsApi
     */
    public readStatementByMember(memberGuid: string, statementGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return StatementsApiFp(this.configuration).readStatementByMember(memberGuid, statementGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaggingsApi - axios parameter creator
 * @export
 */
export const TaggingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a new association between a tag and a particular transaction, according to their unique GUIDs.
         * @summary Create tagging
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TaggingCreateRequestBody} taggingCreateRequestBody Tagging object to be created with required parameters (tag_guid and transaction_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagging: async (userGuid: string, taggingCreateRequestBody: TaggingCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createTagging', 'userGuid', userGuid)
            // verify required parameter 'taggingCreateRequestBody' is not null or undefined
            assertParamExists('createTagging', 'taggingCreateRequestBody', taggingCreateRequestBody)
            const localVarPath = `/users/{user_guid}/taggings`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggingCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a tagging according to its unique GUID. If successful, the API will respond with an empty body and a status of 204 NO Content.
         * @summary Delete tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagging: async (taggingGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggingGuid' is not null or undefined
            assertParamExists('deleteTagging', 'taggingGuid', taggingGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteTagging', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/taggings/{tagging_guid}`
                .replace(`{${"tagging_guid"}}`, encodeURIComponent(String(taggingGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a list of all the taggings associated with a specific user.
         * @summary List taggings
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaggings: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTaggings', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/taggings`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a `tagging` according to its unique GUID.
         * @summary Read tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagging: async (taggingGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggingGuid' is not null or undefined
            assertParamExists('readTagging', 'taggingGuid', taggingGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readTagging', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/taggings/{tagging_guid}`
                .replace(`{${"tagging_guid"}}`, encodeURIComponent(String(taggingGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a tagging.
         * @summary Update tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TaggingUpdateRequestBody} taggingUpdateRequestBody Tagging object to be updated with required parameter (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagging: async (taggingGuid: string, userGuid: string, taggingUpdateRequestBody: TaggingUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taggingGuid' is not null or undefined
            assertParamExists('updateTagging', 'taggingGuid', taggingGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateTagging', 'userGuid', userGuid)
            // verify required parameter 'taggingUpdateRequestBody' is not null or undefined
            assertParamExists('updateTagging', 'taggingUpdateRequestBody', taggingUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/taggings/{tagging_guid}`
                .replace(`{${"tagging_guid"}}`, encodeURIComponent(String(taggingGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taggingUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaggingsApi - functional programming interface
 * @export
 */
export const TaggingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaggingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a new association between a tag and a particular transaction, according to their unique GUIDs.
         * @summary Create tagging
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TaggingCreateRequestBody} taggingCreateRequestBody Tagging object to be created with required parameters (tag_guid and transaction_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTagging(userGuid: string, taggingCreateRequestBody: TaggingCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggingResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTagging(userGuid, taggingCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete a tagging according to its unique GUID. If successful, the API will respond with an empty body and a status of 204 NO Content.
         * @summary Delete tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagging(taggingGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagging(taggingGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to retrieve a list of all the taggings associated with a specific user.
         * @summary List taggings
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTaggings(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggingsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaggings(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a `tagging` according to its unique GUID.
         * @summary Read tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTagging(taggingGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggingResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTagging(taggingGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update a tagging.
         * @summary Update tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TaggingUpdateRequestBody} taggingUpdateRequestBody Tagging object to be updated with required parameter (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagging(taggingGuid: string, userGuid: string, taggingUpdateRequestBody: TaggingUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaggingResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagging(taggingGuid, userGuid, taggingUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaggingsApi - factory interface
 * @export
 */
export const TaggingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaggingsApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a new association between a tag and a particular transaction, according to their unique GUIDs.
         * @summary Create tagging
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TaggingCreateRequestBody} taggingCreateRequestBody Tagging object to be created with required parameters (tag_guid and transaction_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagging(userGuid: string, taggingCreateRequestBody: TaggingCreateRequestBody, options?: any): AxiosPromise<TaggingResponseBody> {
            return localVarFp.createTagging(userGuid, taggingCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a tagging according to its unique GUID. If successful, the API will respond with an empty body and a status of 204 NO Content.
         * @summary Delete tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagging(taggingGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTagging(taggingGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a list of all the taggings associated with a specific user.
         * @summary List taggings
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaggings(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<TaggingsResponseBody> {
            return localVarFp.listTaggings(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a `tagging` according to its unique GUID.
         * @summary Read tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagging(taggingGuid: string, userGuid: string, options?: any): AxiosPromise<TaggingResponseBody> {
            return localVarFp.readTagging(taggingGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a tagging.
         * @summary Update tagging
         * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TaggingUpdateRequestBody} taggingUpdateRequestBody Tagging object to be updated with required parameter (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagging(taggingGuid: string, userGuid: string, taggingUpdateRequestBody: TaggingUpdateRequestBody, options?: any): AxiosPromise<TaggingResponseBody> {
            return localVarFp.updateTagging(taggingGuid, userGuid, taggingUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaggingsApi - object-oriented interface
 * @export
 * @class TaggingsApi
 * @extends {BaseAPI}
 */
export class TaggingsApi extends BaseAPI {
    /**
     * Use this endpoint to create a new association between a tag and a particular transaction, according to their unique GUIDs.
     * @summary Create tagging
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {TaggingCreateRequestBody} taggingCreateRequestBody Tagging object to be created with required parameters (tag_guid and transaction_guid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggingsApi
     */
    public createTagging(userGuid: string, taggingCreateRequestBody: TaggingCreateRequestBody, options?: AxiosRequestConfig) {
        return TaggingsApiFp(this.configuration).createTagging(userGuid, taggingCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a tagging according to its unique GUID. If successful, the API will respond with an empty body and a status of 204 NO Content.
     * @summary Delete tagging
     * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggingsApi
     */
    public deleteTagging(taggingGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TaggingsApiFp(this.configuration).deleteTagging(taggingGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a list of all the taggings associated with a specific user.
     * @summary List taggings
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggingsApi
     */
    public listTaggings(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return TaggingsApiFp(this.configuration).listTaggings(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a `tagging` according to its unique GUID.
     * @summary Read tagging
     * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggingsApi
     */
    public readTagging(taggingGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TaggingsApiFp(this.configuration).readTagging(taggingGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a tagging.
     * @summary Update tagging
     * @param {string} taggingGuid The unique id for a &#x60;tagging&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {TaggingUpdateRequestBody} taggingUpdateRequestBody Tagging object to be updated with required parameter (tag_guid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaggingsApi
     */
    public updateTagging(taggingGuid: string, userGuid: string, taggingUpdateRequestBody: TaggingUpdateRequestBody, options?: AxiosRequestConfig) {
        return TaggingsApiFp(this.configuration).updateTagging(taggingGuid, userGuid, taggingUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a new custom tag.
         * @summary Create tag
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TagCreateRequestBody} tagCreateRequestBody Tag object to be created with required parameters (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (userGuid: string, tagCreateRequestBody: TagCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createTag', 'userGuid', userGuid)
            // verify required parameter 'tagCreateRequestBody' is not null or undefined
            assertParamExists('createTag', 'tagCreateRequestBody', tagCreateRequestBody)
            const localVarPath = `/users/{user_guid}/tags`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to permanently delete a specific tag based on its unique GUID. If successful, the API will respond with status of `204 No Content`.
         * @summary Delete tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagGuid: string, accept: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGuid' is not null or undefined
            assertParamExists('deleteTag', 'tagGuid', tagGuid)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('deleteTag', 'accept', accept)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteTag', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/tags/{tag_guid}`
                .replace(`{${"tag_guid"}}`, encodeURIComponent(String(tagGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all tags associated with the specified `user`. Each user includes the `Business` tag by default.
         * @summary List tags
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTags', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/tags`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a particular tag according to its unique GUID.
         * @summary Read tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTag: async (tagGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGuid' is not null or undefined
            assertParamExists('readTag', 'tagGuid', tagGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readTag', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/tags/{tag_guid}`
                .replace(`{${"tag_guid"}}`, encodeURIComponent(String(tagGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the name of a specific tag according to its unique GUID.
         * @summary Update tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TagUpdateRequestBody} tagUpdateRequestBody Tag object to be updated with required parameter (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tagGuid: string, userGuid: string, tagUpdateRequestBody: TagUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGuid' is not null or undefined
            assertParamExists('updateTag', 'tagGuid', tagGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateTag', 'userGuid', userGuid)
            // verify required parameter 'tagUpdateRequestBody' is not null or undefined
            assertParamExists('updateTag', 'tagUpdateRequestBody', tagUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/tags/{tag_guid}`
                .replace(`{${"tag_guid"}}`, encodeURIComponent(String(tagGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a new custom tag.
         * @summary Create tag
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TagCreateRequestBody} tagCreateRequestBody Tag object to be created with required parameters (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(userGuid: string, tagCreateRequestBody: TagCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(userGuid, tagCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to permanently delete a specific tag based on its unique GUID. If successful, the API will respond with status of `204 No Content`.
         * @summary Delete tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagGuid: string, accept: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagGuid, accept, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list all tags associated with the specified `user`. Each user includes the `Business` tag by default.
         * @summary List tags
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTags(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a particular tag according to its unique GUID.
         * @summary Read tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTag(tagGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTag(tagGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the name of a specific tag according to its unique GUID.
         * @summary Update tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TagUpdateRequestBody} tagUpdateRequestBody Tag object to be updated with required parameter (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tagGuid: string, userGuid: string, tagUpdateRequestBody: TagUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tagGuid, userGuid, tagUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a new custom tag.
         * @summary Create tag
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TagCreateRequestBody} tagCreateRequestBody Tag object to be created with required parameters (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(userGuid: string, tagCreateRequestBody: TagCreateRequestBody, options?: any): AxiosPromise<TagResponseBody> {
            return localVarFp.createTag(userGuid, tagCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to permanently delete a specific tag based on its unique GUID. If successful, the API will respond with status of `204 No Content`.
         * @summary Delete tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(tagGuid: string, accept: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(tagGuid, accept, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all tags associated with the specified `user`. Each user includes the `Business` tag by default.
         * @summary List tags
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<TagsResponseBody> {
            return localVarFp.listTags(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a particular tag according to its unique GUID.
         * @summary Read tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTag(tagGuid: string, userGuid: string, options?: any): AxiosPromise<TagResponseBody> {
            return localVarFp.readTag(tagGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the name of a specific tag according to its unique GUID.
         * @summary Update tag
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TagUpdateRequestBody} tagUpdateRequestBody Tag object to be updated with required parameter (tag_guid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(tagGuid: string, userGuid: string, tagUpdateRequestBody: TagUpdateRequestBody, options?: any): AxiosPromise<TagResponseBody> {
            return localVarFp.updateTag(tagGuid, userGuid, tagUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Use this endpoint to create a new custom tag.
     * @summary Create tag
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {TagCreateRequestBody} tagCreateRequestBody Tag object to be created with required parameters (tag_guid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(userGuid: string, tagCreateRequestBody: TagCreateRequestBody, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTag(userGuid, tagCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to permanently delete a specific tag based on its unique GUID. If successful, the API will respond with status of `204 No Content`.
     * @summary Delete tag
     * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
     * @param {string} accept Specifies the media type expected in the response.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(tagGuid: string, accept: string, userGuid: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(tagGuid, accept, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all tags associated with the specified `user`. Each user includes the `Business` tag by default.
     * @summary List tags
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTags(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).listTags(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a particular tag according to its unique GUID.
     * @summary Read tag
     * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public readTag(tagGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).readTag(tagGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the name of a specific tag according to its unique GUID.
     * @summary Update tag
     * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {TagUpdateRequestBody} tagUpdateRequestBody Tag object to be updated with required parameter (tag_guid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(tagGuid: string, userGuid: string, tagUpdateRequestBody: TagUpdateRequestBody, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(tagGuid, userGuid, tagUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionRulesApi - axios parameter creator
 * @export
 */
export const TransactionRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a new transaction rule. The newly-created `transaction_rule` object will be returned if successful.
         * @summary Create transaction rule
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TransactionRuleCreateRequestBody} transactionRuleCreateRequestBody TransactionRule object to be created with optional parameters (description) and required parameters (category_guid and match_description)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionRule: async (userGuid: string, transactionRuleCreateRequestBody: TransactionRuleCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createTransactionRule', 'userGuid', userGuid)
            // verify required parameter 'transactionRuleCreateRequestBody' is not null or undefined
            assertParamExists('createTransactionRule', 'transactionRuleCreateRequestBody', transactionRuleCreateRequestBody)
            const localVarPath = `/users/{user_guid}/transaction_rules`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRuleCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of all existing transaction rules belonging to the user.
         * @summary List transaction rules
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionRules: async (userGuid: string, page?: number, recordsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTransactionRules', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transaction_rules`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of an existing transaction rule based on the ruleâ€™s unique GUID.
         * @summary Read transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTransactionRule: async (transactionRuleGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRuleGuid' is not null or undefined
            assertParamExists('readTransactionRule', 'transactionRuleGuid', transactionRuleGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readTransactionRule', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transaction_rules/{transaction_rule_guid}`
                .replace(`{${"transaction_rule_guid"}}`, encodeURIComponent(String(transactionRuleGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of a specific transaction rule based on its unique GUID. The API will respond with the updated transaction_rule object. Any attributes not provided will be left unchanged.
         * @summary Update transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TransactionRuleUpdateRequestBody} transactionRuleUpdateRequestBody TransactionRule object to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionRule: async (transactionRuleGuid: string, userGuid: string, transactionRuleUpdateRequestBody: TransactionRuleUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRuleGuid' is not null or undefined
            assertParamExists('updateTransactionRule', 'transactionRuleGuid', transactionRuleGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateTransactionRule', 'userGuid', userGuid)
            // verify required parameter 'transactionRuleUpdateRequestBody' is not null or undefined
            assertParamExists('updateTransactionRule', 'transactionRuleUpdateRequestBody', transactionRuleUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/transaction_rules/{transaction_rule_guid}`
                .replace(`{${"transaction_rule_guid"}}`, encodeURIComponent(String(transactionRuleGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRuleUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionRulesApi - functional programming interface
 * @export
 */
export const TransactionRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a new transaction rule. The newly-created `transaction_rule` object will be returned if successful.
         * @summary Create transaction rule
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TransactionRuleCreateRequestBody} transactionRuleCreateRequestBody TransactionRule object to be created with optional parameters (description) and required parameters (category_guid and match_description)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionRule(userGuid: string, transactionRuleCreateRequestBody: TransactionRuleCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRuleResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionRule(userGuid, transactionRuleCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of all existing transaction rules belonging to the user.
         * @summary List transaction rules
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionRules(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRulesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionRules(userGuid, page, recordsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of an existing transaction rule based on the ruleâ€™s unique GUID.
         * @summary Read transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTransactionRule(transactionRuleGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRuleResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTransactionRule(transactionRuleGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of a specific transaction rule based on its unique GUID. The API will respond with the updated transaction_rule object. Any attributes not provided will be left unchanged.
         * @summary Update transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TransactionRuleUpdateRequestBody} transactionRuleUpdateRequestBody TransactionRule object to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionRule(transactionRuleGuid: string, userGuid: string, transactionRuleUpdateRequestBody: TransactionRuleUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRuleResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionRule(transactionRuleGuid, userGuid, transactionRuleUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionRulesApi - factory interface
 * @export
 */
export const TransactionRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionRulesApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a new transaction rule. The newly-created `transaction_rule` object will be returned if successful.
         * @summary Create transaction rule
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TransactionRuleCreateRequestBody} transactionRuleCreateRequestBody TransactionRule object to be created with optional parameters (description) and required parameters (category_guid and match_description)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionRule(userGuid: string, transactionRuleCreateRequestBody: TransactionRuleCreateRequestBody, options?: any): AxiosPromise<TransactionRuleResponseBody> {
            return localVarFp.createTransactionRule(userGuid, transactionRuleCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of all existing transaction rules belonging to the user.
         * @summary List transaction rules
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionRules(userGuid: string, page?: number, recordsPerPage?: number, options?: any): AxiosPromise<TransactionRulesResponseBody> {
            return localVarFp.listTransactionRules(userGuid, page, recordsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of an existing transaction rule based on the ruleâ€™s unique GUID.
         * @summary Read transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTransactionRule(transactionRuleGuid: string, userGuid: string, options?: any): AxiosPromise<TransactionRuleResponseBody> {
            return localVarFp.readTransactionRule(transactionRuleGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of a specific transaction rule based on its unique GUID. The API will respond with the updated transaction_rule object. Any attributes not provided will be left unchanged.
         * @summary Update transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {TransactionRuleUpdateRequestBody} transactionRuleUpdateRequestBody TransactionRule object to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionRule(transactionRuleGuid: string, userGuid: string, transactionRuleUpdateRequestBody: TransactionRuleUpdateRequestBody, options?: any): AxiosPromise<TransactionRuleResponseBody> {
            return localVarFp.updateTransactionRule(transactionRuleGuid, userGuid, transactionRuleUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionRulesApi - object-oriented interface
 * @export
 * @class TransactionRulesApi
 * @extends {BaseAPI}
 */
export class TransactionRulesApi extends BaseAPI {
    /**
     * Use this endpoint to create a new transaction rule. The newly-created `transaction_rule` object will be returned if successful.
     * @summary Create transaction rule
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {TransactionRuleCreateRequestBody} transactionRuleCreateRequestBody TransactionRule object to be created with optional parameters (description) and required parameters (category_guid and match_description)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRulesApi
     */
    public createTransactionRule(userGuid: string, transactionRuleCreateRequestBody: TransactionRuleCreateRequestBody, options?: AxiosRequestConfig) {
        return TransactionRulesApiFp(this.configuration).createTransactionRule(userGuid, transactionRuleCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of all existing transaction rules belonging to the user.
     * @summary List transaction rules
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRulesApi
     */
    public listTransactionRules(userGuid: string, page?: number, recordsPerPage?: number, options?: AxiosRequestConfig) {
        return TransactionRulesApiFp(this.configuration).listTransactionRules(userGuid, page, recordsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of an existing transaction rule based on the ruleâ€™s unique GUID.
     * @summary Read transaction rule
     * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRulesApi
     */
    public readTransactionRule(transactionRuleGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TransactionRulesApiFp(this.configuration).readTransactionRule(transactionRuleGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of a specific transaction rule based on its unique GUID. The API will respond with the updated transaction_rule object. Any attributes not provided will be left unchanged.
     * @summary Update transaction rule
     * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {TransactionRuleUpdateRequestBody} transactionRuleUpdateRequestBody TransactionRule object to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRulesApi
     */
    public updateTransactionRule(transactionRuleGuid: string, userGuid: string, transactionRuleUpdateRequestBody: TransactionRuleUpdateRequestBody, options?: AxiosRequestConfig) {
        return TransactionRulesApiFp(this.configuration).updateTransactionRule(transactionRuleGuid, userGuid, transactionRuleUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint can only be used to create manual transactions that are under a manual account. This endpoint accepts the optional MX-Skip-Webhook header and skip_webhook parameter.
         * @summary Create manual transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {TransactionCreateRequestBody} transactionCreateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualTransaction: async (userGuid: string, accountGuid: string, transactionCreateRequestBody: TransactionCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createManualTransaction', 'userGuid', userGuid)
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('createManualTransaction', 'accountGuid', accountGuid)
            // verify required parameter 'transactionCreateRequestBody' is not null or undefined
            assertParamExists('createManualTransaction', 'transactionCreateRequestBody', transactionCreateRequestBody)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}/transactions`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates two or more child transactions that are branched from a previous transaction. This endpoint allows you to link multiple categories, descriptions, and amounts to a parent transaction.  When a split transaction is created, the parent transaction\'s `has_been_split` field will automatically be updated to true and the child transactions\' `parent_guid` will have the transaction guid of the parent. The total amount of the child transactions must equal the amount of the parent transaction. Once a transaction has been split it can\'t be split again.    In order to re-split a transaction, it must first be un-split. This can be done by calling the Delete Split Transactions endpoint. Calling this endpoint will delete the existing child transactions and update the parent transaction\'s `has_been_split` field to false. You can then re-split the parent transaction by calling Create Split Transaction again. 
         * @summary Create split transactions
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {SplitTransactionRequestBody} [splitTransactionRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSplitTransactions: async (transactionGuid: string, userGuid: string, splitTransactionRequestBody?: SplitTransactionRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('createSplitTransactions', 'transactionGuid', transactionGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('createSplitTransactions', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transactions/{transaction_guid}/split`
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitTransactionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a manual transaction. In the path, use the manual transaction guid as the `transaction_guid`, such as `MAN-810828b0-5210-4878-9bd3-f4ce514f90c4`.
         * @summary Delete manual transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManualTransactions: async (userGuid: string, transactionGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteManualTransactions', 'userGuid', userGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('deleteManualTransactions', 'transactionGuid', transactionGuid)
            const localVarPath = `/users/{user_guid}/transactions/{transaction_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes all split transactions linked to a parent transaction, but it leaves the parent transaction active. This request will also update the parent transaction\'s has_been_split field to false. This endpoint accepts the optional MX-Skip-Webhook header.
         * @summary Delete split transactions
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSplitTransactions: async (transactionGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('deleteSplitTransactions', 'transactionGuid', transactionGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteSplitTransactions', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transactions/{transaction_guid}/split`
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to permanently delete a transaction rule based on its unique GUID.
         * @summary Delete transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionRule: async (transactionRuleGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRuleGuid' is not null or undefined
            assertParamExists('deleteTransactionRule', 'transactionRuleGuid', transactionRuleGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteTransactionRule', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transaction_rules/{transaction_rule_guid}`
                .replace(`{${"transaction_rule_guid"}}`, encodeURIComponent(String(transactionRuleGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to categorize, cleanse, and classify transactions. These transactions are not persisted or stored on the MX platform. <br /><br />For more information on returned data, please see the [Enhanced Transactions fields guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions).
         * @summary Enhance transactions
         * @param {EnhanceTransactionsRequestBody} enhanceTransactionsRequestBody Transaction object to be enhanced
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enhanceTransactions: async (enhanceTransactionsRequestBody: EnhanceTransactionsRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enhanceTransactionsRequestBody' is not null or undefined
            assertParamExists('enhanceTransactions', 'enhanceTransactionsRequestBody', enhanceTransactionsRequestBody)
            const localVarPath = `/transactions/enhance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enhanceTransactionsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Some institutions allow developers to access an extended transaction history with up to 24 months of data associated with a particular member. The process for fetching and then reading this extended transaction history is much like standard aggregation, and it may trigger multi-factor authentication.
         * @summary Extend history
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendHistory: async (memberGuid: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('extendHistory', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('extendHistory', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/extend_history`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified `user`, across all members and accounts associated with that `user`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: async (userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTransactions', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/transactions`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (fromCreatedAt !== undefined) {
                localVarQueryParameter['from_created_at'] = fromCreatedAt;
            }

            if (toCreatedAt !== undefined) {
                localVarQueryParameter['to_created_at'] = toCreatedAt;
            }

            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = fromUpdatedAt;
            }

            if (toUpdatedAt !== undefined) {
                localVarQueryParameter['to_updated_at'] = toUpdatedAt;
            }

            if (categoryGuid !== undefined) {
                localVarQueryParameter['category_guid'] = categoryGuid;
            }

            if (categoryGuid2) {
                localVarQueryParameter['category_guid[]'] = categoryGuid2;
            }

            if (topLevelCategoryGuid !== undefined) {
                localVarQueryParameter['top_level_category_guid'] = topLevelCategoryGuid;
            }

            if (topLevelCategoryGuid2) {
                localVarQueryParameter['top_level_category_guid[]'] = topLevelCategoryGuid2;
            }

            if (useCase !== undefined) {
                localVarQueryParameter['use_case'] = useCase;
            }

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified account. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByAccount: async (accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('listTransactionsByAccount', 'accountGuid', accountGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTransactionsByAccount', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/accounts/{account_guid}/transactions`
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (fromCreatedAt !== undefined) {
                localVarQueryParameter['from_created_at'] = fromCreatedAt;
            }

            if (toCreatedAt !== undefined) {
                localVarQueryParameter['to_created_at'] = toCreatedAt;
            }

            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = fromUpdatedAt;
            }

            if (toUpdatedAt !== undefined) {
                localVarQueryParameter['to_updated_at'] = toUpdatedAt;
            }

            if (categoryGuid !== undefined) {
                localVarQueryParameter['category_guid'] = categoryGuid;
            }

            if (categoryGuid2) {
                localVarQueryParameter['category_guid[]'] = categoryGuid2;
            }

            if (topLevelCategoryGuid !== undefined) {
                localVarQueryParameter['top_level_category_guid'] = topLevelCategoryGuid;
            }

            if (topLevelCategoryGuid2) {
                localVarQueryParameter['top_level_category_guid[]'] = topLevelCategoryGuid2;
            }

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified `member`, across all accounts associated with that `member`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByMember: async (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('listTransactionsByMember', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTransactionsByMember', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/transactions`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (fromCreatedAt !== undefined) {
                localVarQueryParameter['from_created_at'] = fromCreatedAt;
            }

            if (toCreatedAt !== undefined) {
                localVarQueryParameter['to_created_at'] = toCreatedAt;
            }

            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = fromUpdatedAt;
            }

            if (toUpdatedAt !== undefined) {
                localVarQueryParameter['to_updated_at'] = toUpdatedAt;
            }

            if (categoryGuid !== undefined) {
                localVarQueryParameter['category_guid'] = categoryGuid;
            }

            if (categoryGuid2) {
                localVarQueryParameter['category_guid[]'] = categoryGuid2;
            }

            if (topLevelCategoryGuid !== undefined) {
                localVarQueryParameter['top_level_category_guid'] = topLevelCategoryGuid;
            }

            if (topLevelCategoryGuid2) {
                localVarQueryParameter['top_level_category_guid[]'] = topLevelCategoryGuid2;
            }

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get a list of all transactions associated with a particular tag according to the tag\'s unique GUID. This lists all transactions that have been assigned to a particular tag using the create tagging endpoint. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by tag
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByTag: async (userGuid: string, tagGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('listTransactionsByTag', 'userGuid', userGuid)
            // verify required parameter 'tagGuid' is not null or undefined
            assertParamExists('listTransactionsByTag', 'tagGuid', tagGuid)
            const localVarPath = `/users/{user_guid}/tags/{tag_guid}/transactions`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"tag_guid"}}`, encodeURIComponent(String(tagGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (fromCreatedAt !== undefined) {
                localVarQueryParameter['from_created_at'] = fromCreatedAt;
            }

            if (toCreatedAt !== undefined) {
                localVarQueryParameter['to_created_at'] = toCreatedAt;
            }

            if (fromUpdatedAt !== undefined) {
                localVarQueryParameter['from_updated_at'] = fromUpdatedAt;
            }

            if (toUpdatedAt !== undefined) {
                localVarQueryParameter['to_updated_at'] = toUpdatedAt;
            }

            if (categoryGuid !== undefined) {
                localVarQueryParameter['category_guid'] = categoryGuid;
            }

            if (categoryGuid2) {
                localVarQueryParameter['category_guid[]'] = categoryGuid2;
            }

            if (topLevelCategoryGuid !== undefined) {
                localVarQueryParameter['top_level_category_guid'] = topLevelCategoryGuid;
            }

            if (topLevelCategoryGuid2) {
                localVarQueryParameter['top_level_category_guid[]'] = topLevelCategoryGuid2;
            }

            if (useCase !== undefined) {
                localVarQueryParameter['use_case'] = useCase;
            }

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests to this endpoint will return the attributes of the specified `transaction`. To read a manual transaction, use the manual transaction guid in the path as the `transactionGuid`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary Read transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTransaction: async (userGuid: string, transactionGuid: string, includes?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readTransaction', 'userGuid', userGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('readTransaction', 'transactionGuid', transactionGuid)
            const localVarPath = `/users/{user_guid}/transactions/{transaction_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all recurring transactions for a user. <br /><br />For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx).
         * @summary List Repeating Transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repeatingTransactions: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('repeatingTransactions', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/repeating_transactions`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Specific Repeating Transaction. <br /><br />List For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx)
         * @summary Get a Repeating Transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} repeatingTransactionGuid The unique id for a recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificRepeatingTransaction: async (userGuid: string, repeatingTransactionGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('specificRepeatingTransaction', 'userGuid', userGuid)
            // verify required parameter 'repeatingTransactionGuid' is not null or undefined
            assertParamExists('specificRepeatingTransaction', 'repeatingTransactionGuid', repeatingTransactionGuid)
            const localVarPath = `/users/{user_guid}/repeating_transactions/{repeating_transaction_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"repeating_transaction_guid"}}`, encodeURIComponent(String(repeatingTransactionGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a specific transaction according to its unique GUID.
         * @summary Update transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object with the fields to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (userGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateTransaction', 'userGuid', userGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('updateTransaction', 'transactionGuid', transactionGuid)
            // verify required parameter 'transactionUpdateRequestBody' is not null or undefined
            assertParamExists('updateTransaction', 'transactionUpdateRequestBody', transactionUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/transactions/{transaction_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a specific transaction according to its unique GUID.
         * @summary Update Transaction by Account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionByAccount: async (userGuid: string, memberGuid: string, accountGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateTransactionByAccount', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('updateTransactionByAccount', 'memberGuid', memberGuid)
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('updateTransactionByAccount', 'accountGuid', accountGuid)
            // verify required parameter 'transactionGuid' is not null or undefined
            assertParamExists('updateTransactionByAccount', 'transactionGuid', transactionGuid)
            // verify required parameter 'transactionUpdateRequestBody' is not null or undefined
            assertParamExists('updateTransactionByAccount', 'transactionUpdateRequestBody', transactionUpdateRequestBody)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/accounts/{account_guid}/transactions/{transaction_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)))
                .replace(`{${"transaction_guid"}}`, encodeURIComponent(String(transactionGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint can only be used to create manual transactions that are under a manual account. This endpoint accepts the optional MX-Skip-Webhook header and skip_webhook parameter.
         * @summary Create manual transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {TransactionCreateRequestBody} transactionCreateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManualTransaction(userGuid: string, accountGuid: string, transactionCreateRequestBody: TransactionCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionCreateResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManualTransaction(userGuid, accountGuid, transactionCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint creates two or more child transactions that are branched from a previous transaction. This endpoint allows you to link multiple categories, descriptions, and amounts to a parent transaction.  When a split transaction is created, the parent transaction\'s `has_been_split` field will automatically be updated to true and the child transactions\' `parent_guid` will have the transaction guid of the parent. The total amount of the child transactions must equal the amount of the parent transaction. Once a transaction has been split it can\'t be split again.    In order to re-split a transaction, it must first be un-split. This can be done by calling the Delete Split Transactions endpoint. Calling this endpoint will delete the existing child transactions and update the parent transaction\'s `has_been_split` field to false. You can then re-split the parent transaction by calling Create Split Transaction again. 
         * @summary Create split transactions
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {SplitTransactionRequestBody} [splitTransactionRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSplitTransactions(transactionGuid: string, userGuid: string, splitTransactionRequestBody?: SplitTransactionRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitTransactionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSplitTransactions(transactionGuid, userGuid, splitTransactionRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a manual transaction. In the path, use the manual transaction guid as the `transaction_guid`, such as `MAN-810828b0-5210-4878-9bd3-f4ce514f90c4`.
         * @summary Delete manual transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManualTransactions(userGuid: string, transactionGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManualTransactions(userGuid, transactionGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes all split transactions linked to a parent transaction, but it leaves the parent transaction active. This request will also update the parent transaction\'s has_been_split field to false. This endpoint accepts the optional MX-Skip-Webhook header.
         * @summary Delete split transactions
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSplitTransactions(transactionGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSplitTransactions(transactionGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to permanently delete a transaction rule based on its unique GUID.
         * @summary Delete transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionRule(transactionRuleGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionRule(transactionRuleGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to categorize, cleanse, and classify transactions. These transactions are not persisted or stored on the MX platform. <br /><br />For more information on returned data, please see the [Enhanced Transactions fields guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions).
         * @summary Enhance transactions
         * @param {EnhanceTransactionsRequestBody} enhanceTransactionsRequestBody Transaction object to be enhanced
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enhanceTransactions(enhanceTransactionsRequestBody: EnhanceTransactionsRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnhanceTransactionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enhanceTransactions(enhanceTransactionsRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Some institutions allow developers to access an extended transaction history with up to 24 months of data associated with a particular member. The process for fetching and then reading this extended transaction history is much like standard aggregation, and it may trigger multi-factor authentication.
         * @summary Extend history
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extendHistory(memberGuid: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extendHistory(memberGuid, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified `user`, across all members and accounts associated with that `user`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactions(userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBodyIncludes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactions(userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, useCase, includes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified account. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBodyIncludes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByAccount(accountGuid, userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, includes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified `member`, across all accounts associated with that `member`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBodyIncludes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByMember(memberGuid, userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, includes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to get a list of all transactions associated with a particular tag according to the tag\'s unique GUID. This lists all transactions that have been assigned to a particular tag using the create tagging endpoint. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by tag
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionsByTag(userGuid: string, tagGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBodyIncludes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByTag(userGuid, tagGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, useCase, includes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Requests to this endpoint will return the attributes of the specified `transaction`. To read a manual transaction, use the manual transaction guid in the path as the `transactionGuid`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary Read transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTransaction(userGuid: string, transactionGuid: string, includes?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsResponseBodyIncludes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTransaction(userGuid, transactionGuid, includes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of all recurring transactions for a user. <br /><br />For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx).
         * @summary List Repeating Transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repeatingTransactions(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepeatingTransactionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repeatingTransactions(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Specific Repeating Transaction. <br /><br />List For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx)
         * @summary Get a Repeating Transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} repeatingTransactionGuid The unique id for a recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async specificRepeatingTransaction(userGuid: string, repeatingTransactionGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepeatingTransactionsResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.specificRepeatingTransaction(userGuid, repeatingTransactionGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update a specific transaction according to its unique GUID.
         * @summary Update transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object with the fields to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(userGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(userGuid, transactionGuid, transactionUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update a specific transaction according to its unique GUID.
         * @summary Update Transaction by Account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionByAccount(userGuid: string, memberGuid: string, accountGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionByAccount(userGuid, memberGuid, accountGuid, transactionGuid, transactionUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * This endpoint can only be used to create manual transactions that are under a manual account. This endpoint accepts the optional MX-Skip-Webhook header and skip_webhook parameter.
         * @summary Create manual transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {TransactionCreateRequestBody} transactionCreateRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualTransaction(userGuid: string, accountGuid: string, transactionCreateRequestBody: TransactionCreateRequestBody, options?: any): AxiosPromise<TransactionCreateResponseBody> {
            return localVarFp.createManualTransaction(userGuid, accountGuid, transactionCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates two or more child transactions that are branched from a previous transaction. This endpoint allows you to link multiple categories, descriptions, and amounts to a parent transaction.  When a split transaction is created, the parent transaction\'s `has_been_split` field will automatically be updated to true and the child transactions\' `parent_guid` will have the transaction guid of the parent. The total amount of the child transactions must equal the amount of the parent transaction. Once a transaction has been split it can\'t be split again.    In order to re-split a transaction, it must first be un-split. This can be done by calling the Delete Split Transactions endpoint. Calling this endpoint will delete the existing child transactions and update the parent transaction\'s `has_been_split` field to false. You can then re-split the parent transaction by calling Create Split Transaction again. 
         * @summary Create split transactions
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {SplitTransactionRequestBody} [splitTransactionRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSplitTransactions(transactionGuid: string, userGuid: string, splitTransactionRequestBody?: SplitTransactionRequestBody, options?: any): AxiosPromise<SplitTransactionsResponseBody> {
            return localVarFp.createSplitTransactions(transactionGuid, userGuid, splitTransactionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a manual transaction. In the path, use the manual transaction guid as the `transaction_guid`, such as `MAN-810828b0-5210-4878-9bd3-f4ce514f90c4`.
         * @summary Delete manual transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManualTransactions(userGuid: string, transactionGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManualTransactions(userGuid, transactionGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes all split transactions linked to a parent transaction, but it leaves the parent transaction active. This request will also update the parent transaction\'s has_been_split field to false. This endpoint accepts the optional MX-Skip-Webhook header.
         * @summary Delete split transactions
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSplitTransactions(transactionGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSplitTransactions(transactionGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to permanently delete a transaction rule based on its unique GUID.
         * @summary Delete transaction rule
         * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionRule(transactionRuleGuid: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionRule(transactionRuleGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to categorize, cleanse, and classify transactions. These transactions are not persisted or stored on the MX platform. <br /><br />For more information on returned data, please see the [Enhanced Transactions fields guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions).
         * @summary Enhance transactions
         * @param {EnhanceTransactionsRequestBody} enhanceTransactionsRequestBody Transaction object to be enhanced
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enhanceTransactions(enhanceTransactionsRequestBody: EnhanceTransactionsRequestBody, options?: any): AxiosPromise<EnhanceTransactionsResponseBody> {
            return localVarFp.enhanceTransactions(enhanceTransactionsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Some institutions allow developers to access an extended transaction history with up to 24 months of data associated with a particular member. The process for fetching and then reading this extended transaction history is much like standard aggregation, and it may trigger multi-factor authentication.
         * @summary Extend history
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendHistory(memberGuid: string, userGuid: string, options?: any): AxiosPromise<MemberResponseBody> {
            return localVarFp.extendHistory(memberGuid, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified `user`, across all members and accounts associated with that `user`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options?: any): AxiosPromise<TransactionsResponseBodyIncludes> {
            return localVarFp.listTransactions(userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, useCase, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified account. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by account
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options?: any): AxiosPromise<TransactionsResponseBodyIncludes> {
            return localVarFp.listTransactionsByAccount(accountGuid, userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests to this endpoint return a list of transactions associated with the specified `member`, across all accounts associated with that `member`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by member
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options?: any): AxiosPromise<TransactionsResponseBodyIncludes> {
            return localVarFp.listTransactionsByMember(memberGuid, userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get a list of all transactions associated with a particular tag according to the tag\'s unique GUID. This lists all transactions that have been assigned to a particular tag using the create tagging endpoint. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary List transactions by tag
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
         * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
         * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
         * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
         * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsByTag(userGuid: string, tagGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options?: any): AxiosPromise<TransactionsResponseBodyIncludes> {
            return localVarFp.listTransactionsByTag(userGuid, tagGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, useCase, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Requests to this endpoint will return the attributes of the specified `transaction`. To read a manual transaction, use the manual transaction guid in the path as the `transactionGuid`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
         * @summary Read transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTransaction(userGuid: string, transactionGuid: string, includes?: string, options?: any): AxiosPromise<TransactionsResponseBodyIncludes> {
            return localVarFp.readTransaction(userGuid, transactionGuid, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all recurring transactions for a user. <br /><br />For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx).
         * @summary List Repeating Transactions
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repeatingTransactions(userGuid: string, options?: any): AxiosPromise<RepeatingTransactionsResponseBody> {
            return localVarFp.repeatingTransactions(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Specific Repeating Transaction. <br /><br />List For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx)
         * @summary Get a Repeating Transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} repeatingTransactionGuid The unique id for a recurring transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specificRepeatingTransaction(userGuid: string, repeatingTransactionGuid: string, options?: any): AxiosPromise<RepeatingTransactionsResponseBody> {
            return localVarFp.specificRepeatingTransaction(userGuid, repeatingTransactionGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a specific transaction according to its unique GUID.
         * @summary Update transaction
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object with the fields to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(userGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options?: any): AxiosPromise<TransactionResponseBody> {
            return localVarFp.updateTransaction(userGuid, transactionGuid, transactionUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a specific transaction according to its unique GUID.
         * @summary Update Transaction by Account
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
         * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionByAccount(userGuid: string, memberGuid: string, accountGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options?: any): AxiosPromise<TransactionResponseBody> {
            return localVarFp.updateTransactionByAccount(userGuid, memberGuid, accountGuid, transactionGuid, transactionUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * This endpoint can only be used to create manual transactions that are under a manual account. This endpoint accepts the optional MX-Skip-Webhook header and skip_webhook parameter.
     * @summary Create manual transaction
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {TransactionCreateRequestBody} transactionCreateRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createManualTransaction(userGuid: string, accountGuid: string, transactionCreateRequestBody: TransactionCreateRequestBody, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createManualTransaction(userGuid, accountGuid, transactionCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates two or more child transactions that are branched from a previous transaction. This endpoint allows you to link multiple categories, descriptions, and amounts to a parent transaction.  When a split transaction is created, the parent transaction\'s `has_been_split` field will automatically be updated to true and the child transactions\' `parent_guid` will have the transaction guid of the parent. The total amount of the child transactions must equal the amount of the parent transaction. Once a transaction has been split it can\'t be split again.    In order to re-split a transaction, it must first be un-split. This can be done by calling the Delete Split Transactions endpoint. Calling this endpoint will delete the existing child transactions and update the parent transaction\'s `has_been_split` field to false. You can then re-split the parent transaction by calling Create Split Transaction again. 
     * @summary Create split transactions
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {SplitTransactionRequestBody} [splitTransactionRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createSplitTransactions(transactionGuid: string, userGuid: string, splitTransactionRequestBody?: SplitTransactionRequestBody, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createSplitTransactions(transactionGuid, userGuid, splitTransactionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a manual transaction. In the path, use the manual transaction guid as the `transaction_guid`, such as `MAN-810828b0-5210-4878-9bd3-f4ce514f90c4`.
     * @summary Delete manual transactions
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteManualTransactions(userGuid: string, transactionGuid: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteManualTransactions(userGuid, transactionGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes all split transactions linked to a parent transaction, but it leaves the parent transaction active. This request will also update the parent transaction\'s has_been_split field to false. This endpoint accepts the optional MX-Skip-Webhook header.
     * @summary Delete split transactions
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteSplitTransactions(transactionGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteSplitTransactions(transactionGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to permanently delete a transaction rule based on its unique GUID.
     * @summary Delete transaction rule
     * @param {string} transactionRuleGuid The unique id for a &#x60;transaction_rule&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransactionRule(transactionRuleGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransactionRule(transactionRuleGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to categorize, cleanse, and classify transactions. These transactions are not persisted or stored on the MX platform. <br /><br />For more information on returned data, please see the [Enhanced Transactions fields guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions).
     * @summary Enhance transactions
     * @param {EnhanceTransactionsRequestBody} enhanceTransactionsRequestBody Transaction object to be enhanced
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public enhanceTransactions(enhanceTransactionsRequestBody: EnhanceTransactionsRequestBody, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).enhanceTransactions(enhanceTransactionsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Some institutions allow developers to access an extended transaction history with up to 24 months of data associated with a particular member. The process for fetching and then reading this extended transaction history is much like standard aggregation, and it may trigger multi-factor authentication.
     * @summary Extend history
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public extendHistory(memberGuid: string, userGuid: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).extendHistory(memberGuid, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests to this endpoint return a list of transactions associated with the specified `user`, across all members and accounts associated with that `user`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
     * @summary List transactions
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
     * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
     * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
     * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactions(userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactions(userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, useCase, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests to this endpoint return a list of transactions associated with the specified account. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
     * @summary List transactions by account
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
     * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
     * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactionsByAccount(accountGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactionsByAccount(accountGuid, userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests to this endpoint return a list of transactions associated with the specified `member`, across all accounts associated with that `member`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
     * @summary List transactions by member
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
     * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
     * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactionsByMember(memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, includes?: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactionsByMember(memberGuid, userGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get a list of all transactions associated with a particular tag according to the tag\'s unique GUID. This lists all transactions that have been assigned to a particular tag using the create tagging endpoint. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
     * @summary List transactions by tag
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} tagGuid The unique id for a &#x60;tag&#x60;.
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [fromDate] Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
     * @param {string} [toDate] Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
     * @param {string} [fromCreatedAt] Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toCreatedAt] Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [fromUpdatedAt] Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [toUpdatedAt] Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
     * @param {string} [categoryGuid] Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [categoryGuid2] Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [topLevelCategoryGuid] Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {Array<string>} [topLevelCategoryGuid2] Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
     * @param {string} [useCase] The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
     * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public listTransactionsByTag(userGuid: string, tagGuid: string, page?: number, recordsPerPage?: number, fromDate?: string, toDate?: string, fromCreatedAt?: string, toCreatedAt?: string, fromUpdatedAt?: string, toUpdatedAt?: string, categoryGuid?: string, categoryGuid2?: Array<string>, topLevelCategoryGuid?: string, topLevelCategoryGuid2?: Array<string>, useCase?: string, includes?: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).listTransactionsByTag(userGuid, tagGuid, page, recordsPerPage, fromDate, toDate, fromCreatedAt, toCreatedAt, fromUpdatedAt, toUpdatedAt, categoryGuid, categoryGuid2, topLevelCategoryGuid, topLevelCategoryGuid2, useCase, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests to this endpoint will return the attributes of the specified `transaction`. To read a manual transaction, use the manual transaction guid in the path as the `transactionGuid`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).
     * @summary Read transaction
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {string} [includes] Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public readTransaction(userGuid: string, transactionGuid: string, includes?: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).readTransaction(userGuid, transactionGuid, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all recurring transactions for a user. <br /><br />For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx).
     * @summary List Repeating Transactions
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public repeatingTransactions(userGuid: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).repeatingTransactions(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Specific Repeating Transaction. <br /><br />List For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx)
     * @summary Get a Repeating Transaction
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} repeatingTransactionGuid The unique id for a recurring transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public specificRepeatingTransaction(userGuid: string, repeatingTransactionGuid: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).specificRepeatingTransaction(userGuid, repeatingTransactionGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a specific transaction according to its unique GUID.
     * @summary Update transaction
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object with the fields to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(userGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(userGuid, transactionGuid, transactionUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a specific transaction according to its unique GUID.
     * @summary Update Transaction by Account
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} transactionGuid The unique id for a &#x60;transaction&#x60;.
     * @param {TransactionUpdateRequestBody} transactionUpdateRequestBody Transaction object to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransactionByAccount(userGuid: string, memberGuid: string, accountGuid: string, transactionGuid: string, transactionUpdateRequestBody: TransactionUpdateRequestBody, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransactionByAccount(userGuid, memberGuid, accountGuid, transactionGuid, transactionUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a new user. The API will respond with the newly-created user object if successful, containing a `guid` that you\'ll set as the `user_guid` in other requests when required. Disabling a user means that accounts and transactions associated with it will not be updated in the background by MX. It will also restrict access to that userâ€™s data until they are no longer disabled.
         * @summary Create user
         * @param {UserCreateRequestBody} userCreateRequestBody User object to be created. (None of these parameters are required, but the user object cannot be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreateRequestBody: UserCreateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateRequestBody' is not null or undefined
            assertParamExists('createUser', 'userCreateRequestBody', userCreateRequestBody)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete the specified `user`. The response will have a status of `204 No Content` without an object.  :::warning Deleting a user is permanent. Deleted users can never be restored. For more info, see [Deleting Objects](https://docs.mx.com/api-reference/platform-api/overview/deleting-objects). ::: 
         * @summary Delete user
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (accept: string, userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('deleteUser', 'accept', accept)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('deleteUser', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list every user you\'ve created in the MX Platform API.
         * @summary List users
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [id] The user &#x60;id&#x60; to search for.
         * @param {string} [email] The user &#x60;email&#x60; to search for.
         * @param {boolean} [isDisabled] Search for users that are diabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (page?: number, recordsPerPage?: number, id?: string, email?: string, isDisabled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (recordsPerPage !== undefined) {
                localVarQueryParameter['records_per_page'] = recordsPerPage;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (isDisabled !== undefined) {
                localVarQueryParameter['is_disabled'] = isDisabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to read the attributes of a specific user.
         * @summary Read user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUser: async (userGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('readUser', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the attributes of the specified user.
         * @summary Update user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {UserUpdateRequestBody} userUpdateRequestBody User object to be updated (None of these parameters are required, but the user object cannot be empty.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userGuid: string, userUpdateRequestBody: UserUpdateRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('updateUser', 'userGuid', userGuid)
            // verify required parameter 'userUpdateRequestBody' is not null or undefined
            assertParamExists('updateUser', 'userUpdateRequestBody', userUpdateRequestBody)
            const localVarPath = `/users/{user_guid}`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a new user. The API will respond with the newly-created user object if successful, containing a `guid` that you\'ll set as the `user_guid` in other requests when required. Disabling a user means that accounts and transactions associated with it will not be updated in the background by MX. It will also restrict access to that userâ€™s data until they are no longer disabled.
         * @summary Create user
         * @param {UserCreateRequestBody} userCreateRequestBody User object to be created. (None of these parameters are required, but the user object cannot be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreateRequestBody: UserCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete the specified `user`. The response will have a status of `204 No Content` without an object.  :::warning Deleting a user is permanent. Deleted users can never be restored. For more info, see [Deleting Objects](https://docs.mx.com/api-reference/platform-api/overview/deleting-objects). ::: 
         * @summary Delete user
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(accept: string, userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(accept, userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to list every user you\'ve created in the MX Platform API.
         * @summary List users
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [id] The user &#x60;id&#x60; to search for.
         * @param {string} [email] The user &#x60;email&#x60; to search for.
         * @param {boolean} [isDisabled] Search for users that are diabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(page?: number, recordsPerPage?: number, id?: string, email?: string, isDisabled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(page, recordsPerPage, id, email, isDisabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to read the attributes of a specific user.
         * @summary Read user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUser(userGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUser(userGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to update the attributes of the specified user.
         * @summary Update user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {UserUpdateRequestBody} userUpdateRequestBody User object to be updated (None of these parameters are required, but the user object cannot be empty.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userGuid: string, userUpdateRequestBody: UserUpdateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userGuid, userUpdateRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a new user. The API will respond with the newly-created user object if successful, containing a `guid` that you\'ll set as the `user_guid` in other requests when required. Disabling a user means that accounts and transactions associated with it will not be updated in the background by MX. It will also restrict access to that userâ€™s data until they are no longer disabled.
         * @summary Create user
         * @param {UserCreateRequestBody} userCreateRequestBody User object to be created. (None of these parameters are required, but the user object cannot be empty)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreateRequestBody: UserCreateRequestBody, options?: any): AxiosPromise<UserResponseBody> {
            return localVarFp.createUser(userCreateRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete the specified `user`. The response will have a status of `204 No Content` without an object.  :::warning Deleting a user is permanent. Deleted users can never be restored. For more info, see [Deleting Objects](https://docs.mx.com/api-reference/platform-api/overview/deleting-objects). ::: 
         * @summary Delete user
         * @param {string} accept Specifies the media type expected in the response.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(accept: string, userGuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(accept, userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list every user you\'ve created in the MX Platform API.
         * @summary List users
         * @param {number} [page] Results are paginated. Specify current page.
         * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
         * @param {string} [id] The user &#x60;id&#x60; to search for.
         * @param {string} [email] The user &#x60;email&#x60; to search for.
         * @param {boolean} [isDisabled] Search for users that are diabled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, recordsPerPage?: number, id?: string, email?: string, isDisabled?: boolean, options?: any): AxiosPromise<UsersResponseBody> {
            return localVarFp.listUsers(page, recordsPerPage, id, email, isDisabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to read the attributes of a specific user.
         * @summary Read user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUser(userGuid: string, options?: any): AxiosPromise<UserResponseBody> {
            return localVarFp.readUser(userGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the attributes of the specified user.
         * @summary Update user
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {UserUpdateRequestBody} userUpdateRequestBody User object to be updated (None of these parameters are required, but the user object cannot be empty.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userGuid: string, userUpdateRequestBody: UserUpdateRequestBody, options?: any): AxiosPromise<UserResponseBody> {
            return localVarFp.updateUser(userGuid, userUpdateRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Use this endpoint to create a new user. The API will respond with the newly-created user object if successful, containing a `guid` that you\'ll set as the `user_guid` in other requests when required. Disabling a user means that accounts and transactions associated with it will not be updated in the background by MX. It will also restrict access to that userâ€™s data until they are no longer disabled.
     * @summary Create user
     * @param {UserCreateRequestBody} userCreateRequestBody User object to be created. (None of these parameters are required, but the user object cannot be empty)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userCreateRequestBody: UserCreateRequestBody, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userCreateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete the specified `user`. The response will have a status of `204 No Content` without an object.  :::warning Deleting a user is permanent. Deleted users can never be restored. For more info, see [Deleting Objects](https://docs.mx.com/api-reference/platform-api/overview/deleting-objects). ::: 
     * @summary Delete user
     * @param {string} accept Specifies the media type expected in the response.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(accept: string, userGuid: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(accept, userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list every user you\'ve created in the MX Platform API.
     * @summary List users
     * @param {number} [page] Results are paginated. Specify current page.
     * @param {number} [recordsPerPage] This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
     * @param {string} [id] The user &#x60;id&#x60; to search for.
     * @param {string} [email] The user &#x60;email&#x60; to search for.
     * @param {boolean} [isDisabled] Search for users that are diabled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(page?: number, recordsPerPage?: number, id?: string, email?: string, isDisabled?: boolean, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(page, recordsPerPage, id, email, isDisabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to read the attributes of a specific user.
     * @summary Read user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUser(userGuid: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUser(userGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the attributes of the specified user.
     * @summary Update user
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {UserUpdateRequestBody} userUpdateRequestBody User object to be updated (None of these parameters are required, but the user object cannot be empty.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userGuid: string, userUpdateRequestBody: UserUpdateRequestBody, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userGuid, userUpdateRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerifiableCredentialsApi - axios parameter creator
 * @export
 */
export const VerifiableCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an MX-issued verifiable credential of a user\'s accounts data.
         * @summary Get Accounts Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsData: async (userGuid: string, memberGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('getAccountsData', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('getAccountsData', 'memberGuid', memberGuid)
            const localVarPath = `/vc/users/{user_guid}/members/{member_guid}/accounts`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an MX-issued verifiable credential of a user\'s identity data.
         * @summary Get Identity Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityData: async (userGuid: string, memberGuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('getIdentityData', 'userGuid', userGuid)
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('getIdentityData', 'memberGuid', memberGuid)
            const localVarPath = `/vc/users/{user_guid}/members/{member_guid}/customers`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an MX-issued verifiable credential of a user\'s transaction data.
         * @summary Get Transactions Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} [startTime] Filter transactions from this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
         * @param {string} [endTime] Filter transactions to this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsData: async (userGuid: string, accountGuid: string, startTime?: string, endTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('getTransactionsData', 'userGuid', userGuid)
            // verify required parameter 'accountGuid' is not null or undefined
            assertParamExists('getTransactionsData', 'accountGuid', accountGuid)
            const localVarPath = `/vc/users/{user_guid}/accounts/{account_guid}/transactions`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)))
                .replace(`{${"account_guid"}}`, encodeURIComponent(String(accountGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerifiableCredentialsApi - functional programming interface
 * @export
 */
export const VerifiableCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerifiableCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an MX-issued verifiable credential of a user\'s accounts data.
         * @summary Get Accounts Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsData(userGuid: string, memberGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VCResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsData(userGuid, memberGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an MX-issued verifiable credential of a user\'s identity data.
         * @summary Get Identity Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityData(userGuid: string, memberGuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VCResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityData(userGuid, memberGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an MX-issued verifiable credential of a user\'s transaction data.
         * @summary Get Transactions Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} [startTime] Filter transactions from this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
         * @param {string} [endTime] Filter transactions to this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsData(userGuid: string, accountGuid: string, startTime?: string, endTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VCResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsData(userGuid, accountGuid, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VerifiableCredentialsApi - factory interface
 * @export
 */
export const VerifiableCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerifiableCredentialsApiFp(configuration)
    return {
        /**
         * Get an MX-issued verifiable credential of a user\'s accounts data.
         * @summary Get Accounts Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsData(userGuid: string, memberGuid: string, options?: any): AxiosPromise<VCResponse> {
            return localVarFp.getAccountsData(userGuid, memberGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an MX-issued verifiable credential of a user\'s identity data.
         * @summary Get Identity Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityData(userGuid: string, memberGuid: string, options?: any): AxiosPromise<VCResponse> {
            return localVarFp.getIdentityData(userGuid, memberGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an MX-issued verifiable credential of a user\'s transaction data.
         * @summary Get Transactions Data
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
         * @param {string} [startTime] Filter transactions from this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
         * @param {string} [endTime] Filter transactions to this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsData(userGuid: string, accountGuid: string, startTime?: string, endTime?: string, options?: any): AxiosPromise<VCResponse> {
            return localVarFp.getTransactionsData(userGuid, accountGuid, startTime, endTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerifiableCredentialsApi - object-oriented interface
 * @export
 * @class VerifiableCredentialsApi
 * @extends {BaseAPI}
 */
export class VerifiableCredentialsApi extends BaseAPI {
    /**
     * Get an MX-issued verifiable credential of a user\'s accounts data.
     * @summary Get Accounts Data
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableCredentialsApi
     */
    public getAccountsData(userGuid: string, memberGuid: string, options?: AxiosRequestConfig) {
        return VerifiableCredentialsApiFp(this.configuration).getAccountsData(userGuid, memberGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an MX-issued verifiable credential of a user\'s identity data.
     * @summary Get Identity Data
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableCredentialsApi
     */
    public getIdentityData(userGuid: string, memberGuid: string, options?: AxiosRequestConfig) {
        return VerifiableCredentialsApiFp(this.configuration).getIdentityData(userGuid, memberGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an MX-issued verifiable credential of a user\'s transaction data.
     * @summary Get Transactions Data
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} accountGuid The unique id for an &#x60;account&#x60;.
     * @param {string} [startTime] Filter transactions from this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
     * @param {string} [endTime] Filter transactions to this date. Must be in the format YYYY-MM-DD. The range is limited to 1 year.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableCredentialsApi
     */
    public getTransactionsData(userGuid: string, accountGuid: string, startTime?: string, endTime?: string, options?: AxiosRequestConfig) {
        return VerifiableCredentialsApiFp(this.configuration).getTransactionsData(userGuid, accountGuid, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WidgetsApi - axios parameter creator
 * @export
 */
export const WidgetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will return a URL for an embeddable version of MX Connect.
         * @summary (Deprecated) Request connect widget URL
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ConnectWidgetRequestBody} connectWidgetRequestBody Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        requestConnectWidgetURL: async (userGuid: string, connectWidgetRequestBody: ConnectWidgetRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('requestConnectWidgetURL', 'userGuid', userGuid)
            // verify required parameter 'connectWidgetRequestBody' is not null or undefined
            assertParamExists('requestConnectWidgetURL', 'connectWidgetRequestBody', connectWidgetRequestBody)
            const localVarPath = `/users/{user_guid}/connect_widget_url`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectWidgetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will generate an `oauth_window_uri` for the specified `member`.
         * @summary Request oauth window uri
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [clientRedirectUrl] A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;.
         * @param {string} [enableApp2app] This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. When set to &#x60;false&#x60;, any &#x60;oauth_window_uri&#x60; generated will **not** direct the end user to the institution\&#39;s mobile application. This setting is not persistent. This setting currently only affects Chase institutions.
         * @param {string} [referralSource] Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;.
         * @param {boolean} [skipAggregation] Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page.
         * @param {string} [uiMessageWebviewUrlScheme] A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOAuthWindowURI: async (memberGuid: string, userGuid: string, clientRedirectUrl?: string, enableApp2app?: string, referralSource?: string, skipAggregation?: boolean, uiMessageWebviewUrlScheme?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberGuid' is not null or undefined
            assertParamExists('requestOAuthWindowURI', 'memberGuid', memberGuid)
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('requestOAuthWindowURI', 'userGuid', userGuid)
            const localVarPath = `/users/{user_guid}/members/{member_guid}/oauth_window_uri`
                .replace(`{${"member_guid"}}`, encodeURIComponent(String(memberGuid)))
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (clientRedirectUrl !== undefined) {
                localVarQueryParameter['client_redirect_url'] = clientRedirectUrl;
            }

            if (enableApp2app !== undefined) {
                localVarQueryParameter['enable_app2app'] = enableApp2app;
            }

            if (referralSource !== undefined) {
                localVarQueryParameter['referral_source'] = referralSource;
            }

            if (skipAggregation !== undefined) {
                localVarQueryParameter['skip_aggregation'] = skipAggregation;
            }

            if (uiMessageWebviewUrlScheme !== undefined) {
                localVarQueryParameter['ui_message_webview_url_scheme'] = uiMessageWebviewUrlScheme;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an embeddable URL for integrating a widget into your website or app. The URL expires after ten minutes or upon first use, whichever occurs first. You\'ll need to obtain a new URL each time the page loads or reloads.  Include the `widget_type` in the request body to specify which widget you want to embedâ€”the Connect Widget, a Personal Financial Management widget, or an Insights widget. Some request parameters are specific to certain widget types.  To embed the Connect Widget, set `widget_type` to `connect_widget`.  For a full list of available widget types, see [Widget Types](/api-reference/platform-api/reference/widgets#widget-types). 
         * @summary Request widget URL
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {WidgetRequestBody} widgetRequestBody The widget url configuration options.
         * @param {string} [acceptLanguage] The desired language of the widget.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestWidgetURL: async (userGuid: string, widgetRequestBody: WidgetRequestBody, acceptLanguage?: string, xCALLBACKPAYLOAD?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGuid' is not null or undefined
            assertParamExists('requestWidgetURL', 'userGuid', userGuid)
            // verify required parameter 'widgetRequestBody' is not null or undefined
            assertParamExists('requestWidgetURL', 'widgetRequestBody', widgetRequestBody)
            const localVarPath = `/users/{user_guid}/widget_urls`
                .replace(`{${"user_guid"}}`, encodeURIComponent(String(userGuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            if (xCALLBACKPAYLOAD != null) {
                localVarHeaderParameter['X-CALLBACK-PAYLOAD'] = String(xCALLBACKPAYLOAD);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(widgetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WidgetsApi - functional programming interface
 * @export
 */
export const WidgetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WidgetsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will return a URL for an embeddable version of MX Connect.
         * @summary (Deprecated) Request connect widget URL
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ConnectWidgetRequestBody} connectWidgetRequestBody Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async requestConnectWidgetURL(userGuid: string, connectWidgetRequestBody: ConnectWidgetRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectWidgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestConnectWidgetURL(userGuid, connectWidgetRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will generate an `oauth_window_uri` for the specified `member`.
         * @summary Request oauth window uri
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [clientRedirectUrl] A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;.
         * @param {string} [enableApp2app] This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. When set to &#x60;false&#x60;, any &#x60;oauth_window_uri&#x60; generated will **not** direct the end user to the institution\&#39;s mobile application. This setting is not persistent. This setting currently only affects Chase institutions.
         * @param {string} [referralSource] Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;.
         * @param {boolean} [skipAggregation] Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page.
         * @param {string} [uiMessageWebviewUrlScheme] A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOAuthWindowURI(memberGuid: string, userGuid: string, clientRedirectUrl?: string, enableApp2app?: string, referralSource?: string, skipAggregation?: boolean, uiMessageWebviewUrlScheme?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthWindowResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestOAuthWindowURI(memberGuid, userGuid, clientRedirectUrl, enableApp2app, referralSource, skipAggregation, uiMessageWebviewUrlScheme, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an embeddable URL for integrating a widget into your website or app. The URL expires after ten minutes or upon first use, whichever occurs first. You\'ll need to obtain a new URL each time the page loads or reloads.  Include the `widget_type` in the request body to specify which widget you want to embedâ€”the Connect Widget, a Personal Financial Management widget, or an Insights widget. Some request parameters are specific to certain widget types.  To embed the Connect Widget, set `widget_type` to `connect_widget`.  For a full list of available widget types, see [Widget Types](/api-reference/platform-api/reference/widgets#widget-types). 
         * @summary Request widget URL
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {WidgetRequestBody} widgetRequestBody The widget url configuration options.
         * @param {string} [acceptLanguage] The desired language of the widget.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestWidgetURL(userGuid: string, widgetRequestBody: WidgetRequestBody, acceptLanguage?: string, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestWidgetURL(userGuid, widgetRequestBody, acceptLanguage, xCALLBACKPAYLOAD, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WidgetsApi - factory interface
 * @export
 */
export const WidgetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WidgetsApiFp(configuration)
    return {
        /**
         * This endpoint will return a URL for an embeddable version of MX Connect.
         * @summary (Deprecated) Request connect widget URL
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {ConnectWidgetRequestBody} connectWidgetRequestBody Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        requestConnectWidgetURL(userGuid: string, connectWidgetRequestBody: ConnectWidgetRequestBody, options?: any): AxiosPromise<ConnectWidgetResponseBody> {
            return localVarFp.requestConnectWidgetURL(userGuid, connectWidgetRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will generate an `oauth_window_uri` for the specified `member`.
         * @summary Request oauth window uri
         * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {string} [clientRedirectUrl] A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;.
         * @param {string} [enableApp2app] This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. When set to &#x60;false&#x60;, any &#x60;oauth_window_uri&#x60; generated will **not** direct the end user to the institution\&#39;s mobile application. This setting is not persistent. This setting currently only affects Chase institutions.
         * @param {string} [referralSource] Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;.
         * @param {boolean} [skipAggregation] Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page.
         * @param {string} [uiMessageWebviewUrlScheme] A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOAuthWindowURI(memberGuid: string, userGuid: string, clientRedirectUrl?: string, enableApp2app?: string, referralSource?: string, skipAggregation?: boolean, uiMessageWebviewUrlScheme?: string, options?: any): AxiosPromise<OAuthWindowResponseBody> {
            return localVarFp.requestOAuthWindowURI(memberGuid, userGuid, clientRedirectUrl, enableApp2app, referralSource, skipAggregation, uiMessageWebviewUrlScheme, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an embeddable URL for integrating a widget into your website or app. The URL expires after ten minutes or upon first use, whichever occurs first. You\'ll need to obtain a new URL each time the page loads or reloads.  Include the `widget_type` in the request body to specify which widget you want to embedâ€”the Connect Widget, a Personal Financial Management widget, or an Insights widget. Some request parameters are specific to certain widget types.  To embed the Connect Widget, set `widget_type` to `connect_widget`.  For a full list of available widget types, see [Widget Types](/api-reference/platform-api/reference/widgets#widget-types). 
         * @summary Request widget URL
         * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
         * @param {WidgetRequestBody} widgetRequestBody The widget url configuration options.
         * @param {string} [acceptLanguage] The desired language of the widget.
         * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestWidgetURL(userGuid: string, widgetRequestBody: WidgetRequestBody, acceptLanguage?: string, xCALLBACKPAYLOAD?: string, options?: any): AxiosPromise<WidgetResponseBody> {
            return localVarFp.requestWidgetURL(userGuid, widgetRequestBody, acceptLanguage, xCALLBACKPAYLOAD, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WidgetsApi - object-oriented interface
 * @export
 * @class WidgetsApi
 * @extends {BaseAPI}
 */
export class WidgetsApi extends BaseAPI {
    /**
     * This endpoint will return a URL for an embeddable version of MX Connect.
     * @summary (Deprecated) Request connect widget URL
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {ConnectWidgetRequestBody} connectWidgetRequestBody Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof WidgetsApi
     */
    public requestConnectWidgetURL(userGuid: string, connectWidgetRequestBody: ConnectWidgetRequestBody, options?: AxiosRequestConfig) {
        return WidgetsApiFp(this.configuration).requestConnectWidgetURL(userGuid, connectWidgetRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will generate an `oauth_window_uri` for the specified `member`.
     * @summary Request oauth window uri
     * @param {string} memberGuid The unique id for a &#x60;member&#x60;.
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {string} [clientRedirectUrl] A URL that MX will redirect to at the end of OAuth with additional query parameters. Only available with &#x60;referral_source&#x3D;APP&#x60;.
     * @param {string} [enableApp2app] This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to &#x60;true&#x60;. When set to &#x60;false&#x60;, any &#x60;oauth_window_uri&#x60; generated will **not** direct the end user to the institution\&#39;s mobile application. This setting is not persistent. This setting currently only affects Chase institutions.
     * @param {string} [referralSource] Must be either &#x60;BROWSER&#x60; or &#x60;APP&#x60; depending on the implementation. Defaults to &#x60;BROWSER&#x60;.
     * @param {boolean} [skipAggregation] Setting this parameter to &#x60;true&#x60; will prevent the member from automatically aggregating after being redirected from the authorization page.
     * @param {string} [uiMessageWebviewUrlScheme] A scheme for routing the user back to the application state they were previously in. Only available with &#x60;referral_source&#x3D;APP&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsApi
     */
    public requestOAuthWindowURI(memberGuid: string, userGuid: string, clientRedirectUrl?: string, enableApp2app?: string, referralSource?: string, skipAggregation?: boolean, uiMessageWebviewUrlScheme?: string, options?: AxiosRequestConfig) {
        return WidgetsApiFp(this.configuration).requestOAuthWindowURI(memberGuid, userGuid, clientRedirectUrl, enableApp2app, referralSource, skipAggregation, uiMessageWebviewUrlScheme, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an embeddable URL for integrating a widget into your website or app. The URL expires after ten minutes or upon first use, whichever occurs first. You\'ll need to obtain a new URL each time the page loads or reloads.  Include the `widget_type` in the request body to specify which widget you want to embedâ€”the Connect Widget, a Personal Financial Management widget, or an Insights widget. Some request parameters are specific to certain widget types.  To embed the Connect Widget, set `widget_type` to `connect_widget`.  For a full list of available widget types, see [Widget Types](/api-reference/platform-api/reference/widgets#widget-types). 
     * @summary Request widget URL
     * @param {string} userGuid The unique identifier for a &#x60;user&#x60;, beginning with the prefix &#x60;USR-&#x60;.
     * @param {WidgetRequestBody} widgetRequestBody The widget url configuration options.
     * @param {string} [acceptLanguage] The desired language of the widget.
     * @param {string} [xCALLBACKPAYLOAD] The base64 encoded string defined in this header will be returned in the [Member](/resources/webhooks/member/) and [Member Data Updated](/resources/webhooks/member#member-data-updated) webhooks. This allows you to trace user interactions and workflows initiated externally and internally in the MX Platform. Max 1024 characters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetsApi
     */
    public requestWidgetURL(userGuid: string, widgetRequestBody: WidgetRequestBody, acceptLanguage?: string, xCALLBACKPAYLOAD?: string, options?: AxiosRequestConfig) {
        return WidgetsApiFp(this.configuration).requestWidgetURL(userGuid, widgetRequestBody, acceptLanguage, xCALLBACKPAYLOAD, options).then((request) => request(this.axios, this.basePath));
    }
}



